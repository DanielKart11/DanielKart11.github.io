{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "JavaGuide(Java面试 + 学习指南)",
  "home_page_url": "https://javaguide.cn/",
  "feed_url": "https://javaguide.cn/feed.json",
  "description": "「Java学习指北 + Java面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，复习 Java 知识点，首选 JavaGuide！  ",
  "favicon": "https://javaguide.cn/favicon.ico",
  "items": [
    {
      "title": "美团三年，总结的10条血泪教训",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10.html",
      "summary": "推荐语：作者用了很多生动的例子和故事展示了自己在美团的成长和感悟，看了之后受益颇多！ 内容概览： 本文的作者提出了以下十条建议，希望能对其他职场人有所启发和帮助： 结构化思考与表达，提高个人影响力 忘掉职级，该怼就怼，推动事情往前走 用好平台资源，结识优秀的人，学习通识课 一切都是争取来的，不要等待机会，要主动寻求 关注商业，升维到老板思维，看清趋势，及时止损 培养数据思维，利用数据了解世界，指导决策 做一个好\"销售\"，无论是自己还是产品，都要学会展示和说服 少加班多运动，保持身心健康，提高工作效率 有随时可以离开的底气，不要被职场所困，借假修真，提升自己 只是一份工作，不要过分纠结，相信自己，走出去看看 原文地址：https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：作者用了很多生动的例子和故事展示了自己在美团的成长和感悟，看了之后受益颇多！</p>\n<br>\n<p><strong>内容概览</strong>：</p>\n<p>本文的作者提出了以下十条建议，希望能对其他职场人有所启发和帮助：</p>\n<ol>\n<li>结构化思考与表达，提高个人影响力</li>\n<li>忘掉职级，该怼就怼，推动事情往前走</li>\n<li>用好平台资源，结识优秀的人，学习通识课</li>\n<li>一切都是争取来的，不要等待机会，要主动寻求</li>\n<li>关注商业，升维到老板思维，看清趋势，及时止损</li>\n<li>培养数据思维，利用数据了解世界，指导决策</li>\n<li>做一个好\"销售\"，无论是自己还是产品，都要学会展示和说服</li>\n<li>少加班多运动，保持身心健康，提高工作效率</li>\n<li>有随时可以离开的底气，不要被职场所困，借假修真，提升自己</li>\n<li>只是一份工作，不要过分纠结，相信自己，走出去看看</li>\n</ol>\n<p><strong>原文地址</strong>：<a href=\"https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ</a></p>\n</blockquote>\n<p>在美团的三年多时光，如同一部悠长的交响曲，高高低低，而今离开已有一段时间。闲暇之余，梳理了三年多的收获与感慨，总结成 10 条，既是对过去一段时光的的一个深情回眸，也是对未来之路的一份期许。</p>\n<p>倘若一些感悟能为刚步入职场的年轻人，或是刚在职业生涯中崭露头角的后起之秀，带来一点点启示与帮助，也是莫大的荣幸。</p>\n<h2> 01 结构化思考与表达</h2>\n<p>美团是一家特别讲究方法论的公司，人人都要熟读四大名著《高效能人士的七个习惯》、《金字塔原理》、《用图表说话》和《学会提问》。</p>\n<p>与结构化思考和表达相关的，是《金字塔原理》，作者是麦肯锡公司第一位女性咨询顾问。这本书告诉我们，思考和表达的过程，就像构建金字塔（或者构建一棵树），先有整体结论，再寻找证据，证据之间要讲究相互独立、而且能穷尽（MECE 原则），论证的过程也要按特定的顺序进行，比如时间顺序、空间顺序、重要性顺序……</p>\n<p>作为大厂社畜，日常很大一部分工作就是写文档、看别人文档。大家做的事，但最后呈现的结果却有很大差异。一篇逻辑清晰、详略得当的文档，给人一种如沐春风的感受，能提炼出重要信息，是好的参考指南。</p>\n<p>结构化思考与表达算是职场最通用的能力，也是打造个人影响力最重要的途径之一。</p>\n<h2> 02 忘掉职级，该怼就怼</h2>\n<p>在阿里工作时，能看到每个人的 Title，看到江湖地位高（职级高+入职时间早）的同学，即便跟自己没有汇报关系，不自然的会多一层敬畏。推进工作时，会多一层压力，对方未读或已读未回时，不知如何应对。</p>\n<p>美团只能看到每个人的坑位信息，还有 Ta 的上级。工作相关的问题，可以向任何人提问，如果协同方没有及时响应，隔段时间@一次，甚至\"怼一怼\"，都没啥问题，事情一直往前推进才最重要。除了大象消息直接提问外，还有个大杀器--TT（公司级问题流转系统），在上面提问时，加上对方主管，如果对方未及时回应，问题会自动升级，每天定时 Push，直到解决为止。</p>\n<p>我见到一些很年轻的同事，他们在推动 OKR、要资源的事上，很有一套，只要能达到自己的目标，不会考虑别人的感受，最终，他们还真能把事办成。</p>\n<p>当然了，段位越高的人，越能用自己的人格魅力、影响力、资源等，去影响和推动事情的进程，而不是靠对他人的 Push。只是在拿结果的事上，不要把自己太当回事，把别人太当回事，大家在一起，也只是为了完成各自的任务，忘掉职级，该怼时还得怼。</p>\n<h2> 03 用好平台资源</h2>\n<p>没有人能在一家公司待一辈子，公司再牛，跟自己关系不大，重要的是，在有限的时间内，最大化用好平台资源。</p>\n<p>在美团除了认识自己节点的同事外，有幸认识一群特别棒的协作方，还有其他 BU 的同学。</p>\n<p>这些优秀的人身上，有很多共同的特质：谦虚、利他、乐于分享、双赢思维。</p>\n<p>有两位做运营的同学。</p>\n<p>一位是无意中关注他公众号结识上的。他公众号记录了很多职场成长、家庭建造上的思考和收获，还有定期个人复盘。他和太太都是大厂中层管理者，从文章中看到的不是他多厉害，而是非常接地气的故事。我们约饭了两次，有很多共同话题，现在还时不时有一些互动。</p>\n<p>一位职级更高的同学，他在内网发起了一个\"请我喝一杯咖啡，和我一起聊聊个人困惑\"的活动，我报名参与了一期。和他聊天的过程，特别像是一场教练对话（最近学习教练课程时才感受到的），帮我排除干扰、聚焦目标的同时，也从他分享个人成长蜕变的过程，收获很多动力。（刚好自己最近也学习了教练技术，后面也准备采用类似的方式，去帮助曾经像我一样迷茫的人）</p>\n<p>还有一些协作方同学。他们工作做得超级到位，能感受到，他们在乎他人时间；稍微有点出彩的事儿，不忘记拉上更多人。利他和双赢思维，在他们身上是最好的阐释。</p>\n<p>除了结识优秀的人，向他们学习外，还可以关注各个通道/工种的课程资源。</p>\n<p>在大厂，多数人的角色都是螺丝钉，但千万不要局限于做一颗螺丝钉。多去学习一些通识课，了解商业交付的各个环节，看清商业世界，明白自己的定位，超越自己的定位。</p>\n<h2> 04 一切都是争取来的</h2>\n<p>工作很多年了，很晚才明白这个道理。</p>\n<p>之前一直认为，只要做好自己该做的，一定会被看见，被赏识，也会得到更多机会。但很多时候，这只是个人的一厢情愿。除了自己，不会有人关心你的权益。</p>\n<p>社会主义初级阶段，我国国内的主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。无论在哪里，资源都是稀缺的，自己在乎的，就得去争取。</p>\n<p>想成长某个技能、想参与哪个模块、想做哪个项目，升职加薪……自己不提，不去争取，不会有人主动给你。</p>\n<p>争不争取是一回事，能不能得到是一回事，只有争取，才有可能得到。争取了，即便没有得到，最终也没失去什么。</p>\n<h2> 05 关注商业</h2>\n<p>大公司，极度关注效率，大部分岗位，拆解的粒度越细，效率会越高，这些对组织是有利的。但对个人来说，则很容易螺丝钉化。</p>\n<p>做技术的同学，更是这样。</p>\n<p>做前端的同学，不会关注数据是如何落库的；做后端的同学，不会思考页面是否存在兼容性问题；做业务开发的，不用考虑微服务诸多中间件是如何搭建起来的……</p>\n<p>大部分人都想着怎么把自己这摊子事搞好，不会去思考上下游同学在做些什么，更少有人真正关注商业，关心公司的盈利模式，关心每一次产品迭代到底带来哪些业务价值。</p>\n<p>把手头的事做好是应该的，但绝不能停留在此。所有的产品，只有在商业社会产生交付，让客户真正获益，才是有价值的。</p>\n<p>关注商业，能帮我们升维到老板思维，明白投入产出比，抓大放小；也帮助我们，在碰到不好的业务时，及时止损；更重要的是，它帮助我们真正看清趋势，提前做好准备。</p>\n<p>《五分钟商学院》系列，是很好的商业入门级书籍。尽管作者刘润最近存在争议，但不可否认，他比我们大多数人段位还是高很多，他的书值得一读。</p>\n<h2> 06 培养数据思维</h2>\n<p>当今数字化时代，数据思维显得尤为重要。数据不仅可以帮助我们更好地了解世界，还可以指导我们的决策和行动。</p>\n<p>非常幸运的是，在阿里和美团的两份经历，都是做商业化广告业务，在离钱💰最近的地方，也培养了数据的敏感性。见过商业数据指标的定义、加工、生产和应用全流程，也在不断熏陶下，能看懂大部分指标背后的价值。</p>\n<p>除了直接面向业务的数据，还有研发协作全流程产生的数据。数据被记录和汇总统计后，能直观地看到每个环节的效率和质量。螺丝钉们的工作，也彻彻底底被数字量化，除了积极面对虚拟化、线上化、数字化外，我们别无他法。</p>\n<p>受工作数据化的影响，生活中，我也渐渐变成了一个数据记录狂，日常运动（骑行、跑步、健走等）必须通过智能手表记录下来，没带 Apple Watch，感觉这次白运动了。每天也在很努力地完成三个圆环。</p>\n<p>数据时代，我们沦为了透明人。也得益于数据被记录和分析，我们做任何事，都能快速得到反馈，这也是自我提升的一个重要环节。</p>\n<h2> 07 做一个好\"销售\"</h2>\n<p>就某种程度来说，所有的工作，本质都是销售。</p>\n<p>这是很多大咖的观点，我也是很晚才明白这个道理。</p>\n<p>我们去一家公司应聘，本质上是在讲一个「我很牛」的故事，销售的是自己；日常工作汇报、季度/年度述职、晋升答辩，是在销售自己；在任何一个场合曝光，也是在销售自己。</p>\n<p>如果我们所服务的组织，对外提供的是一件产品或一项服务，所有上下游协作的同学，唯一在做的事就是，齐心协力把产品/服务卖出去， 我们本质做的还是销售。</p>\n<p>所以， 千万不要看不起任何销售，也不要认为认为销售是一件很丢面子的事。</p>\n<p>真正的大佬，随时随地都在销售。</p>\n<h2> 08 少加班多运动</h2>\n<p>在职场，大家都认同一个观点，工作是做不完的。</p>\n<p>我们要做的是，用好时间管理四象限法，识别重要程度和优先级，有限时间，聚焦在固定几件事上。</p>\n<p>这要求我们不断提高自己的问题识别能力、拆解能力，还有专注力。</p>\n<p>我们会因为部分项目的需要而加班，但不会长期加班。</p>\n<p>加班时间短一点，就能腾出更多时间运动。</p>\n<p>最近一次线下培训课，认识一位老师 Hubert，Hubert 是一位超级有魅力的中年大叔（可以通过「有意思教练」的课程链接到他），从外企高管的位置离开后，和太太一起创办了一家培训机构。作为公司高层，日常工作非常忙，头发也有些花白了，但一身腱子肉胜过很多健身教练，给人的状态也是很年轻。聊天得知，Hubert 经常 5 点多起来泡健身房~</p>\n<p>我身边还有一些同事，跟我年龄差不多，因为长期加班，发福严重，比实际年龄看起来苍老 10+岁；</p>\n<p>还有同事曾经加班进 ICU，幸好后面身体慢慢恢复过来。</p>\n<p>某某厂员工长期加班猝死的例子，更是屡见不鲜。</p>\n<p>减少加班，增加运动，绝对是一件性价比极高的事。</p>\n<h2> 09 有随时可以离开的底气</h2>\n<p>当今职场，跟父辈时候完全不一样，职业的多样性和变化性越来越快，很少有人能够在同一份工作或同一个公司待一辈子。除了某些特定的岗位，如公务员、事业单位等，大多数人都会在职业生涯中经历多次的职业变化和调整。</p>\n<p>在商业组织里，个体是弱势群体，但不要做弱者。每一段职场，每一项工作，都是上天给我们的修炼。</p>\n<p>我很喜欢\"借假修真\"这个词。我们参与的大大小小的项目， 重要吗？对公司来说可能重要，对个人来说，则未必。我们去做，一方面是迫于生计；</p>\n<p>另外一方面，参与每个项目的感悟、心得、体会，是真实存在的，很多的能力，都是在这个过程得到提升。</p>\n<p>明白这一点，就不会被职场所困，会刻意在各样事上提升自己，积累的越多，对事务的本质理解的越深、越广，也越发相信很多底层知识是通用的，内心越平静，也会建立起随时都可以离开的底气。</p>\n<h2> 10 只是一份工作</h2>\n<p>工作中，我们时常会遇到各种挑战和困难，如发展瓶颈、难以处理的人和事，甚至职场 PUA 等。这些经历可能会让我们感到疲惫、沮丧，甚至怀疑自己的能力和价值。然而，重要的是要明白，困难只是成长道路上的暂时阻碍，而不是我们的定义。</p>\n<p>写总结和复盘是很好的方式，可以帮我们理清思路，找到问题的根源，并学习如何应对类似的情况。但也要注意不要陷入自我怀疑和内耗的陷阱。遇到困难时，应该学会相信自己，积极寻找解决问题的方法，而不是过分纠结于自己的不足和错误。</p>\n<p>内网常有同学匿名分享工作压力过大，常常失眠甚至中度抑郁，每次看到这些话题，非常难过。大环境不好，是不争的事实，但并不代表个体就没有出路。</p>\n<p>我们容易预设困难，容易加很多\"可是\"，当窗户布满灰尘时，不要试图努力把窗户擦干净，走出去吧，你将看到一片蔚蓝的天空。</p>\n<h2> 最后</h2>\n<p>写到最后，特别感恩美团三年多的经历。感谢我的 Leader 们，感谢曾经并肩作战过的小伙伴，感谢遇到的每一位和我一样在平凡的岗位，努力想带给身边一片微光的同学。所有的相遇，都是缘分。</p>\n",
      "date_published": "2023-12-17T07:37:37.000Z",
      "date_modified": "2023-12-17T07:37:37.000Z",
      "authors": [
        {
          "name": "CityDreamer部落"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "程序员如何快速学习新技术",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology.html",
      "summary": "推荐语：这是《Java 面试指北》练级攻略篇中的一篇文章，分享了我对于如何快速学习一门新技术的看法。 《Java 面试指北》练级攻略篇",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这是<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>练级攻略篇中的一篇文章，分享了我对于如何快速学习一门新技术的看法。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/training-strategy-articles.png\" alt=\"《Java 面试指北》练级攻略篇\" tabindex=\"0\"><figcaption>《Java 面试指北》练级攻略篇</figcaption></figure>\n</blockquote>\n<p>很多时候，我们因为工作原因需要快速学习某项技术，进而在项目中应用。或者说，我们想要去面试的公司要求的某项技术我们之前没有接触过，为了应对面试需要，我们需要快速掌握这项技术。</p>\n<p>作为一个人纯自学出生的程序员，这篇文章简单聊聊自己对于如何快速学习某项技术的看法。</p>\n<p>学习任何一门技术的时候，一定要先搞清楚这个技术是为了解决什么问题的。深入学习这个技术的之前，一定先从全局的角度来了解这个技术，思考一下它是由哪些模块构成的，提供了哪些功能，和同类的技术想必它有什么优势。</p>\n<p>比如说我们在学习 Spring 的时候，通过 Spring 官方文档你就可以知道 Spring 最新的技术动态，Spring 包含哪些模块 以及 Spring 可以帮你解决什么问题。</p>\n<figure><img src=\"https://img-blog.csdnimg.cn/20210506110341207.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>再比如说我在学习消息队列的时候，我会先去了解这个消息队列一般在系统中有什么作用，帮助我们解决了什么问题。消息队列的种类很多，具体学习研究某个消息队列的时候，我会将其和自己已经学习过的消息队列作比较。像我自己在学习 RocketMQ 的时候，就会先将其和自己曾经学习过的第 1 个消息队列 ActiveMQ 进行比较，思考 RocketMQ 相对于 ActiveMQ 有了哪些提升，解决了 ActiveMQ 的哪些痛点，两者有哪些相似的地方，又有哪些不同的地方。</p>\n<p><strong>学习一个技术最有效最快的办法就是将这个技术和自己之前学到的技术建立连接，形成一个网络。</strong></p>\n<p>然后，我建议你先去看看官方文档的教程，运行一下相关的 Demo ，做一些小项目。</p>\n<p>不过，官方文档通常是英文的，通常只有国产项目以及少部分国外的项目提供了中文文档。并且，官方文档介绍的往往也比较粗糙，不太适合初学者作为学习资料。</p>\n<p>如果你看不太懂官网的文档，你也可以搜索相关的关键词找一些高质量的博客或者视频来看。 <strong>一定不要一上来就想着要搞懂这个技术的原理。</strong></p>\n<p>就比如说我们在学习 Spring 框架的时候，我建议你在搞懂 Spring 框架所解决的问题之后，不是直接去开始研究 Spring 框架的原理或者源码，而是先实际去体验一下 Spring 框架提供的核心功能 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)，使用  Spring 框架写一些 Demo，甚至是使用   Spring 框架做一些小项目。</p>\n<p>一言以蔽之， <strong>在研究这个技术的原理之前，先要搞懂这个技术是怎么使用的。</strong></p>\n<p>这样的循序渐进的学习过程，可以逐渐帮你建立学习的快感，获得即时的成就感，避免直接研究原理性的知识而被劝退。</p>\n<p><strong>研究某个技术原理的时候，为了避免内容过于抽象，我们同样可以动手实践。</strong></p>\n<p>比如说我们学习 Tomcat 原理的时候，我们发现 Tomcat 的自定义线程池挺有意思，那我们自己也可以手写一个定制版的线程池。再比如我们学习 Dubbo 原理的时候，可以自己动手造一个简易版的 RPC 框架。</p>\n<p>另外，学习项目中需要用到的技术和面试中需要用到的技术其实还是有一些差别的。</p>\n<p>如果你学习某一项技术是为了在实际项目中使用的话，那你的侧重点就是学习这项技术的使用以及最佳实践，了解这项技术在使用过程中可能会遇到的问题。你的最终目标就是这项技术为项目带来了实际的效果，并且，这个效果是正面的。</p>\n<p>如果你学习某一项技术仅仅是为了面试的话，那你的侧重点就应该放在这项技术在面试中最常见的一些问题上，也就是我们常说的八股文。</p>\n<p>很多人一提到八股文，就是一脸不屑。在我看来，如果你不是死记硬背八股文，而是去所思考这些面试题的本质。那你在准备八股文的过程中，同样也能让你加深对这项技术的了解。</p>\n<p>最后，最重要同时也是最难的还是 <strong>知行合一！知行合一！知行合一！</strong> 不论是编程还是其他领域，最重要不是你知道的有多少，而是要尽量做到知行合一。</p>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/training-strategy-articles.png",
      "date_published": "2023-11-09T08:24:19.000Z",
      "date_modified": "2023-11-11T12:48:46.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "经典算法思想总结（含LeetCode题目推荐）",
      "url": "https://javaguide.cn/cs-basics/algorithms/classical-algorithm-problems-recommendations.html",
      "id": "https://javaguide.cn/cs-basics/algorithms/classical-algorithm-problems-recommendations.html",
      "summary": "贪心算法 算法思想 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 一般解题步骤 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 LeetCode 455.分发饼干：https://leetcode.cn/problems/assign-cookies/",
      "content_html": "<h2> 贪心算法</h2>\n<h3> 算法思想</h3>\n<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>\n<h3> 一般解题步骤</h3>\n<ul>\n<li>将问题分解为若干个子问题</li>\n<li>找出适合的贪心策略</li>\n<li>求解每一个子问题的最优解</li>\n<li>将局部最优解堆叠成全局最优解</li>\n</ul>\n<h3> LeetCode</h3>\n<p>455.分发饼干：<a href=\"https://leetcode.cn/problems/assign-cookies/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/assign-cookies/</a></p>\n<p>121.买卖股票的最佳时机：<a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>\n<p>122.买卖股票的最佳时机 II：<a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>\n<p>55.跳跃游戏：<a href=\"https://leetcode.cn/problems/jump-game/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/jump-game/</a></p>\n<p>45.跳跃游戏 II：<a href=\"https://leetcode.cn/problems/jump-game-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/jump-game-ii/</a></p>\n<h2> 动态规划</h2>\n<h3> 算法思想</h3>\n<p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>\n<p>经典题目：01 背包、完全背包</p>\n<h3> 一般解题步骤</h3>\n<ul>\n<li>确定 dp 数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp 数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导 dp 数组</li>\n</ul>\n<h3> LeetCode</h3>\n<p>509.斐波那契数：<a href=\"https://leetcode.cn/problems/fibonacci-number/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/fibonacci-number/</a></p>\n<p>746.使用最小花费爬楼梯：<a href=\"https://leetcode.cn/problems/min-cost-climbing-stairs/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>\n<p>416.分割等和子集：<a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>\n<p>518.零钱兑换：<a href=\"https://leetcode.cn/problems/coin-change-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/coin-change-ii/</a></p>\n<p>647.回文子串：<a href=\"https://leetcode.cn/problems/palindromic-substrings/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/palindromic-substrings/</a></p>\n<p>516.最长回文子序列：<a href=\"https://leetcode.cn/problems/longest-palindromic-subsequence/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>\n<h2> 回溯算法</h2>\n<h3> 算法思想</h3>\n<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条</p>\n<p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。</p>\n<p>经典题目：8 皇后</p>\n<h3> 一般解题步骤</h3>\n<ul>\n<li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>\n<li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>\n<li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>\n</ul>\n<h3> leetcode</h3>\n<p>77.组合：<a href=\"https://leetcode.cn/problems/combinations/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/combinations/</a></p>\n<p>39.组合总和：<a href=\"https://leetcode.cn/problems/combination-sum/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/combination-sum/</a></p>\n<p>40.组合总和 II：<a href=\"https://leetcode.cn/problems/combination-sum-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/combination-sum-ii/</a></p>\n<p>78.子集：<a href=\"https://leetcode.cn/problems/subsets/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/subsets/</a></p>\n<p>90.子集 II：<a href=\"https://leetcode.cn/problems/subsets-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/subsets-ii/</a></p>\n<p>51.N 皇后：<a href=\"https://leetcode.cn/problems/n-queens/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/n-queens/</a></p>\n<h2> 分治算法</h2>\n<h3> 算法思想</h3>\n<p>将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>\n<p>经典题目：二分查找、汉诺塔问题</p>\n<h3> 一般解题步骤</h3>\n<ul>\n<li>将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>\n<li>若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>\n<li>将各个子问题的解合并为原问题的解。</li>\n</ul>\n<h3> LeetCode</h3>\n<p>108.将有序数组转换成二叉搜索数：<a href=\"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>\n<p>148.排序列表：<a href=\"https://leetcode.cn/problems/sort-list/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/sort-list/</a></p>\n<p>23.合并 k 个升序链表：<a href=\"https://leetcode.cn/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>\n",
      "date_published": "2023-11-07T08:25:02.000Z",
      "date_modified": "2023-11-07T08:25:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "常见数据结构经典LeetCode题目推荐",
      "url": "https://javaguide.cn/cs-basics/algorithms/common-data-structures-leetcode-recommendations.html",
      "id": "https://javaguide.cn/cs-basics/algorithms/common-data-structures-leetcode-recommendations.html",
      "summary": "数组 704.二分查找：https://leetcode.cn/problems/binary-search/ 80.删除有序数组中的重复项 II：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii",
      "content_html": "<h2> 数组</h2>\n<p>704.二分查找：<a href=\"https://leetcode.cn/problems/binary-search/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/binary-search/</a></p>\n<p>80.删除有序数组中的重复项 II：<a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a></p>\n<p>977.有序数组的平方：<a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>\n<h2> 链表</h2>\n<p>707.设计链表：<a href=\"https://leetcode.cn/problems/design-linked-list/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/design-linked-list/</a></p>\n<p>206.反转链表：<a href=\"https://leetcode.cn/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/reverse-linked-list/</a></p>\n<p>92.反转链表 II：<a href=\"https://leetcode.cn/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>\n<p>61.旋转链表：<a href=\"https://leetcode.cn/problems/rotate-list/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/rotate-list/</a></p>\n<h2> 栈与队列</h2>\n<p>232.用栈实现队列：<a href=\"https://leetcode.cn/problems/implement-queue-using-stacks/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>\n<p>225.用队列实现栈：<a href=\"https://leetcode.cn/problems/implement-stack-using-queues/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>\n<p>347.前 K 个高频元素：<a href=\"https://leetcode.cn/problems/top-k-frequent-elements/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>\n<p>239.滑动窗口最大值：<a href=\"https://leetcode.cn/problems/sliding-window-maximum/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/sliding-window-maximum/</a></p>\n<h2> 二叉树</h2>\n<p>105.从前序与中序遍历构造二叉树：<a href=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>\n<p>117.填充每个节点的下一个右侧节点指针 II：<a href=\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</a></p>\n<p>236.二叉树的最近公共祖先：<a href=\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>\n<p>129.求根节点到叶节点数字之和：<a href=\"https://leetcode.cn/problems/sum-root-to-leaf-numbers/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>\n<p>102.二叉树的层序遍历：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>\n<p>530.二叉搜索树的最小绝对差：<a href=\"https://leetcode.cn/problems/minimum-absolute-difference-in-bst/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>\n<h2> 图</h2>\n<p>200.岛屿数量：<a href=\"https://leetcode.cn/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/number-of-islands/</a></p>\n<p>207.课程表：<a href=\"https://leetcode.cn/problems/course-schedule/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/course-schedule/</a></p>\n<p>210.课程表 II：<a href=\"https://leetcode.cn/problems/course-schedule-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/course-schedule-ii/</a></p>\n<h2> 堆</h2>\n<ol start=\"215\">\n<li>\n<p>数组中的第 K 个最大元素:<a href=\"https://leetcode.cn/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>\n</li>\n<li>\n<p>数据流的中位数:<a href=\"https://leetcode.cn/problems/find-median-from-data-stream/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>\n</li>\n<li>\n<p>前 K 个高频元素：<a href=\"https://leetcode.cn/problems/top-k-frequent-elements/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>\n</li>\n</ol>\n",
      "date_published": "2023-11-07T08:25:02.000Z",
      "date_modified": "2023-11-07T08:25:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "虚拟线程极简入门",
      "url": "https://javaguide.cn/java/concurrent/virtual-thread.html",
      "id": "https://javaguide.cn/java/concurrent/virtual-thread.html",
      "summary": "本文部分内容来自 Lorin 的PR。 虚拟线程在 Java 21 正式发布，这是一项重量级的更新。 什么是虚拟线程？",
      "content_html": "<blockquote>\n<p>本文部分内容来自 <a href=\"https://github.com/Lorin-github\" target=\"_blank\" rel=\"noopener noreferrer\">Lorin</a> 的<a href=\"https://github.com/Snailclimb/JavaGuide/pull/2190\" target=\"_blank\" rel=\"noopener noreferrer\">PR</a>。</p>\n</blockquote>\n<p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<h2> 什么是虚拟线程？</h2>\n<p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<h2> 虚拟线程和平台线程有什么关系？</h2>\n<p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程（Platform Thread），也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：<a href=\"https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7\" target=\"_blank\" rel=\"noopener noreferrer\">How to Use Java 19 Virtual Threads</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png\" alt=\"虚拟线程、平台线程和系统内核线程的关系\" tabindex=\"0\"><figcaption>虚拟线程、平台线程和系统内核线程的关系</figcaption></figure>\n<p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: <a href=\"https://www.zhihu.com/question/23096638/answer/29617153\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 中的线程模型是用户级的么？</a>。</p>\n<h2> 虚拟线程有什么优点和缺点？</h2>\n<h3> 优点</h3>\n<ul>\n<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>\n<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</li>\n<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>\n</ul>\n<h3> 缺点</h3>\n<ul>\n<li>不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</li>\n<li>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</li>\n</ul>\n<h2> 四种创建虚拟线程的方法</h2>\n<p>Java 21 已经正式支持虚拟线程，大家可以在官网下载使用，在使用上官方为了降低使用门槛，尽量复用原有的 <code>Thread</code> 类，让大家可以更加平滑的使用。</p>\n<p>官方提供了以下四种方式创建虚拟线程：</p>\n<ol>\n<li>使用 <code>Thread.startVirtualThread()</code> 创建</li>\n<li>使用 <code>Thread.ofVirtual()</code> 创建</li>\n<li>使用 <code>ThreadFactory</code> 创建</li>\n</ol>\n<h4> 使用 Thread.startVirtualThread()创建</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用 Thread.ofVirtual()创建</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用 ThreadFactory 创建</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用 Executors.newVirtualThreadPerTaskExecutor()创建</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 虚拟线程和平台线程性能对比</h2>\n<p>通过多线程和虚拟线程的方式处理相同的任务，对比创建的系统线程数和处理耗时。</p>\n<p><strong>说明</strong>：统计创建的系统线程中部分为后台线程（比如 GC 线程），两种场景下都一样，所以并不影响对比。</p>\n<p><strong>测试代码</strong>：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>请求数 10000 单请求耗时 1s</strong>：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>请求数 10000 单请求耗时 0.5s</strong>：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>可以看到在密集 IO 的场景下，需要创建大量的平台线程异步处理才能达到虚拟线程的处理速度。</li>\n<li>因此，在密集 IO 的场景，虚拟线程可以大幅提高线程的执行效率，减少线程资源的创建以及上下文切换。</li>\n<li>吐槽：虽然虚拟线程我很想用，但是我 Java8 有机会升级到 Java21 吗？呜呜</li>\n</ul>\n<p><strong>注意</strong>：有段时间 JDK 一直致力于 Reactor 响应式编程来提高 Java 性能，但响应式编程难以理解、调试、使用，最终又回到了同步编程，最终虚拟线程诞生。</p>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png",
      "date_published": "2023-10-15T12:01:30.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 21 新特性概览(重要)",
      "url": "https://javaguide.cn/java/new-features/java21.html",
      "id": "https://javaguide.cn/java/new-features/java21.html",
      "summary": "JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。 JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。 JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍： JEP 430：String Templates（字符串模板）（预览） JEP 431：Sequenced Collections（序列化集合） JEP 439：Generational ZGC（分代 ZGC） JEP 440：Record Patterns（记录模式） JEP 441：Pattern Matching for switch（switch 的模式匹配） JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）（第三次预览） JEP 443：Unnamed Patterns and Variables（未命名模式和变量（预览） JEP 444：Virtual Threads（虚拟线程） JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）（预览）",
      "content_html": "<p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。</p>\n<p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。</p>\n<p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：</p>\n<ul>\n<li>\n<p><a href=\"https://openjdk.org/jeps/430\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 430：String Templates（字符串模板）</a>（预览）</p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/431\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 431：Sequenced Collections（序列化集合）</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/439\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 439：Generational ZGC（分代 ZGC）</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/440\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 440：Record Patterns（记录模式）</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/442\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 441：Pattern Matching for switch（switch 的模式匹配）</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/442\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第三次预览）</p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/443\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 443：Unnamed Patterns and Variables（未命名模式和变量</a>（预览）</p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/444\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 444：Virtual Threads（虚拟线程）</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/445\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）</a>（预览）</p>\n</li>\n</ul>\n<h2> JEP 430：字符串模板（预览）</h2>\n<p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。</p>\n<p>String Templates 提供了一种更简洁、更直观的方式来动态构建字符串。通过使用占位符<code>${}</code>，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。在运行时，Java 编译器会将这些占位符替换为实际的变量值。并且，表达式支持局部变量、静态/非静态字段甚至方法、计算结果等特性。</p>\n<p>实际上，String Templates（字符串模板）再大多数编程语言中都存在:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Java 在没有 String Templates 之前，我们通常使用字符串拼接或格式化方法来构建字符串：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些方法或多或少都存在一些缺点，比如难以阅读、冗长、复杂。</p>\n<p>Java 使用 String Templates 进行字符串拼接，可以直接在字符串中嵌入表达式，而无需进行额外的处理：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在上面的模板表达式中：</p>\n<ul>\n<li>STR 是模板处理器。</li>\n<li><code>\\{name}</code>为表达式，运行时，这些表达式将被相应的变量值替换。</li>\n</ul>\n<p>Java 目前支持三种模板处理器：</p>\n<ul>\n<li>STR：自动执行字符串插值，即将模板中的每个嵌入式表达式替换为其值（转换为字符串）。</li>\n<li>FMT：和 STR 类似，但是它还可以接受格式说明符，这些格式说明符出现在嵌入式表达式的左边，用来控制输出的样式</li>\n<li>RAW：不会像 STR 和 FMT 模板处理器那样自动处理字符串模板，而是返回一个 <code>StringTemplate</code> 对象，这个对象包含了模板中的文本和表达式的信息</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了 JDK 自带的三种模板处理器外，你还可以实现 <code>StringTemplate.Processor</code> 接口来创建自己的模板处理器。</p>\n<p>我们可以使用局部变量、静态/非静态字段甚至方法作为嵌入表达式：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还可以在表达式中执行计算并打印结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了提高可读性，我们可以将嵌入的表达式分成多行:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP431：序列化集合</h2>\n<p>JDK 21 引入了一种新的集合类型：<strong>Sequenced Collections（序列化集合，也叫有序集合）</strong>，这是一种具有确定出现顺序（encounter order）的集合（无论我们遍历这样的集合多少次，元素的出现顺序始终是固定的）。序列化集合提供了处理集合的第一个和最后一个元素以及反向视图（与原始集合相反的顺序）的简单方法。</p>\n<p>Sequenced Collections 包括以下三个接口：</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>SequencedCollection</code></a></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>SequencedSet</code></a></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>SequencedMap</code></a></li>\n</ul>\n<p><code>SequencedCollection</code> 接口继承了 <code>Collection</code>接口， 提供了在集合两端访问、添加或删除元素以及获取集合的反向视图的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>List</code> 和 <code>Deque</code> 接口实现了<code>SequencedCollection</code> 接口。</p>\n<p>这里以 <code>ArrayList</code> 为例，演示一下实际使用效果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>SequencedSet</code>接口直接继承了 <code>SequencedCollection</code> 接口并重写了 <code>reversed()</code> 方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>SortedSet</code> 和 <code>LinkedHashSet</code> 实现了<code>SequencedSet</code>接口。</p>\n<p>这里以 <code>LinkedHashSet</code> 为例，演示一下实际使用效果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>SequencedMap</code> 接口继承了 <code>Map</code>接口， 提供了在集合两端访问、添加或删除键值对、获取包含 key 的 <code>SequencedSet</code>、包含 value 的 <code>SequencedCollection</code>、包含 entry（键值对） 的 <code>SequencedSet</code>以及获取集合的反向视图的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>SortedMap</code> 和<code>LinkedHashMap</code> 实现了<code>SequencedMap</code> 接口。</p>\n<p>这里以 <code>LinkedHashMap</code> 为例，演示一下实际使用效果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 439：分代 ZGC</h2>\n<p>JDK21 中对 ZGC 进行了功能扩展，增加了分代 GC 功能。不过，默认是关闭的，需要通过配置打开：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在未来的版本中，官方会把 ZGenerational 设为默认值，即默认打开 ZGC 的分代 GC。在更晚的版本中，非分代 ZGC 就被移除。</p>\n<blockquote>\n<p>In a future release we intend to make Generational ZGC the default, at which point -XX:-ZGenerational will select non-generational ZGC. In an even later release we intend to remove non-generational ZGC, at which point the ZGenerational option will become obsolete.</p>\n<p>在将来的版本中，我们打算将 Generational ZGC 作为默认选项，此时-XX:-ZGenerational 将选择非分代 ZGC。在更晚的版本中，我们打算移除非分代 ZGC，此时 ZGenerational 选项将变得过时。</p>\n</blockquote>\n<p>分代 ZGC 可以显著减少垃圾回收过程中的停顿时间，并提高应用程序的响应性能。这对于大型 Java 应用程序和高并发场景下的性能优化非常有价值。</p>\n<h2> JEP 440：记录模式</h2>\n<p>记录模式在 Java 19 进行了第一次预览， 由 <a href=\"https://openjdk.org/jeps/405\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href=\"https://openjdk.org/jeps/432\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 432</a> 提出。最终，记录模式在 JDK21 顺利转正。</p>\n<p><a href=\"/java/new-features/java20.html\" target=\"blank\">Java 20 新特性概览</a>已经详细介绍过记录模式，这里就不重复了。</p>\n<h2> JEP 441：switch 的模式匹配</h2>\n<p>增强 Java 中的 switch 表达式和语句，允许在 case 标签中使用模式。当模式匹配时，执行 case 标签对应的代码。</p>\n<p>在下面的代码中，switch 表达式使用了类型模式来进行匹配。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 442: 外部函数和内存 API（第三次预览）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出。JDK 20 中是第二次预览，由 <a href=\"https://openjdk.org/jeps/434\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 434</a> 提出。JDK 21 中是第三次预览，由 <a href=\"https://openjdk.org/jeps/442\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 442</a> 提出。</p>\n<p>在 <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 443：未命名模式和变量（预览）</h2>\n<p>未命名模式和变量使得我们可以使用下划线 <code>_</code> 表示未命名的变量以及模式匹配时不使用的组件，旨在提高代码的可读性和可维护性。</p>\n<p>未命名变量的典型场景是 <code>try-with-resources</code> 语句、 <code>catch</code> 子句中的异常变量和<code>for</code>循环。当变量不需要使用的时候就可以使用下划线 <code>_</code>代替，这样清晰标识未被使用的变量。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>未命名模式是一个无条件的模式，并不绑定任何值。未命名模式变量出现在类型模式中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 444：虚拟线程</h2>\n<p>虚拟线程是一项重量级的更新，一定一定要重视！</p>\n<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href=\"https://openjdk.org/jeps/425\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 425</a>提出。JDK 20 中是第二次预览。最终，虚拟线程在 JDK21 顺利转正。</p>\n<p><a href=\"/java/new-features/java20.html\" target=\"blank\">Java 20 新特性概览</a>已经详细介绍过虚拟线程，这里就不重复了。</p>\n<h2> JEP 445：未命名类和实例 main 方法 （预览）</h2>\n<p>这个特性主要简化了 <code>main</code> 方法的的声明。对于 Java 初学者来说，这个 <code>main</code> 方法的声明引入了太多的 Java 语法概念，不利于初学者快速上手。</p>\n<p>没有使用该特性之前定义一个 <code>main</code> 方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用该新特性之后定义一个 <code>main</code> 方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>进一步精简(未命名的类允许我们不定义类名)：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>Java 21 String Templates：<a href=\"https://howtodoinjava.com/java/java-string-templates/\" target=\"_blank\" rel=\"noopener noreferrer\">https://howtodoinjava.com/java/java-string-templates/</a></li>\n<li>Java 21 Sequenced Collections：<a href=\"https://howtodoinjava.com/java/sequenced-collections/\" target=\"_blank\" rel=\"noopener noreferrer\">https://howtodoinjava.com/java/sequenced-collections/</a></li>\n</ul>\n",
      "date_published": "2023-10-08T07:27:41.000Z",
      "date_modified": "2023-11-29T15:27:15.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Maven最佳实践",
      "url": "https://javaguide.cn/tools/maven/maven-best-practices.html",
      "id": "https://javaguide.cn/tools/maven/maven-best-practices.html",
      "summary": "本文由 JavaGuide 翻译并完善，原文地址：https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b 。",
      "content_html": "<blockquote>\n<p>本文由 JavaGuide 翻译并完善，原文地址：<a href=\"https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b\" target=\"_blank\" rel=\"noopener noreferrer\">https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b</a> 。</p>\n</blockquote>\n<p>Maven 是一种广泛使用的 Java 项目构建自动化工具。它简化了构建过程并帮助管理依赖关系，使开发人员的工作更轻松。Maven 详细介绍可以参考我写的这篇 <a href=\"/tools/maven/maven-core-concepts.html\" target=\"blank\">Maven 核心概念总结</a> 。</p>\n<p>这篇文章不会涉及到 Maven 概念的介绍，主要讨论一些最佳实践、建议和技巧，以优化我们在项目中对 Maven 的使用并改善我们的开发体验。</p>\n<h2> Maven 标准目录结构</h2>\n<p>Maven 遵循标准目录结构来保持项目之间的一致性。遵循这种结构可以让其他开发人员更轻松地理解我们的项目。</p>\n<p>Maven 项目的标准目录结构如下：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>src/main/java</code>：源代码目录</li>\n<li><code>src/main/resources</code>：资源文件目录</li>\n<li><code>src/test/java</code>：测试代码目录</li>\n<li><code>src/test/resources</code>：测试资源文件目录</li>\n</ul>\n<p>这只是一个最简单的 Maven 项目目录示例。实际项目中，我们还会根据项目规范去做进一步的细分。</p>\n<h2> 指定 Maven 编译器插件</h2>\n<p>默认情况下，Maven 使用 Java5 编译我们的项目。要使用不同的 JDK 版本，请在 <code>pom.xml</code> 文件中配置 Maven 编译器插件。</p>\n<p>例如，如果你想要使用 Java8 来编译你的项目，你可以在<code>&lt;build&gt;</code>标签下添加以下的代码片段：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样，Maven 就会使用 Java8 的编译器来编译你的项目。如果你想要使用其他版本的 JDK，你只需要修改<code>&lt;source&gt;</code>和<code>&lt;target&gt;</code>标签的值即可。例如，如果你想要使用 Java11，你可以将它们的值改为 11。</p>\n<h2> 有效管理依赖关系</h2>\n<p>Maven 的依赖管理系统是其最强大的功能之一。在顶层 pom 文件中，通过标签 <code>dependencyManagement</code> 定义公共的依赖关系，这有助于避免冲突并确保所有模块使用相同版本的依赖项。</p>\n<p>例如，假设我们有一个父模块和两个子模块 A 和 B，我们想要在所有模块中使用 JUnit 5.7.2 作为测试框架。我们可以在父模块的<code>pom.xml</code>文件中使用<code>&lt;dependencyManagement&gt;</code>标签来定义 JUnit 的版本：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在子模块 A 和 B 的 <code>pom.xml</code> 文件中，我们只需要引用 JUnit 的 <code>groupId</code> 和 <code>artifactId</code> 即可:</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 针对不同环境使用配置文件</h2>\n<p>Maven 配置文件允许我们配置不同环境的构建设置，例如开发、测试和生产。在 <code>pom.xml</code> 文件中定义配置文件并使用命令行参数激活它们：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用命令行激活配置文件：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 保持 pom.xml 干净且井然有序</h2>\n<p>组织良好的 <code>pom.xml</code> 文件更易于维护和理解。以下是维护干净的 <code>pom.xml</code> 的一些技巧：</p>\n<ul>\n<li>将相似的依赖项和插件组合在一起。</li>\n<li>使用注释来描述特定依赖项或插件的用途。</li>\n<li>将插件和依赖项的版本号保留在 <code>&lt;properties&gt;</code> 标签内以便于管理。</li>\n</ul>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用 Maven Wrapper</h2>\n<p>Maven Wrapper 是一个用于管理和使用 Maven 的工具，它允许在没有预先安装 Maven 的情况下运行和构建 Maven 项目。</p>\n<p>Maven 官方文档是这样介绍 Maven Wrapper 的：</p>\n<blockquote>\n<p>The Maven Wrapper is an easy way to ensure a user of your Maven build has everything necessary to run your Maven build.</p>\n<p>Maven Wrapper 是一种简单的方法，可以确保 Maven 构建的用户拥有运行 Maven 构建所需的一切。</p>\n</blockquote>\n<p>Maven Wrapper 可以确保构建过程使用正确的 Maven 版本，非常方便。要使用 Maven Wrapper，请在项目目录中运行以下命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此命令会在我们的项目中生成 Maven Wrapper 文件。现在我们可以使用 <code>./mvnw</code> （或 Windows 上的 <code>./mvnw.cmd</code>）而不是 <code>mvn</code> 来执行 Maven 命令。</p>\n<h2> 通过持续集成实现构建自动化</h2>\n<p>将 Maven 项目与持续集成 (CI) 系统（例如 Jenkins 或 GitHub Actions）集成，可确保自动构建、测试和部署我们的代码。CI 有助于及早发现问题并在整个团队中提供一致的构建流程。以下是 Maven 项目的简单 GitHub Actions 工作流程示例：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 利用 Maven 插件获得附加功能</h2>\n<p>有许多 Maven 插件可用于扩展 Maven 的功能。一些流行的插件包括（前三个是 Maven 自带的插件，后三个是第三方提供的插件）：</p>\n<ul>\n<li>maven-surefire-plugin：配置并执行单元测试。</li>\n<li>maven-failsafe-plugin：配置并执行集成测试。</li>\n<li>maven-javadoc-plugin：生成 Javadoc 格式的项目文档。</li>\n<li>maven-checkstyle-plugin：强制执行编码标准和最佳实践。</li>\n<li>jacoco-maven-plugin: 单测覆盖率。</li>\n<li>sonar-maven-plugin：分析代码质量。</li>\n<li>……</li>\n</ul>\n<p>jacoco-maven-plugin 使用示例：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果这些已有的插件无法满足我们的需求，我们还可以自定义插件。</p>\n<p>探索可用的插件并在 <code>pom.xml</code> 文件中配置它们以增强我们的开发过程。</p>\n<h2> 总结</h2>\n<p>Maven 是一个强大的工具，可以简化 Java 项目的构建过程和依赖关系管理。通过遵循这些最佳实践和技巧，我们可以优化 Maven 的使用并改善我们的 Java 开发体验。请记住使用标准目录结构，有效管理依赖关系，利用不同环境的配置文件，并将项目与持续集成系统集成，以确保构建一致。</p>\n",
      "date_published": "2023-09-15T13:14:19.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "开发工具"
      ]
    },
    {
      "title": "IoC & AOP详解（快速搞懂）",
      "url": "https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html",
      "id": "https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html",
      "summary": "这篇文章会从下面从以下几个问题展开对 IoC &amp; AOP 的解释 什么是 IoC？ IoC 解决了什么问题？ IoC 和 DI 的区别？ 什么是 AOP？ AOP 解决了什么问题？ AOP 的应用场景有哪些？ AOP 为什么叫做切面编程？ AOP 实现方式有哪些？ 首先声明：IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。",
      "content_html": "<p>这篇文章会从下面从以下几个问题展开对 IoC &amp; AOP 的解释</p>\n<ul>\n<li>什么是 IoC？</li>\n<li>IoC 解决了什么问题？</li>\n<li>IoC 和 DI 的区别？</li>\n<li>什么是 AOP？</li>\n<li>AOP 解决了什么问题？</li>\n<li>AOP 的应用场景有哪些？</li>\n<li>AOP 为什么叫做切面编程？</li>\n<li>AOP 实现方式有哪些？</li>\n</ul>\n<p>首先声明：IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p>\n<h2> IoC （Inversion of control ）</h2>\n<h3> 什么是 IoC?</h3>\n<p>IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p>\n<p>例如：现有类 A 依赖于类 B</p>\n<ul>\n<li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li>\n<li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li>\n</ul>\n<p>从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）</p>\n<p><strong>为什么叫控制反转?</strong></p>\n<ul>\n<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>\n<li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png\" alt=\"IoC 图解\" tabindex=\"0\"><figcaption>IoC 图解</figcaption></figure>\n<h3> IoC 解决了什么问题?</h3>\n<p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p>\n<ol>\n<li>对象之间的耦合度或者说依赖程度降低；</li>\n<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li>\n</ol>\n<p>例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发</p>\n<p>在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在<code>UserServiceImpl</code> 中手动 new 出 <code>IUserDao</code> 的具体实现类 <code>UserDaoImpl</code>（不能直接 new 接口类）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/ioc-kfji3.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>很完美，这种方式也是可以实现的，但是我们想象一下如下场景：</p>\n<p>开发过程中突然接到一个新的需求，针对对<code>IUserDao</code> 接口开发出另一个具体实现类。因为 Server 层依赖了<code>IUserDao</code>的具体实现，所以我们需要修改<code>UserServiceImpl</code>中 new 的对象。如果只有一个类引用了<code>IUserDao</code>的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了<code>IUserDao</code>的具体实现的话，一旦需要更换<code>IUserDao</code> 的实现方式，那修改起来将会非常的头疼。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc-2.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> IoC 和 DI 有区别吗？</h3>\n<p>IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 <strong>将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容易。</strong> 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。</p>\n<p>IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p>\n<p>老马（Martin Fowler）在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址：<a href=\"https://martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://martinfowler.com/articles/injection.html</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/martin-fowler-injection.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>老马的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。</p>\n<h2> AOP（Aspect oriented programming）</h2>\n<p>这里不会涉及太多专业的术语，核心目的是将 AOP 的思想说清楚。</p>\n<h3> 什么是 AOP？</h3>\n<p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p>\n<p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p>\n<h3> AOP 为什么叫面向切面编程？</h3>\n<p>AOP 之所以叫面向切面编程，是因为它的核心思想就是将横切关注点从核心业务逻辑中分离出来，形成一个个的<strong>切面（Aspect）</strong>。</p>\n<p>这里顺带总结一下 AOP 关键术语（不理解也没关系，可以继续往下看）：</p>\n<ul>\n<li><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</li>\n<li><strong>切面（Aspect）</strong>：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li>\n<li><strong>连接点（JoinPoint）</strong>：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li>\n<li><strong>通知（Advice）</strong>：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li>\n<li><strong>切点（Pointcut）</strong>：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。</li>\n<li><strong>织入（Weaving）</strong>：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）。</li>\n</ul>\n<h3> AOP 解决了什么问题？</h3>\n<p>OOP 不能很好地处理一些分散在多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等），这些行为通常被称为 <strong>横切关注点（cross-cutting concerns）</strong> 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护。</p>\n<p>AOP 可以将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从 <strong>核心业务逻辑（core concerns，核心关注点）</strong> 中分离出来，实现关注点的分离。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/crosscut-logic-and-businesslogic-separation      .png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>以日志记录为例进行介绍，假如我们需要对某些方法进行统一格式的日志记录，没有使用 AOP 技术之前，我们需要挨个写日志记录的逻辑代码，全是重复的的逻辑。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 AOP 技术之后，我们可以日志记录的逻辑封装成一个切面，然后通过切入点和通知来指定在哪些方法需要执行日志记录的操作。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样的话，我们一行注解即可实现日志记录：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> AOP 的应用场景有哪些？</h3>\n<ul>\n<li>日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。</li>\n<li>性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。</li>\n<li>事务管理：<code>@Transactional</code> 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。<code>@Transactional</code>注解就是基于 AOP 实现的。</li>\n<li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用<code>@PreAuthorize</code> 注解一行代码即可自定义权限校验。</li>\n<li>接口限流：利用 AOP 在目标方法执行前通过具体的限流算法和实现对请求进行限流处理。</li>\n<li>缓存管理：利用 AOP 在目标方法执行前后进行缓存的读取和更新。</li>\n<li>……</li>\n</ul>\n<h3> AOP 实现方式有哪些？</h3>\n<p>AOP 的常见实现方式有动态代理、字节码操作等方式。</p>\n<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg\" alt=\"SpringAOPProcess\" tabindex=\"0\"><figcaption>SpringAOPProcess</figcaption></figure>\n<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>\n<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>\n<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>\n<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>\n",
      "image": "https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png",
      "date_published": "2023-09-10T14:59:47.000Z",
      "date_modified": "2023-10-10T06:43:53.000Z",
      "authors": [],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "Spring Boot核心源码解读（付费）",
      "url": "https://javaguide.cn/system-design/framework/spring/springboot-source-code.html",
      "id": "https://javaguide.cn/system-design/framework/spring/springboot-source-code.html",
      "summary": "Spring Boot 核心源码解读 为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 必读源码系列》中。",
      "content_html": "<p><strong>Spring Boot 核心源码解读</strong> 为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/source-code-reading.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 必读源码系列》</a>中。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/springboot-source-code.png\" alt=\"Spring Boot核心源码解读\" tabindex=\"0\"><figcaption>Spring Boot核心源码解读</figcaption></figure>\n<p><a href=\"/zhuanlan/source-code-reading.html\" target=\"blank\">《Java 必读源码系列》</a>（点击链接即可查看详细介绍）的部分内容展示如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220621091832348.png\" alt=\"《Java 必读源码系列》\" tabindex=\"0\"><figcaption>《Java 必读源码系列》</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/xingqiu/springboot-source-code.png",
      "date_published": "2023-07-27T01:08:19.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "SQL常见面试题总结（2）",
      "url": "https://javaguide.cn/database/sql/sql-questions-02.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-02.html",
      "summary": "题目来源于：牛客题霸 - SQL 进阶挑战 增删改操作 SQL 插入记录的方式汇总： 普通插入（全字段） ：INSERT INTO table_name VALUES (value1, value2, ...) 普通插入（限定字段） ：INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...) 多条一次性插入 ：INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ... 从另一个表导入 ：INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value] 带更新的插入 ：REPLACE INTO table_name VALUES (value1, value2, ...)（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 进阶挑战</a></p>\n</blockquote>\n<h2> 增删改操作</h2>\n<p>SQL 插入记录的方式汇总：</p>\n<ul>\n<li><strong>普通插入（全字段）</strong> ：<code>INSERT INTO table_name VALUES (value1, value2, ...)</code></li>\n<li><strong>普通插入（限定字段）</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)</code></li>\n<li><strong>多条一次性插入</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</code></li>\n<li><strong>从另一个表导入</strong> ：<code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]</code></li>\n<li><strong>带更新的插入</strong> ：<code>REPLACE INTO table_name VALUES (value1, value2, ...)</code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）</li>\n</ul>\n<h3> 插入记录（一）</h3>\n<p><strong>描述</strong>：牛客后台会记录每个用户的试卷作答记录到 <code>exam_record</code> 表，现在有两个用户的作答记录详情如下：</p>\n<ul>\n<li>用户 1001 在 2021 年 9 月 1 日晚上 10 点 11 分 12 秒开始作答试卷 9001，并在 50 分钟后提交，得了 90 分；</li>\n<li>用户 1002 在 2021 年 9 月 4 日上午 7 点 1 分 2 秒开始作答试卷 9002，并在 10 分钟后退出了平台。</li>\n</ul>\n<p>试卷作答记录表<code>exam_record</code>中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>得分</td>\n</tr>\n</tbody>\n</table>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入记录（二）</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，结构如下表，其中包含多年来的用户作答试卷记录，由于数据越来越多，维护难度越来越大，需要对数据表内容做精简，历史数据做备份。</p>\n<p>表<code>exam_record</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>得分</td>\n</tr>\n</tbody>\n</table>\n<p>我们已经创建了一张新表<code>exam_record_before_2021</code>用来备份 2021 年之前的试题作答记录，结构和<code>exam_record</code>表一致，请将 2021 年之前的已完成了的试题作答纪录导入到该表。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入记录（三）</h3>\n<p><strong>描述</strong>：现在有一套 ID 为 9003 的高难度 SQL 试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表<code>examination_info</code>，不管该 ID 试卷是否存在，都要插入成功，请尝试插入它。</p>\n<p>试题信息表<code>examination_info</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>UNI</td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>tag</td>\n<td>varchar(32)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>类别标签</td>\n</tr>\n<tr>\n<td>difficulty</td>\n<td>varchar(8)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>难度</td>\n</tr>\n<tr>\n<td>duration</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>时长(分钟数)</td>\n</tr>\n<tr>\n<td>release_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>发布时间</td>\n</tr>\n</tbody>\n</table>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 更新记录（一）</h3>\n<p><strong>描述</strong>：现在有一张试卷信息表 <code>examination_info</code>, 表结构如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>UNI</td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>tag</td>\n<td>char(32)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>类别标签</td>\n</tr>\n<tr>\n<td>difficulty</td>\n<td>char(8)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>难度</td>\n</tr>\n<tr>\n<td>duration</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>时长</td>\n</tr>\n<tr>\n<td>release_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>发布时间</td>\n</tr>\n</tbody>\n</table>\n<p>请把<strong>examination_info</strong>表中<code>tag</code>为<code>PYTHON</code>的<code>tag</code>字段全部修改为<code>Python</code>。</p>\n<p><strong>思路</strong>：这题有两种解题思路，最容易想到的是直接<code>update + where</code>来指定条件更新，第二种就是根据要修改的字段进行查找替换</p>\n<p><strong>答案一</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>答案二</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 更新记录（二）</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：作答记录表 <code>exam_record</code>： <strong><code>submit_time</code></strong> 为 完成时间 （注意这句话）</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>得分</td>\n</tr>\n</tbody>\n</table>\n<p><strong>题目要求</strong>：请把 <code>exam_record</code> 表中 2021 年 9 月 1 日==之前==开始作答的==未完成==记录全部改为被动完成，即：将完成时间改为'2099-01-01 00:00:00'，分数改为 0。</p>\n<p><strong>思路</strong>：注意题干中的关键字(已经高亮) <code>\" xxx 时间 \"</code>之前这个条件， 那么这里马上就要想到要进行时间的比较 可以直接 <code>xxx_time &lt; \"2021-09-01 00:00:00\",</code> 也可以采用<code>date()</code>函数来进行比较；第二个条件就是 <code>\"未完成\"</code>， 即完成时间为 NULL，也就是题目中的提交时间 ----- <code>submit_time 为 NULL</code>。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除记录（一）</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>\n<p>作答记录表<code>exam_record：</code> <strong><code>start_time</code></strong> 是试卷开始时间<code>submit_time</code> 是交卷，即结束时间。</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>得分</td>\n</tr>\n</tbody>\n</table>\n<p><strong>要求</strong>：请删除<code>exam_record</code>表中作答时间小于 5 分钟整且分数不及格（及格线为 60 分）的记录；</p>\n<p><strong>思路</strong>：这一题虽然是练习删除，仔细看确是考察对时间函数的用法，这里提及的分钟数比较，常用的函数有 <strong><code>TIMEDIFF</code><strong>和</strong><code>TIMESTAMPDIFF</code></strong> ，两者用法稍有区别，后者更为灵活，这都是看个人习惯。</p>\n<p>1.　 <code>TIMEDIFF</code>：两个时间之间的差值</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>两者参数都是必须的，都是一个时间或者日期时间表达式。如果指定的参数不合法或者是 NULL，那么函数将返回 NULL。</p>\n<p>对于这题而言，可以用在 minute 函数里面，因为 TIMEDIFF 计算出来的是时间的差值，在外面套一个 MINUTE 函数，计算出来的就是分钟数。</p>\n<ol start=\"2\">\n<li><code>TIMESTAMPDIFF</code>：用于计算两个日期的时间差</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这题需要进行分钟的比较，那么就是 TIMESTAMPDIFF(MINUTE, 开始时间， 结束时间) &lt; 5</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除记录（二）</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>\n<p>作答记录表<code>exam_record</code>：<code>start_time</code> 是试卷开始时间，<code>submit_time</code> 是交卷时间，即结束时间，如果未完成的话，则为空。</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th style=\"text-align:center\">Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td style=\"text-align:center\">YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td style=\"text-align:center\">YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>分数</td>\n</tr>\n</tbody>\n</table>\n<p><strong>要求</strong>：请删除<code>exam_record</code>表中未完成作答==或==作答时间小于 5 分钟整的记录中，开始作答时间最早的 3 条记录。</p>\n<p><strong>思路</strong>：这题比较简单，但是要注意题干中给出的信息，结束时间，如果未完成的话，则为空，这个其实就是一个条件</p>\n<p>还有一个条件就是小于 5 分钟，跟上题类似，但是这里是<strong>或</strong>，即两个条件满足一个就行；另外就是稍微考察到了排序和 limit 的用法。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除记录（三）</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th style=\"text-align:center\">Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td style=\"text-align:center\">NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td style=\"text-align:center\">YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td style=\"text-align:center\">YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>分数</td>\n</tr>\n</tbody>\n</table>\n<p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，==并重置自增主键==</p>\n<p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p>\n<ul>\n<li><code>DROP</code>: 清空表，删除表结构，不可逆</li>\n<li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li>\n<li><code>DELETE</code>：删除数据，可逆</li>\n</ul>\n<p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p>\n<p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p>\n<p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 表与索引操作</h2>\n<h3> 创建一张新表</h3>\n<p><strong>描述</strong>：现有一张用户信息表，其中包含多年来在平台注册过的用户信息，随着牛客平台的不断壮大，用户量飞速增长，为了高效地为高活跃用户提供服务，现需要将部分用户拆分出一张新表。</p>\n<p>原来的用户信息表：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Default</th>\n<th>Extra</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>(NULL)</td>\n<td>auto_increment</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>UNI</td>\n<td>(NULL)</td>\n<td></td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>nick_name</td>\n<td>varchar(64)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>昵称</td>\n</tr>\n<tr>\n<td>achievement</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>0</td>\n<td></td>\n<td>成就值</td>\n</tr>\n<tr>\n<td>level</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>用户等级</td>\n</tr>\n<tr>\n<td>job</td>\n<td>varchar(32)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>职业方向</td>\n</tr>\n<tr>\n<td>register_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td>CURRENT_TIMESTAMP</td>\n<td></td>\n<td>注册时间</td>\n</tr>\n</tbody>\n</table>\n<p>作为数据分析师，请<strong>创建一张优质用户信息表 user_info_vip</strong>，表结构和用户信息表一致。</p>\n<p>你应该返回的输出如下表格所示，请写出建表语句将表格中所有限制和说明记录到表里。</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Default</th>\n<th>Extra</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>(NULL)</td>\n<td>auto_increment</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>UNI</td>\n<td>(NULL)</td>\n<td></td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>nick_name</td>\n<td>varchar(64)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>昵称</td>\n</tr>\n<tr>\n<td>achievement</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>0</td>\n<td></td>\n<td>成就值</td>\n</tr>\n<tr>\n<td>level</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>用户等级</td>\n</tr>\n<tr>\n<td>job</td>\n<td>varchar(32)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>职业方向</td>\n</tr>\n<tr>\n<td>register_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td>CURRENT_TIMESTAMP</td>\n<td></td>\n<td>注册时间</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思路</strong>：如果这题给出了旧表的名称，可直接<code>create table 新表 as select * from 旧表;</code> 但是这题并没有给出旧表名称，所以需要自己创建，注意默认值和键的创建即可，比较简单。（注意：如果是在牛客网上面执行，请注意 comment 中要和题目中的 comment 保持一致，包括大小写，否则不通过，还有字符也要设置）</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 修改表</h3>\n<p><strong>描述</strong>： 现有一张用户信息表<code>user_info</code>，其中包含多年来在平台注册过的用户信息。</p>\n<p><strong>用户信息表 <code>user_info</code>：</strong></p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Default</th>\n<th>Extra</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>(NULL)</td>\n<td>auto_increment</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>UNI</td>\n<td>(NULL)</td>\n<td></td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>nick_name</td>\n<td>varchar(64)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>昵称</td>\n</tr>\n<tr>\n<td>achievement</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>0</td>\n<td></td>\n<td>成就值</td>\n</tr>\n<tr>\n<td>level</td>\n<td>int(11)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>用户等级</td>\n</tr>\n<tr>\n<td>job</td>\n<td>varchar(32)</td>\n<td>YES</td>\n<td></td>\n<td>(NULL)</td>\n<td></td>\n<td>职业方向</td>\n</tr>\n<tr>\n<td>register_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td>CURRENT_TIMESTAMP</td>\n<td></td>\n<td>注册时间</td>\n</tr>\n</tbody>\n</table>\n<p>**要求：**请在用户信息表，字段 <code>level</code> 的后面增加一列最多可保存 15 个汉字的字段 <code>school</code>；并将表中 <code>job</code> 列名改为 <code>profession</code>，同时 <code>varchar</code> 字段长度变为 10；<code>achievement</code> 的默认值设置为 0。</p>\n<p><strong>思路</strong>：首先做这题之前，需要了解 ALTER 语句的基本用法：</p>\n<ul>\n<li>添加一列：<code>ALTER TABLE 表名 ADD COLUMN 列名 类型 【first | after 字段名】;</code>（first ： 在某列之前添加，after 反之）</li>\n<li>修改列的类型或约束：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</code></li>\n<li>修改列名：<code>ALTER TABLE 表名 change COLUMN 旧列名 新列名 类型;</code></li>\n<li>删除列：<code>ALTER TABLE 表名 drop COLUMN 列名;</code></li>\n<li>修改表名：<code>ALTER TABLE 表名 rename 【to】 新表名;</code></li>\n<li>将某一列放到第一列：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 类型 first;</code></li>\n</ul>\n<p><code>COLUMN</code> 关键字其实可以省略不写，这里基于规范还是罗列出来了。</p>\n<p>在修改时，如果有多个修改项，可以写到一起，但要注意格式</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除表</h3>\n<p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录。一般每年都会为 <code>exam_record</code> 表建立一张备份表 <code>exam_record_{YEAR}，{YEAR}</code> 为对应年份。</p>\n<p>现在随着数据越来越多，存储告急，请你把很久前的（2011 到 2014 年）备份表都删掉（如果存在的话）。</p>\n<p><strong>思路</strong>：这题很简单，直接删就行，如果嫌麻烦，可以将要删除的表用逗号隔开，写到一行；这里肯定会有小伙伴问：如果要删除很多张表呢？放心，如果要删除很多张表，可以写脚本来进行删除。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建索引</h3>\n<p><strong>描述</strong>：现有一张试卷信息表 <code>examination_info</code>，其中包含各种类型试卷的信息。为了对表更方便快捷地查询，需要在 <code>examination_info</code> 表创建以下索引，</p>\n<p>规则如下：在 <code>duration</code> 列创建普通索引 <code>idx_duration</code>、在 <code>exam_id</code> 列创建唯一性索引 <code>uniq_idx_exam_id</code>、在 <code>tag</code> 列创建全文索引 <code>full_idx_tag</code>。</p>\n<p>根据题意，将返回如下结果：</p>\n<table>\n<thead>\n<tr>\n<th>examination_info</th>\n<th>0</th>\n<th>PRIMARY</th>\n<th>1</th>\n<th>id</th>\n<th>A</th>\n<th>0</th>\n<th></th>\n<th></th>\n<th></th>\n<th>BTREE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>examination_info</td>\n<td>0</td>\n<td>uniq_idx_exam_id</td>\n<td>1</td>\n<td>exam_id</td>\n<td>A</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td>YES</td>\n<td>BTREE</td>\n</tr>\n<tr>\n<td>examination_info</td>\n<td>1</td>\n<td>idx_duration</td>\n<td>1</td>\n<td>duration</td>\n<td>A</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n<td>BTREE</td>\n</tr>\n<tr>\n<td>examination_info</td>\n<td>1</td>\n<td>full_idx_tag</td>\n<td>1</td>\n<td>tag</td>\n<td></td>\n<td>0</td>\n<td></td>\n<td></td>\n<td>YES</td>\n<td>FULLTEXT</td>\n</tr>\n</tbody>\n</table>\n<p>备注：后台会通过 <code>SHOW INDEX FROM examination_info</code> 语句来对比输出结果</p>\n<p><strong>思路</strong>：做这题首先需要了解常见的索引类型：</p>\n<ul>\n<li>B-Tree 索引：B-Tree（或称为平衡树）索引是最常见和默认的索引类型。它适用于各种查询条件，可以快速定位到符合条件的数据。B-Tree 索引适用于普通的查找操作，支持等值查询、范围查询和排序。</li>\n<li>唯一索引：唯一索引与普通的 B-Tree 索引类似，不同之处在于它要求被索引的列的值是唯一的。这意味着在插入或更新数据时，MySQL 会验证索引列的唯一性。</li>\n<li>主键索引：主键索引是一种特殊的唯一索引，它用于唯一标识表中的每一行数据。每个表只能有一个主键索引，它可以帮助提高数据的访问速度和数据完整性。</li>\n<li>全文索引：全文索引用于在文本数据中进行全文搜索。它支持在文本字段中进行关键字搜索，而不仅仅是简单的等值或范围查找。全文索引适用于需要进行全文搜索的应用场景。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有了以上的基础知识之后，该题答案也就浮出水面了。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除索引</h3>\n<p><strong>描述</strong>：请删除<code>examination_info</code>表上的唯一索引 uniq_idx_exam_id 和全文索引 full_idx_tag。</p>\n<p><strong>思路</strong>：该题考察删除索引的基本语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里需要注意的是：在 MySQL 中，一次删除多个索引的操作是不支持的。每次删除索引时，只能指定一个索引名称进行删除。</p>\n<p>而且 <strong>DROP</strong> 命令需要慎用！！！</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-07-13T14:23:50.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL常见面试题总结（3）",
      "url": "https://javaguide.cn/database/sql/sql-questions-03.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-03.html",
      "summary": "题目来源于：牛客题霸 - SQL 进阶挑战 较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。 聚合函数 SQL 类别高难度试卷得分的截断平均值（较难） 描述： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 进阶挑战</a></p>\n</blockquote>\n<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>\n<h2> 聚合函数</h2>\n<h3> SQL 类别高难度试卷得分的截断平均值（较难）</h3>\n<p><strong>描述</strong>： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。</p>\n<p>请你帮她从<code>exam_record</code>数据表中计算所有用户完成 SQL 类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p>\n<p>示例数据：<code>examination_info</code>（<code>exam_id</code> 试卷 ID, tag 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-08-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>示例数据：<code>exam_record</code>（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>2021-05-02 10:30:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:31:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-07 12:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-06 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>根据输入你的查询结果如下：</p>\n<table>\n<thead>\n<tr>\n<th>tag</th>\n<th>difficulty</th>\n<th>clip_avg_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQL</td>\n<td>hard</td>\n<td>81.7</td>\n</tr>\n</tbody>\n</table>\n<p>从<code>examination_info</code>表可知，试卷 9001 为高难度 SQL 试卷，该试卷被作答的得分有[80,81,84,90,50]，去除最高分和最低分后为[80,81,84]，平均分为 81.6666667，保留一位小数后为 81.7</p>\n<p><strong>输入描述：</strong></p>\n<p>输入数据中至少有 3 个有效分数</p>\n<p><strong>思路一：</strong> 要找出高难度 sql 试卷，肯定需要联 examination_info 这张表，然后找出高难度的课程，由 examination_info 得知，高难度 sql 的 exam_id 为 9001，那么等下就以 exam_id = 9001 作为条件去查询；</p>\n<p>先找出 9001 号考试 <code>select * from exam_record where exam_id = 9001</code></p>\n<p>然后，找出最高分 <code>select max(score) 最高分 from exam_record where exam_id = 9001</code></p>\n<p>接着，找出最低分 <code>select min(score) 最低分 from exam_record where exam_id = 9001</code></p>\n<p>在查询出来的分数结果集当中，去掉最高分和最低分，最直观能想到的就是 NOT IN 或者 用 NOT EXISTS 也行，这里以 NOT IN 来做</p>\n<p>首先将主体写出来<code>select tag, difficulty, round(avg(score), 1) clip_avg_score from examination_info info INNER JOIN exam_record record</code></p>\n<p><strong>小 tips</strong> : MYSQL 的 <code>ROUND()</code> 函数 ,<code>ROUND(X)</code>返回参数 X 最近似的整数 <code>ROUND(X,D)</code>返回 X ,其值保留到小数点后 D 位,第 D 位的保留方式为四舍五入。</p>\n<p>再将上面的 \"碎片\" 语句拼凑起来即可， 注意在 NOT IN 中两个子查询用 UNION ALL 来关联，用 union 把 max 和 min 的结果集中在一行当中，这样形成一列多行的效果。</p>\n<p><strong>答案一：</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是最直观，也是最容易想到的解法，但是还有待改进，这算是投机取巧过关，其实严格按照题目要求应该这么写：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然而你会发现，重复的语句非常多，所以可以利用<code>WITH</code>来抽取公共部分</p>\n<p><strong><code>WITH</code> 子句介绍</strong>：</p>\n<p><code>WITH</code> 子句，也称为公共表表达式（Common Table Expression，CTE），是在 SQL 查询中定义临时表的方式。它可以让我们在查询中创建一个临时命名的结果集，并且可以在同一查询中引用该结果集。</p>\n<p>基本用法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WITH</code> 子句由以下几个部分组成：</p>\n<ul>\n<li><code>cte_name</code>: 给临时表起一个名称，可以在主查询中引用。</li>\n<li><code>(column1, column2, ..., columnN)</code>: 可选，指定临时表的列名。</li>\n<li><code>AS</code>: 必需，表示开始定义临时表。</li>\n<li><code>CTE 查询体</code>: 实际的查询语句，用于定义临时表中的数据。</li>\n</ul>\n<p><code>WITH</code> 子句的主要用途之一是增强查询的可读性和可维护性，尤其在涉及多个嵌套子查询或需要重复使用相同的查询逻辑时。通过将这些逻辑放在一个命名的临时表中，我们可以更清晰地组织查询，并消除重复代码。</p>\n<p>此外，<code>WITH</code> 子句还可以在复杂的查询中实现递归查询。递归查询允许我们在单个查询中执行对同一表的多次迭代，逐步构建结果集。这在处理层次结构数据、组织结构和树状结构等场景中非常有用。</p>\n<p><strong>小细节</strong>：MySQL 5.7 版本以及之前的版本不支持在 <code>WITH</code> 子句中直接使用别名。</p>\n<p>下面是改进后的答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>思路二：</strong></p>\n<ul>\n<li>筛选 SQL 高难度试卷：<code>where tag=\"SQL\" and difficulty=\"hard\"</code></li>\n<li>计算截断平均值：<code>(和-最大值-最小值) / (总个数-2)</code>:\n<ul>\n<li><code>(sum(score) - max(score) - min(score)) / (count(score) - 2)</code></li>\n<li>有一个缺点就是，如果最大值和最小值有多个，这个方法就很难筛选出来, 但是题目中说了-----&gt;<strong><code>去掉一个最大值和一个最小值后的平均值</code></strong>, 所以这里可以用这个公式。</li>\n</ul>\n</li>\n</ul>\n<p><strong>答案二：</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 统计作答次数</h3>\n<p>有一个试卷作答记录表 <code>exam_record</code>，请从中统计出总作答次数 <code>total_pv</code>、试卷已完成作答数 <code>complete_pv</code>、已完成的试卷数 <code>complete_exam_cnt</code>。</p>\n<p>示例数据 <code>exam_record</code> 表（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>2021-05-02 10:30:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:31:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-07 12:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-06 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>示例输出：</p>\n<table>\n<thead>\n<tr>\n<th>total_pv</th>\n<th>complete_pv</th>\n<th>complete_exam_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>解释：表示截止当前，有 11 次试卷作答记录，已完成的作答次数为 7 次（中途退出的为未完成状态，其交卷时间和份数为 NULL），已完成的试卷有 9001 和 9002 两份。</p>\n<p><strong>思路</strong>： 这题一看到统计次数，肯定第一时间就要想到用<code>COUNT</code>这个函数来解决，问题是要统计不同的记录，该怎么来写？使用子查询就能解决这个题目(这题用 case when 也能写出来，解法类似，逻辑不同而已)；首先在做这个题之前，让我们先来了解一下<code>COUNT</code>的基本用法；</p>\n<p><code>COUNT()</code> 函数的基本语法如下所示：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中，<code>expression</code> 可以是列名、表达式、常量或通配符。下面是一些常见的用法示例：</p>\n<ol>\n<li>计算表中所有行的数量：</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>计算特定列非空（不为 NULL）值的数量：</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li>计算满足条件的行数：</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"4\">\n<li>结合 <code>GROUP BY</code> 使用，计算分组后每个组的行数：</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"5\">\n<li>计算不同列组合的唯一组合数：</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在使用 <code>COUNT()</code> 函数时，如果不指定任何参数或者使用 <code>COUNT(*)</code>，将会计算所有行的数量。而如果使用列名，则只会计算该列非空值的数量。</p>\n<p>另外，<code>COUNT()</code> 函数的结果是一个整数值。即使结果是零，也不会返回 NULL，这点需要谨记。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里着重说一下<code>COUNT( DISTINCT exam_id, score IS NOT NULL OR NULL )</code>这一句，判断 score 是否为 null ，如果是即为真，如果不是返回 null；注意这里如果不加 <code>or null</code> 在不是 null 的情况下只会返回 false 也就是返回 0；</p>\n<p><code>COUNT</code>本身是不可以对多列求行数的，<code>distinct</code>的加入是的多列成为一个整体，可以求出现的行数了;<code>count distinct</code>在计算时只返回非 null 的行, 这个也要注意；</p>\n<p>另外通过本题 get 到了------&gt;count 加条件常用句式<code>count( 列判断 or null)</code></p>\n<h3> 得分不小于平均分的最低分</h3>\n<p><strong>描述</strong>： 请从试卷作答记录表中找到 SQL 试卷得分不小于该类试卷平均得分的用户最低得分。</p>\n<p>示例数据 exam_record 表（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-02-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>9003</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p><code>examination_info</code> 表（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>SQL</td>\n<td>easy</td>\n<td>60</td>\n<td>2020-02-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-08-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>示例输出数据：</p>\n<table>\n<thead>\n<tr>\n<th>min_score_over_avg</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>87</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：试卷 9001 和 9002 为 SQL 类别，作答这两份试卷的得分有[80,89,87,90]，平均分为 86.5，不小于平均分的最小分数为 87</p>\n<p><strong>思路</strong>：这类题目第一眼看确实很复杂， 因为不知道从哪入手，但是当我们仔细读题审题后，要学会抓住题干中的关键信息。以本题为例：<code>请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。</code>你能一眼从中提取哪些有效信息来作为解题思路？</p>\n<p>第一条：找到==SQL==试卷得分</p>\n<p>第二条：该类试卷==平均得分==</p>\n<p>第三条：该类试卷的==用户最低得分==</p>\n<p>然后中间的 “桥梁” 就是==不小于==</p>\n<p>将条件拆分后，先逐步完成</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后再找出该类试卷的最低得分，接着将结果集<code>【80, 89,87,90】</code> 去和平均分数作比较，方可得出最终答案。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其实这类题目给出的要求看似很 “绕”，但其实仔细梳理一遍，将大条件拆分成小条件，逐个拆分完以后，最后将所有条件拼凑起来。反正只要记住：<strong>抓主干，理分支</strong>，问题便迎刃而解。</p>\n<h2> 分组查询</h2>\n<h3> 平均活跃天数和月活人数</h3>\n<p><strong>描述</strong>：用户在牛客试卷作答区作答记录存储在表 <code>exam_record</code> 中，内容如下：</p>\n<p><code>exam_record</code> 表（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-07-02 09:01:01</td>\n<td>2021-07-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-07-02 19:01:01</td>\n<td>2021-07-02 19:30:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-07-05 18:01:01</td>\n<td>2021-07-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-07-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>9003</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1006</td>\n<td>9002</td>\n<td>2021-09-02 12:11:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1007</td>\n<td>9002</td>\n<td>2020-09-02 12:11:01</td>\n<td>2020-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>请计算 2021 年每个月里试卷作答区用户平均月活跃天数 <code>avg_active_days</code> 和月度活跃人数 <code>mau</code>，上面数据的示例输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>month</th>\n<th>avg_active_days</th>\n<th>mau</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>202107</td>\n<td>1.50</td>\n<td>2</td>\n</tr>\n<tr>\n<td>202109</td>\n<td>1.25</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：2021 年 7 月有 2 人活跃，共活跃了 3 天（1001 活跃 1 天，1002 活跃 2 天），平均活跃天数 1.5；2021 年 9 月有 4 人活跃，共活跃了 5 天，平均活跃天数 1.25，结果保留 2 位小数。</p>\n<p>注：此处活跃指有==交卷==行为。</p>\n<p><strong>思路</strong>：读完题先注意高亮部分；一般求天数和月活跃人数马上就要想到相关的日期函数；这一题我们同样来进行拆分，把问题细化再解决；首先求活跃人数，肯定要用到<code>COUNT()</code>，那这里首先就有一个坑，不知道大家注意了没有？用户 1002 在 9 月份做了两种不同的试卷，所以这里要注意去重，不然在统计的时候，活跃人数是错的；第二个就是要知道日期的格式化，如上表，题目要求以<code>202107</code>这种日期格式展现，要用到<code>DATE_FORMAT</code>来进行格式化。</p>\n<p>基本用法：</p>\n<p><code>DATE_FORMAT(date_value, format)</code></p>\n<ul>\n<li><code>date_value</code> 参数是待格式化的日期或时间值。</li>\n<li><code>format</code> 参数是指定的日期或时间格式（这个和 Java 里面的日期格式一样）。</li>\n</ul>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里多说一句, 使用<code>COUNT(DISTINCT uid, DATE_FORMAT(submit_time, '%Y%m%d'))</code> 可以统计在 <code>uid</code> 列和 <code>submit_time</code> 列按照年份、月份和日期进行格式化后的组合值的数量。</p>\n<h3> 月总刷题数和日均刷题数</h3>\n<p><strong>描述</strong>：现有一张题目练习记录表 <code>practice_record</code>，示例内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>question_id</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>8001</td>\n<td>2021-08-02 11:41:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:30:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:20:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>8002</td>\n<td>2021-09-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1003</td>\n<td>8002</td>\n<td>2021-08-01 19:38:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>请从中统计出 2021 年每个月里用户的月总刷题数 <code>month_q_cnt</code> 和日均刷题数 <code>avg_day_q_cnt</code>（按月份升序排序）以及该年的总体情况，示例数据输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>submit_month</th>\n<th>month_q_cnt</th>\n<th>avg_day_q_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>202108</td>\n<td>2</td>\n<td>0.065</td>\n</tr>\n<tr>\n<td>202109</td>\n<td>3</td>\n<td>0.100</td>\n</tr>\n<tr>\n<td>2021 汇总</td>\n<td>5</td>\n<td>0.161</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：2021 年 8 月共有 2 次刷题记录，日均刷题数为 2/31=0.065（保留 3 位小数）；2021 年 9 月共有 3 次刷题记录，日均刷题数为 3/30=0.100；2021 年共有 5 次刷题记录（年度汇总平均无实际意义，这里我们按照 31 天来算 5/31=0.161）</p>\n<blockquote>\n<p>牛客已经采用最新的 Mysql 版本，如果您运行结果出现错误：ONLY_FULL_GROUP_BY，意思是：对于 GROUP BY 聚合操作，如果在 SELECT 中的列，没有在 GROUP BY 中出现，那么这个 SQL 是不合法的，因为列不在 GROUP BY 从句中，也就是说查出来的列必须在 group by 后面出现否则就会报错，或者这个字段出现在聚合函数里面。</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>看到实例数据就要马上联想到相关的函数，比如<code>submit_month</code>就要用到<code>DATE_FORMAT</code>来格式化日期。然后查出每月的刷题数量。</p>\n<p>每月的刷题数量</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接着第三列这里要用到<code>DAY(LAST_DAY(date_value))</code>函数来查找给定日期的月份中的天数。</p>\n<p>示例代码如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 <code>LAST_DAY()</code> 函数获取给定日期的当月最后一天，然后使用 <code>DAY()</code> 函数提取该日期的天数。这样就能获得指定月份的天数。</p>\n<p>需要注意的是，<code>LAST_DAY()</code> 函数返回的是日期值，而 <code>DAY()</code> 函数用于提取日期值中的天数部分。</p>\n<p>有了上述的分析之后，即可马上写出答案，这题复杂就复杂在处理日期上，其中的逻辑并不难。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在实例数据输出中因为最后一行需要得出汇总数据，所以这里要 <code>UNION ALL</code>加到结果集中；别忘了最后要排序！</p>\n<h3> 未完成试卷数大于 1 的有效用户（较难）</h3>\n<p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-07-02 09:01:01</td>\n<td>2021-07-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-07-02 19:01:01</td>\n<td>2021-07-02 19:30:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-07-05 18:01:01</td>\n<td>2021-07-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-07-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>9003</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1006</td>\n<td>9002</td>\n<td>2021-09-02 12:11:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1007</td>\n<td>9002</td>\n<td>2020-09-02 12:11:01</td>\n<td>2020-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>还有一张试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间），示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>SQL</td>\n<td>easy</td>\n<td>60</td>\n<td>2020-02-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-08-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>请统计 2021 年每个未完成试卷作答数大于 1 的有效用户的数据（有效用户指完成试卷作答数至少为 1 且未完成数小于 5），输出用户 ID、未完成试卷作答数、完成试卷作答数、作答过的试卷 tag 集合，按未完成试卷数量由多到少排序。示例数据的输出结果如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>incomplete_cnt</th>\n<th>complete_cnt</th>\n<th>detail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1002</td>\n<td>2</td>\n<td>4</td>\n<td>2021-09-01:算法;2021-07-02:SQL;2021-09-02:SQL;2021-09-05:SQL;2021-07-05:SQL</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：2021 年的作答记录中，除了 1004，其他用户均满足有效用户定义，但只有 1002 未完成试卷数大于 1，因此只输出 1002，detail 中是 1002 作答过的试卷{日期:tag}集合，日期和 tag 间用 <strong>:</strong> 连接，多元素间用 <strong>;</strong> 连接。</p>\n<p><strong>思路：</strong></p>\n<p>仔细读题后，分析出：首先要联表，因为后面要输出<code>tag</code>；</p>\n<p>筛选出 2021 年的数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据 uid 进行分组，然后对每个用户进行条件进行判断，题目中要求<code>完成试卷数至少为1,未完成试卷数要大于1，小于5</code></p>\n<p>那么等会儿写 sql 的时候条件应该是：<code>未完成 &gt; 1 and 已完成 &gt;=1 and 未完成 &lt; 5</code></p>\n<p>因为最后要用到字符串的拼接，而且还要组合拼接，这个可以用<code>GROUP_CONCAT</code>函数，下面简单介绍一下该函数的用法：</p>\n<p>基本格式：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>expr</code>：要连接的列或表达式。</li>\n<li><code>DISTINCT</code>：可选参数，用于去重。当指定了 <code>DISTINCT</code>，相同的值只会出现一次。</li>\n<li><code>ORDER BY</code>：可选参数，用于排序连接后的值。可以选择升序 (<code>ASC</code>) 或降序 (<code>DESC</code>) 排序。</li>\n<li><code>SEPARATOR sep</code>：可选参数，用于设置连接后的值的分隔符。（本题要用这个参数设置 ; 号 ）</li>\n</ul>\n<p><code>GROUP_CONCAT()</code> 函数常用于 <code>GROUP BY</code> 子句中，将一组行的值连接为一个字符串，并在结果集中以聚合的形式返回。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>SUM(CASE WHEN a.submit_time IS NULL THEN 1 END)</code> 统计了每个用户未完成的记录数量。</li>\n<li><code>SUM(CASE WHEN a.submit_time IS NOT NULL THEN 1 END)</code> 统计了每个用户已完成的记录数量。</li>\n<li><code>GROUP_CONCAT(DISTINCT CONCAT(DATE_FORMAT(a.start_time, '%Y-%m-%d'), ':', b.tag) ORDER BY a.start_time SEPARATOR ';')</code> 将每个用户的考试日期和标签以逗号分隔的形式连接成一个字符串，并按考试开始时间进行排序。</li>\n</ul>\n<h2> 嵌套子查询</h2>\n<h3> 月均完成试卷数不小于 3 的用户爱作答的类别（较难）</h3>\n<p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code>：用户 ID, <code>exam_id</code>：试卷 ID, <code>start_time</code>：开始作答时间, <code>submit_time</code>：交卷时间，没提交的话为 NULL, <code>score</code>：得分），示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-07-02 09:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:21:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-02 12:01:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-07-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 12:01:01</td>\n<td>2021-09-08 12:11:01</td>\n<td>40</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-08 13:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-08 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 15:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-02 12:11:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code>：试卷 ID, <code>tag</code>：试卷类别, <code>difficulty</code>：试卷难度, <code>duration</code>：考试时长, <code>release_time</code>：发布时间），示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>easy</td>\n<td>60</td>\n<td>2020-02-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-08-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>请从表中统计出 “当月均完成试卷数”不小于 3 的用户们爱作答的类别及作答次数，按次数降序输出，示例输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>tag</th>\n<th>tag_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++</td>\n<td>4</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>2</td>\n</tr>\n<tr>\n<td>算法</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：用户 1002 和 1005 在 2021 年 09 月的完成试卷数目均为 3，其他用户均小于 3；然后用户 1002 和 1005 作答过的试卷 tag 分布结果按作答次数降序排序依次为 C++、SQL、算法。</p>\n<p><strong>思路</strong>：这题考察联合子查询，重点在于<code>月均回答&gt;=3</code>, 但是个人认为这里没有表述清楚，应该直接说查 9 月的就容易理解多了；这里不是每个月都要&gt;=3 或者是所有答题次数/答题月份。不要理解错误了。</p>\n<p>先查询出哪些用户月均答题大于三次</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有了这一步之后再进行深入，只要能理解上一步(我的意思是不被题目中的月均所困扰)，然后再套一个子查询，查哪些用户包含其中，然后查出题目中所需的列即可。记得排序！！</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 试卷发布当天作答人数和平均分</h3>\n<p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间），示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>3100</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2100</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号</td>\n<td>1500</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>1100</td>\n<td>4</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5 号</td>\n<td>1600</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 6 号</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p><strong>释义</strong>：用户 1001 昵称为牛客 1 号，成就值为 3100，用户等级是 7 级，职业方向为算法，注册时间 2020-01-01 10:00:00</p>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间） 示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>easy</td>\n<td>60</td>\n<td>2020-02-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-08-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分） 示例数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-07-02 09:01:01</td>\n<td>2021-09-01 09:41:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:21:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-02 12:01:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-08-01 12:01:01</td>\n<td>2021-08-01 12:21:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-08-02 12:01:01</td>\n<td>2021-08-02 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-07-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 12:01:01</td>\n<td>2021-09-08 12:11:01</td>\n<td>40</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-01 13:01:01</td>\n<td>2021-09-01 13:41:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-08 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-08 15:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>16</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-02 12:11:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>请计算每张 SQL 类别试卷发布后，当天 5 级以上的用户作答的人数 <code>uv</code> 和平均分 <code>avg_score</code>，按人数降序，相同人数的按平均分升序，示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>uv</th>\n<th>avg_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>3</td>\n<td>81.3</td>\n</tr>\n</tbody>\n</table>\n<p>解释：只有一张 SQL 类别的试卷，试卷 ID 为 9001，发布当天（2021-09-01）有 1001、1002、1003、1005 作答过，但是 1003 是 5 级用户，其他 3 位为 5 级以上，他们三的得分有[70,80,85,90]，平均分为 81.3（保留 1 位小数）。</p>\n<p><strong>思路</strong>：这题看似很复杂，但是先逐步将“外边”条件拆分，然后合拢到一起，答案就出来，多表查询反正记住：由外向里，抽丝剥茧。</p>\n<p>先把三种表连起来，同时给定一些条件，比如题目中要求<code>等级&gt; 5</code>的用户，那么可以先查出来</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接着注意题目中要求：<code>每张sql类别试卷发布后，当天作答用户</code>，注意其中的==当天==，那我们马上就要想到要用到时间的比较。</p>\n<p>对试卷发布日期和开始考试日期进行比较：<code>DATE(e_info.release_time) = DATE(record.start_time)</code>；不用担心<code>submit_time</code> 为 null 的问题，后续在 where 中会给过滤掉。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意最后的分组排序！先按人数排，若一致，按平均分排。</p>\n<h3> 作答试卷得分大于过 80 的人的用户等级分布</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>3100</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2100</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号</td>\n<td>1500</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>1100</td>\n<td>4</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5 号</td>\n<td>1600</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 6 号</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>easy</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答信息表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:41:01</td>\n<td>79</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:21:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-08-01 12:01:01</td>\n<td>2021-08-01 12:21:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 12:01:01</td>\n<td>2021-09-08 12:11:01</td>\n<td>40</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-01 13:01:01</td>\n<td>2021-09-01 13:41:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-01 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-08 15:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>88</td>\n</tr>\n<tr>\n<td>16</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-02 12:11:01</td>\n<td>2021-09-02 12:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>统计作答 SQL 类别的试卷得分大于过 80 的人的用户等级分布，按数量降序排序（保证数量都不同）。示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>level</th>\n<th>level_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6</td>\n<td>2</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>解释：9001 为 SQL 类试卷，作答该试卷大于 80 分的人有 1002、1003、1005 共 3 人，6 级两人，5 级一人。</p>\n<p>**思路：**这题和上一题都是一样的数据，只是查询条件改变了而已，上一题理解了，这题分分钟做出来。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 合并查询</h2>\n<h3> 每个题目和每份试卷被作答的人数和次数</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:41:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>题目练习表 practice_record（uid 用户 ID, question_id 题目 ID, submit_time 提交时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>question_id</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>8001</td>\n<td>2021-08-02 11:41:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:30:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:20:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>8002</td>\n<td>2021-09-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1003</td>\n<td>8001</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1003</td>\n<td>8001</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1003</td>\n<td>8002</td>\n<td>2021-08-01 19:38:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>请统计每个题目和每份试卷被作答的人数和次数，分别按照\"试卷\"和\"题目\"的 uv &amp; pv 降序显示，示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>tid</th>\n<th>uv</th>\n<th>pv</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>9002</td>\n<td>1</td>\n<td>3</td>\n</tr>\n<tr>\n<td>8001</td>\n<td>3</td>\n<td>5</td>\n</tr>\n<tr>\n<td>8002</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：“试卷”有 3 人共练习 3 次试卷 9001，1 人作答 3 次 9002；“刷题”有 3 人刷 5 次 8001，有 2 人刷 2 次 8002</p>\n<p><strong>思路</strong>：这题的难点和易错点在于<code>UNOIN</code>和<code>ORDER BY</code> 同时使用的问题</p>\n<p>有以下几种情况：使用<code>union</code>和多个<code>order by</code>不加括号，报错！</p>\n<p><code>order by</code>在<code>union</code>连接的子句中不起作用；</p>\n<p>比如不加括号：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>直接报语法错误，如果没有括号，只能有一个<code>order by</code></p>\n<p>还有一种<code>order by</code>不起作用的情况，但是能在子句的子句中起作用，这里的解决方案就是在外面再套一层查询。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 分别满足两个活动的人</h3>\n<p><strong>描述</strong>： 为了促进更多用户在牛客平台学习和刷题进步，我们会经常给一些既活跃又表现不错的用户发放福利。假使以前我们有两拨运营活动，分别给每次试卷得分都能到 85 分的人（activity1）、至少有一次用了一半时间就完成高难度试卷且分数大于 80 的人（activity2）发了福利券。</p>\n<p>现在，需要你一次性将这两个活动满足的人筛选出来，交给运营同学。请写出一个 SQL 实现：输出 2021 年里，所有每次试卷得分都能到 85 分的人以及至少有一次用了一半时间就完成高难度试卷且分数大于 80 的人的 id 和活动号，按用户 ID 排序输出。</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>easy</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td><strong>86</strong></td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:30:01</td>\n<td>85</td>\n</tr>\n</tbody>\n</table>\n<p>示例数据输出结果：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>activity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>activity2</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>activity1</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>activity1</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>activity2</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：用户 1001 最小分数 81 不满足活动 1，但 29 分 59 秒完成了 60 分钟长的试卷得分 81，满足活动 2；1003 最小分数 86 满足活动 1，完成时长都大于试卷时长的一半，不满足活动 2；用户 1004 刚好用了一半时间（30 分钟整）完成了试卷得分 85，满足活动 1 和活动 2。</p>\n<p><strong>思路</strong>： 这一题需要涉及到时间的减法，需要用到 <code>TIMESTAMPDIFF()</code> 函数计算两个时间戳之间的分钟差值。</p>\n<p>下面我们来看一下基本用法</p>\n<p>示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>TIMESTAMPDIFF()</code> 函数的第一个参数是时间单位，这里我们选择 <code>MINUTE</code> 表示返回分钟差值。第二个参数是较早的时间戳，第三个参数是较晚的时间戳。函数会返回它们之间的分钟差值</p>\n<p>了解了这个函数的用法之后，我们再回过头来看<code>activity1</code>的要求，求分数大于 85 即可，那我们还是先把这个写出来，后续思路就会清晰很多</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据条件 2，接着写出<code>在一半时间内完成高难度试卷且分数大于80的人</code></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后再把两者<code>UNION</code> 起来即可。（这里特别要注意括号问题和<code>order by</code>位置，具体用法在上一篇中已提及）</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 连接查询</h2>\n<h3> 满足条件的用户的试卷完成数和题目练习数（困难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 user_info（uid 用户 ID，nick_name 昵称, achievement 成就值, level 等级, job 职业方向, register_time 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>3100</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2300</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号</td>\n<td>2500</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>1200</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5 号</td>\n<td>1600</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 6 号</td>\n<td>2000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 examination_info（exam_id 试卷 ID, tag 试卷类别, difficulty 试卷难度, duration 考试时长, release_time 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:51</td>\n<td>89</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:30:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:02</td>\n<td>85</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1006</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>题目练习记录表 practice_record（uid 用户 ID, question_id 题目 ID, submit_time 提交时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>question_id</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>8001</td>\n<td>2021-08-02 11:41:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:30:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:20:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>8002</td>\n<td>2021-09-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>8001</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1004</td>\n<td>8002</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1001</td>\n<td>8002</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1004</td>\n<td>8002</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>8002</td>\n<td>2021-08-02 19:58:01</td>\n<td>94</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1004</td>\n<td>8003</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1004</td>\n<td>8003</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1004</td>\n<td>8003</td>\n<td>2021-08-01 19:38:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>请你找到高难度 SQL 试卷得分平均值大于 80 并且是 7 级的红名大佬，统计他们的 2021 年试卷总完成次数和题目总练习次数，只保留 2021 年有试卷完成记录的用户。结果按试卷完成数升序，按题目练习数降序。</p>\n<p>示例数据输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_cnt</th>\n<th>question_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>解释：用户 1001、1003、1004、1006 满足高难度 SQL 试卷得分平均值大于 80，但只有 1001、1003 是 7 级红名大佬；1001 完成了 1 次试卷 1001，练习了 2 次题目；1003 完成了 2 次试卷 9001、9002，未练习题目（因此计数为 0）</p>\n<p><strong>思路：</strong></p>\n<p>先将条件进行初步筛选，比如先查出做过高难度 sql 试卷的用户</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后根据题目要求，接着再往里叠条件即可；</p>\n<p>但是这里又要注意：</p>\n<p>第一：不能<code>YEAR(submit_time)= 2021</code>这个条件放到最后，要在<code>ON</code>条件里，因为左连接存在返回左表全部行，右表为 null 的情形，放在 <code>JOIN</code>条件的 <code>ON</code> 子句中的目的是为了确保在连接两个表时，只有满足年份条件的记录会进行连接。这样可以避免其他年份的记录被包含在结果中。即 1001 做过 2021 年的试卷，但没有练习过，如果把条件放到最后，就会排除掉这种情况。</p>\n<p>第二，必须是<code>COUNT(distinct er.exam_id) exam_cnt, COUNT(distinct pr.id) question_cnt，</code>要加 distinct，因为有左连接产生很多重复值。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可能细心的小伙伴会发现，为什么明明将条件限制了<code>tag = 'SQL' AND difficulty = 'hard'</code>，但是用户 1003 仍然能查出两条考试记录，其中一条的考试<code>tag</code>为 <code>C++</code>; 这是由于<code>LEFT JOIN</code>的特性，即使没有与右表匹配的行，左表的所有记录仍然会被保留。</p>\n<h3> 每个 6/7 级用户活跃情况（困难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>3100</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2300</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号</td>\n<td>2500</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>1200</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5 号</td>\n<td>1600</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 6 号</td>\n<td>2600</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>easy</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>78</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:30:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:02</td>\n<td>85</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:59</td>\n<td>84</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9001</td>\n<td>2020-09-01 13:01:01</td>\n<td>2020-09-01 13:41:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>题目练习记录表 <code>practice_record</code>（<code>uid</code> 用户 ID, <code>question_id</code> 题目 ID, <code>submit_time</code> 提交时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>question_id</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>8001</td>\n<td>2021-08-02 11:41:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>8001</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>8002</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>8002</td>\n<td>2021-08-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>8002</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>8002</td>\n<td>2021-08-04 19:58:01</td>\n<td>94</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>8003</td>\n<td>2021-08-03 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>8003</td>\n<td>2021-08-02 19:48:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>8003</td>\n<td>2020-08-01 19:38:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>请统计每个 6/7 级用户总活跃月份数、2021 年活跃天数、2021 年试卷作答活跃天数、2021 年答题活跃天数，按照总活跃月份数、2021 年活跃天数降序排序。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>act_month_total</th>\n<th>act_days_2021</th>\n<th>act_days_2021_exam</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1006</td>\n<td>3</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>2</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：6/7 级用户共有 5 个，其中 1006 在 202109、202108、202008 共 3 个月活跃过，2021 年活跃的日期有 20210907、20210804、20210803、20210802 共 4 天，2021 年在试卷作答区 20210907 活跃 1 天，在题目练习区活跃了 3 天。</p>\n<p><strong>思路：</strong></p>\n<p>这题的关键在于<code>CASE WHEN THEN</code>的使用，不然要写很多的<code>left join</code> 因为会产生很多的结果集。</p>\n<p><code>CASE WHEN THEN</code>语句是一种条件表达式，用于在 SQL 中根据条件执行不同的操作或返回不同的结果。</p>\n<p>语法结构如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个结构中，可以根据需要添加多个<code>WHEN</code>子句，每个<code>WHEN</code>子句后面跟着一个条件（condition）和一个结果（result）。条件可以是任何逻辑表达式，如果满足条件，将返回对应的结果。</p>\n<p>最后的<code>ELSE</code>子句是可选的，用于指定当所有前面的条件都不满足时的默认返回结果。如果没有提供<code>ELSE</code>子句，则默认返回<code>NULL</code>。</p>\n<p>例如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上述示例中，根据学生成绩（score）的不同范围，使用 CASE WHEN THEN 语句返回相应的等级（grade）。如果成绩大于等于 90，则返回\"优秀\"；如果成绩大于等于 80，则返回\"良好\"；如果成绩大于等于 60，则返回\"及格\"；否则返回\"不及格\"。</p>\n<p>那了解到了上述的用法之后，回过头看看该题，要求列出不同的活跃天数。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里的 tag 是先给标记，方便对查询进行区分，将考试和答题分开。</p>\n<p>找出试卷作答区的用户</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>紧接着就是答题作答区的用户</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后将两个结果进行<code>UNION</code> 最后别忘了将结果进行排序 （这题有点类似于分治法的思想）</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-07-13T14:23:50.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL常见面试题总结（4）",
      "url": "https://javaguide.cn/database/sql/sql-questions-04.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-04.html",
      "summary": "题目来源于：牛客题霸 - SQL 进阶挑战 较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。 专用窗口函数 MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 进阶挑战</a></p>\n</blockquote>\n<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>\n<h2> 专用窗口函数</h2>\n<p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：</p>\n<ol>\n<li><code>ROW_NUMBER()</code>: 为查询结果集中的每一行分配一个唯一的整数值。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li><code>RANK()</code>: 计算每一行在排序结果中的排名。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li><code>DENSE_RANK()</code>: 计算每一行在排序结果中的排名，保留相同的排名。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"4\">\n<li><code>NTILE(n)</code>: 将结果分成 n 个基本均匀的桶，并为每个桶分配一个标识号。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"5\">\n<li><code>SUM()</code>, <code>AVG()</code>,<code>COUNT()</code>, <code>MIN()</code>, <code>MAX()</code>: 这些聚合函数也可以与窗口函数结合使用，计算窗口内指定列的汇总、平均值、计数、最小值和最大值。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"6\">\n<li><code>LEAD()</code> 和 <code>LAG()</code>: LEAD 函数用于获取当前行之后的某个偏移量的行的值，而 LAG 函数用于获取当前行之前的某个偏移量的行的值。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"7\">\n<li><code>FIRST_VALUE()</code> 和 <code>LAST_VALUE()</code>: FIRST_VALUE 函数用于获取窗口内指定列的第一个值，LAST_VALUE 函数用于获取窗口内指定列的最后一个值。</li>\n</ol>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>窗口函数通常需要配合 OVER 子句一起使用，用于定义窗口的大小、排序规则和分组方式。</p>\n<h3> 每类试卷得分前三名</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>78</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:40:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:51</td>\n<td>89</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1004</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:30:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1005</td>\n<td>9003</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:02</td>\n<td>85</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1006</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 12:01:01</td>\n<td>2021-09-08 12:11:01</td>\n<td>40</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>找到每类试卷得分的前 3 名，如果两人最大分数相同，选择最小分数大者，如果还相同，选择 uid 大者。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>tid</th>\n<th>uid</th>\n<th>ranking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQL</td>\n<td>1003</td>\n<td>1</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>1004</td>\n<td>2</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>1002</td>\n<td>3</td>\n</tr>\n<tr>\n<td>算法</td>\n<td>1005</td>\n<td>1</td>\n</tr>\n<tr>\n<td>算法</td>\n<td>1006</td>\n<td>2</td>\n</tr>\n<tr>\n<td>算法</td>\n<td>1003</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：有作答得分记录的试卷 tag 有 SQL 和算法，SQL 试卷用户 1001、1002、1003、1004 有作答得分，最高得分分别为 81、81、89、85，最低得分分别为 78、81、86、40，因此先按最高得分排名再按最低得分排名取前三为 1003、1004、1002。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 第二快/慢用时之差大于试卷时长一半的试卷（较难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2021-09-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:51:01</td>\n<td>78</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 09:01:01</td>\n<td>2021-09-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:59:01</td>\n<td>86</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:51</td>\n<td>89</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1004</td>\n<td>9002</td>\n<td>2021-09-01 19:01:01</td>\n<td>2021-09-01 19:30:01</td>\n<td>85</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:31:02</td>\n<td>85</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-08 12:01:01</td>\n<td>2021-09-08 12:11:01</td>\n<td>40</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9002</td>\n<td>2021-09-01 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-01 14:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-09-08 15:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>找到第二快和第二慢用时之差大于试卷时长的一半的试卷信息，按试卷 ID 降序排序。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>60</td>\n<td>2021-09-01 06:00:00</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：试卷 9001 被作答用时有 50 分钟、50 分钟、30 分 1 秒、11 分钟、10 分钟，第二快和第二慢用时之差为 50 分钟-11 分钟=39 分钟，试卷时长为 60 分钟，因此满足大于试卷时长一半的条件，输出试卷 ID、时长、发布时间。</p>\n<p><strong>思路：</strong></p>\n<p>第一步，找到每张试卷完成时间的顺序排名和倒序排名 也就是表 a；</p>\n<p>第二步，与通过试卷信息表 b 建立内连接，并根据试卷 id 分组，利用<code>having</code>筛选排名为第二个数据，将秒转化为分钟并进行比较，最后再根据试卷 id 倒序排序就行</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 连续两次作答试卷的最大时间窗（较难）</h3>\n<p><strong>描述</strong></p>\n<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1006</td>\n<td>9003</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:21:02</td>\n<td>84</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-09-01 12:11:01</td>\n<td>2021-09-01 12:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1006</td>\n<td>9002</td>\n<td>2021-09-06 10:01:01</td>\n<td>2021-09-06 10:21:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1005</td>\n<td>9002</td>\n<td>2021-09-05 10:01:01</td>\n<td>2021-09-05 10:21:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-09-05 10:31:01</td>\n<td>2021-09-05 10:51:01</td>\n<td>81</td>\n</tr>\n</tbody>\n</table>\n<p>请计算在 2021 年至少有两天作答过试卷的人中，计算该年连续两次作答试卷的最大时间窗 <code>days_window</code>，那么根据该年的历史规律他在 <code>days_window</code> 天里平均会做多少套试卷，按最大时间窗和平均做答试卷套数倒序排序。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>days_window</th>\n<th>avg_exam_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1006</td>\n<td>6</td>\n<td>2.57</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：用户 1006 分别在 20210901、20210906、20210907 作答过 3 次试卷，连续两次作答最大时间窗为 6 天（1 号到 6 号），他 1 号到 7 号这 7 天里共做了 3 张试卷，平均每天 3/7=0.428571 张，那么 6 天里平均会做 0.428571*6=2.57 张试卷（保留两位小数）；用户 1005 在 20210905 做了两张试卷，但是只有一天的作答记录，过滤掉。</p>\n<p><strong>思路：</strong></p>\n<p>上面这个解释中提示要对作答记录去重，千万别被骗了，不要去重！去重就通不过测试用例。注意限制时间是 2021 年；</p>\n<p>而且要注意时间差要+1 天；还要注意==没交卷也算在内==！！！！ （反正感觉这题描述不清，出的不是很好）</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 近三个月未完成为 0 的用户完成情况</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code>:用户 ID, <code>exam_id</code>:试卷 ID, <code>start_time</code>:开始作答时间, <code>submit_time</code>:交卷时间，为空的话则代表未完成, <code>score</code>:得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1006</td>\n<td>9003</td>\n<td>2021-09-06 10:01:01</td>\n<td>2021-09-06 10:21:02</td>\n<td>84</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-08-02 12:11:01</td>\n<td>2021-08-02 12:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1006</td>\n<td>9002</td>\n<td>2021-06-06 10:01:01</td>\n<td>2021-06-06 10:21:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1006</td>\n<td>9002</td>\n<td>2021-05-06 10:01:01</td>\n<td>2021-05-06 10:21:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-05-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-05 10:31:01</td>\n<td>2021-09-05 10:51:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1001</td>\n<td>9003</td>\n<td>2021-08-01 09:01:01</td>\n<td>2021-08-01 09:51:11</td>\n<td>78</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-07-01 09:01:01</td>\n<td>2021-07-01 09:31:00</td>\n<td>81</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-07-01 12:01:01</td>\n<td>2021-07-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-07-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数，按试卷完成数和用户 ID 降序排名。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_complete_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1006</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：用户 1006 近三个有作答试卷的月份为 202109、202108、202106，作答试卷数为 3，全部完成；用户 1001 近三个有作答试卷的月份为 202109、202108、202107，作答试卷数为 5，完成试卷数为 4，因为有未完成试卷，故过滤掉。</p>\n<p><strong>思路:</strong></p>\n<ol>\n<li><code>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数</code>首先看这句话，肯定要先根据人进行分组</li>\n<li>最近三个月，可以采用连续重复排名，倒序排列，排名&lt;=3</li>\n<li>统计作答数</li>\n<li>拼装剩余条件</li>\n<li>排序</li>\n</ol>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 未完成率较高的 50%用户近三个月答卷情况（困难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>3200</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2500</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>2200</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>SQL</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>9004</td>\n<td>PYTHON</td>\n<td>medium</td>\n<td>70</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-01 09:01:01</td>\n<td>2020-01-01 09:21:59</td>\n<td>90</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-01 18:01:01</td>\n<td>2020-01-01 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 10:01:01</td>\n<td>2020-01-02 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-20 10:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-02-01 12:11:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-03-01 19:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-05-02 19:01:01</td>\n<td>2020-05-02 19:32:00</td>\n<td>90</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-01 12:11:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:59:01</td>\n<td>69</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-03-02 12:11:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-05-05 18:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-05-06 12:01:01</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>请统计 SQL 试卷上未完成率较高的 50%用户中，6 级和 7 级用户在有试卷作答记录的近三个月中，每个月的答卷数目和完成数目。按用户 ID、月份升序排序。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>start_month</th>\n<th>total_cnt</th>\n<th>complete_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1002</td>\n<td>202002</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>202003</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>202005</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>解释：各个用户对 SQL 试卷的未完成数、作答总数、未完成率如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>incomplete_cnt</th>\n<th>total_cnt</th>\n<th>incomplete_rate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>3</td>\n<td>7</td>\n<td>0.4286</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>4</td>\n<td>8</td>\n<td>0.5000</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>1</td>\n<td>1</td>\n<td>1.0000</td>\n</tr>\n</tbody>\n</table>\n<p>1001、1002、1003 分别排在 1.0、0.5、0.0 的位置，因此较高的 50%用户（排位&lt;=0.5）为 1002、1003；</p>\n<p>1003 不是 6 级或 7 级；</p>\n<p>有试卷作答记录的近三个月为 202005、202003、202002；</p>\n<p>这三个月里 1002 的作答题数分别为 3、2、2，完成数目分别为 1、1、1。</p>\n<p><strong>思路：</strong></p>\n<p>注意点：这题注意求的是所有的答题次数和完成次数，而 sql 类别的试卷是限制未完成率排名，6, 7 级用户限制的是做题记录。</p>\n<p>先求出未完成率的排名</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再求出最近三个月的练习记录</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 试卷完成数同比 2020 年的增长率及排名变化（困难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>9004</td>\n<td>PYTHON</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-08-02 10:01:01</td>\n<td>2020-08-02 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-04-01 18:01:01</td>\n<td>2020-04-01 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-04-01 09:01:01</td>\n<td>2020-04-01 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-03-02 19:01:01</td>\n<td>2021-03-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-05-02 12:01:01</td>\n<td>2021-05-02 12:31:01</td>\n<td>98</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-01-02 10:01:01</td>\n<td>2020-01-02 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-02-02 12:01:01</td>\n<td>2020-02-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:59:01</td>\n<td>69</td>\n</tr>\n<tr>\n<td>16</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-03-02 12:11:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-01-20 10:01:01</td>\n<td>2021-01-20 10:10:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9003</td>\n<td>2021-04-02 19:01:01</td>\n<td>2021-04-02 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1002</td>\n<td>9003</td>\n<td>2021-01-01 18:01:01</td>\n<td>2021-01-01 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1004</td>\n<td>9004</td>\n<td>2020-05-02 12:01:01</td>\n<td>2020-05-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1001</td>\n<td>9004</td>\n<td>2021-09-02 12:11:01</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>1002</td>\n<td>9004</td>\n<td>2020-01-01 12:11:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>83</td>\n</tr>\n</tbody>\n</table>\n<p>请计算 2021 年上半年各类试卷的做完次数相比 2020 年上半年同期的增长率（百分比格式，保留 1 位小数），以及做完次数排名变化，按增长率和 21 年排名降序输出。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>tag</th>\n<th>exam_cnt_20</th>\n<th>exam_cnt_21</th>\n<th>growth_rate</th>\n<th>exam_cnt_rank_20</th>\n<th>exam_cnt_rank_21</th>\n<th>rank_delta</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SQL</td>\n<td>3</td>\n<td>2</td>\n<td>-33.3%</td>\n<td>1</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>解释：2020 年上半年有 3 个 tag 有作答完成的记录，分别是 C++、SQL、PYTHON，它们被做完的次数分别是 3、3、2，做完次数排名为 1、1（并列）、3；</p>\n<p>2021 年上半年有 2 个 tag 有作答完成的记录，分别是算法、SQL，它们被做完的次数分别是 3、2，做完次数排名为 1、2；具体如下：</p>\n<table>\n<thead>\n<tr>\n<th>tag</th>\n<th>start_year</th>\n<th>exam_cnt</th>\n<th>exam_cnt_rank</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++</td>\n<td>2020</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>2020</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>PYTHON</td>\n<td>2020</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>算法</td>\n<td>2021</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>2021</td>\n<td>2</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>因此能输出同比结果的 tag 只有 SQL，从 2020 到 2021 年，做完次数 3=&gt;2，减少 33.3%（保留 1 位小数）；排名 1=&gt;2，后退 1 名。</p>\n<p><strong>思路：</strong></p>\n<p>本题难点在于长整型的数据类型要求不能有负号产生，用 cast 函数转换数据类型为 signed。</p>\n<p>以及用到的<code>增长率计算公式：(exam_cnt_21-exam_cnt_20)/exam_cnt_20</code></p>\n<p>做完次数排名变化（2021 年和 2020 年比排名升了或者降了多少）</p>\n<p>计算公式：<code>exam_cnt_rank_21 - exam_cnt_rank_20</code></p>\n<p>在 MySQL 中，<code>CAST()</code> 函数用于将一个表达式的数据类型转换为另一个数据类型。它的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>示例就不一一举例了，这个函数很简单</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 聚合窗口函数</h2>\n<h3> 对试卷得分做 min-max 归一化</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>算法</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>9004</td>\n<td>PYTHON</td>\n<td>medium</td>\n<td>70</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-01-02 12:01:01</td>\n<td>2020-01-02 12:31:01</td>\n<td>68</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 10:01:01</td>\n<td>2020-01-02 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-01 09:01:01</td>\n<td>2020-01-01 09:21:59</td>\n<td>90</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1004</td>\n<td>9002</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-01-01 19:01:01</td>\n<td>2020-01-01 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 12:01:01</td>\n<td>2020-01-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-01-01 12:11:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:32:00</td>\n<td>90</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9004</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9005</td>\n<td>2020-01-02 12:11:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>在物理学及统计学数据计算时，有个概念叫 min-max 标准化，也被称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。</p>\n<p>转换函数为：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/sql/29A377601170AB822322431FCDF7EDFE.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>请你将用户作答高难度试卷的得分在每份试卷作答记录内执行 min-max 归一化后缩放到[0,100]区间，并输出用户 ID、试卷 ID、归一化后分数平均值；最后按照试卷 ID 升序、归一化分数降序输出。（注：得分区间默认为[0,100]，如果某个试卷作答记录中只有一个得分，那么无需使用公式，归一化并缩放后分数仍为原分数）。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_id</th>\n<th>avg_new_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>9001</td>\n<td>98</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>9001</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9002</td>\n<td>88</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>9002</td>\n<td>75</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9002</td>\n<td>70</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>9002</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>解释：高难度试卷有 9001、9002、9003；</p>\n<p>作答了 9001 的记录有 3 条，分数分别为 68、89、90，按给定公式归一化后分数为：0、95、100，而后两个得分都是用户 1001 作答的，因此用户 1001 对试卷 9001 的新得分为(95+100)/2≈98（只保留整数部分），用户 1003 对于试卷 9001 的新得分为 0。最后结果按照试卷 ID 升序、归一化分数降序输出。</p>\n<p><strong>思路：</strong></p>\n<p>注意点：</p>\n<ol>\n<li>将高难度的试卷，按每类试卷的得分，利用 max/min (col) over()窗口函数求得各组内最大最小值，然后进行归一化公式计算，缩放区间为[0,100]，即 min_max*100</li>\n<li>若某类试卷只有一个得分，则无需使用归一化公式，因只有一个分 max_score=min_score,score，公式后结果可能会变成 0。</li>\n<li>最后结果按 uid、exam_id 分组求归一化后均值，score 为 NULL 的要过滤掉。</li>\n</ol>\n<p>最后就是仔细看上面公式 （说实话，这题看起来就很绕）</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 每份试卷每月作答数和截止当月的作答总数</h3>\n<p><strong>描述:</strong></p>\n<p>现有试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-01 09:01:01</td>\n<td>2020-01-01 09:21:59</td>\n<td>90</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-20 10:01:01</td>\n<td>2020-01-20 10:10:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-02-01 12:11:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-03-01 19:01:01</td>\n<td>2020-03-01 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-05-02 19:01:01</td>\n<td>2020-05-02 19:32:00</td>\n<td>90</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:59:01</td>\n<td>69</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:31:01</td>\n<td>68</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-03-02 12:11:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>请输出每份试卷每月作答数和截止当月的作答总数。<br>\n由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>start_month</th>\n<th>month_cnt</th>\n<th>cum_exam_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>202001</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>9001</td>\n<td>202002</td>\n<td>1</td>\n<td>3</td>\n</tr>\n<tr>\n<td>9001</td>\n<td>202003</td>\n<td>3</td>\n<td>6</td>\n</tr>\n<tr>\n<td>9001</td>\n<td>202005</td>\n<td>1</td>\n<td>7</td>\n</tr>\n<tr>\n<td>9002</td>\n<td>202001</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>9002</td>\n<td>202002</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>9002</td>\n<td>202003</td>\n<td>1</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>解释：试卷 9001 在 202001、202002、202003、202005 共 4 个月有被作答记录，每个月被作答数分别为 2、1、3、1，截止当月累积作答总数为 2、3、6、7。</p>\n<p><strong>思路：</strong></p>\n<p>这题就两个关键点：统计截止当月的作答总数、输出每份试卷每月作答数和截止当月的作答总数</p>\n<p>这个是关键<code>**sum(count(*)) over(partition by exam_id order by date_format(start_time,'%Y%m'))**</code></p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 每月及截止当月的答题情况（较难）</h3>\n<p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-01 09:01:01</td>\n<td>2020-01-01 09:21:59</td>\n<td>90</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-20 10:01:01</td>\n<td>2020-01-20 10:10:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-02-01 12:11:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-03-01 19:01:01</td>\n<td>2020-03-01 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1003</td>\n<td>9001</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-05-02 19:01:01</td>\n<td>2020-05-02 19:32:00</td>\n<td>90</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:59:01</td>\n<td>69</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1004</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:31:01</td>\n<td>68</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-02-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1001</td>\n<td>9002</td>\n<td>2020-03-02 12:11:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>请输出自从有用户作答记录以来，每月的试卷作答记录中月活用户数、新增用户数、截止当月的单月最大新增用户数、截止当月的累积用户数。结果按月份升序输出。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>start_month</th>\n<th>mau</th>\n<th>month_add_uv</th>\n<th>max_month_add_uv</th>\n<th>cum_sum_uv</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>202001</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>202002</td>\n<td>4</td>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>202003</td>\n<td>3</td>\n<td>0</td>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>202005</td>\n<td>1</td>\n<td>0</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>month</th>\n<th>1001</th>\n<th>1002</th>\n<th>1003</th>\n<th>1004</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>202001</td>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>202002</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>202003</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>202005</td>\n<td></td>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>由上述矩阵可以看出，2020 年 1 月有 2 个用户活跃（mau=2），当月新增用户数为 2；</p>\n<p>2020 年 2 月有 4 个用户活跃，当月新增用户数为 2，最大单月新增用户数为 2，当前累积用户数为 4。</p>\n<p><strong>思路：</strong></p>\n<p>难点：</p>\n<p>1.如何求每月新增用户</p>\n<p>2.截至当月的答题情况</p>\n<p>大致流程：</p>\n<p>（1）统计每个人的首次登陆月份 <code>min()</code></p>\n<p>（2）统计每月的月活和新增用户数：先得到每个人的首次登陆月份，再对首次登陆月份分组求和是该月份的新增人数</p>\n<p>（3）统计截止当月的单月最大新增用户数、截止当月的累积用户数 ，最终按照按月份升序输出</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/sql/29A377601170AB822322431FCDF7EDFE.png",
      "date_published": "2023-07-13T14:23:50.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL常见面试题总结（5）",
      "url": "https://javaguide.cn/database/sql/sql-questions-05.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-05.html",
      "summary": "题目来源于：牛客题霸 - SQL 进阶挑战 较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。 空值处理 统计有未完成状态的试卷的未完成数和未完成率 描述：",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 进阶挑战</a></p>\n</blockquote>\n<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>\n<h2> 空值处理</h2>\n<h3> 统计有未完成状态的试卷的未完成数和未完成率</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>2021-05-02 10:30:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n</tbody>\n</table>\n<p>请统计有未完成状态的试卷的未完成数 incomplete_cnt 和未完成率 incomplete_rate。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>incomplete_cnt</th>\n<th>complete_rate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>1</td>\n<td>0.333</td>\n</tr>\n</tbody>\n</table>\n<p>解释：试卷 9001 有 3 次被作答的记录，其中两次完成，1 次未完成，因此未完成数为 1，未完成率为 0.333（保留 3 位小数）</p>\n<p><strong>思路</strong>：</p>\n<p>这题只需要注意一个是有条件限制，一个是没条件限制的；要么分别查询条件，然后合并；要么直接在 select 里面进行条件判断。</p>\n<p><strong>答案</strong>：</p>\n<p>写法 1：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>写法 2：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两种写法都可以，只有中间的写法不一样，一个是对符合条件的才<code>COUNT</code>，一个是直接上<code>IF</code>,后者更为直观，最后这个<code>having</code>解释一下， 无论是 <code>complete_rate</code> 还是 <code>incomplete_cnt</code>，只要不为 0 即可，不为 0 就意味着有未完成的。</p>\n<h3> 0 级用户高难度试卷的平均用时和平均得分</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间），数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>10</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>2100</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间），数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>SQL</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>SQL</td>\n<td>easy</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9004</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n</tbody>\n</table>\n<p>请输出每个 0 级用户所有的高难度试卷考试平均用时和平均得分，未完成的默认试卷最大考试时长和 0 分处理。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>avg_score</th>\n<th>avg_time_took</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>33</td>\n<td>36.7</td>\n</tr>\n</tbody>\n</table>\n<p>解释：0 级用户有 1001，高难度试卷有 9001，1001 作答 9001 的记录有 3 条，分别用时 20 分钟、未完成（试卷时长 60 分钟）、30 分钟（未满 31 分钟），分别得分为 80 分、未完成（0 分处理）、20 分。因此他的平均用时为 110/3=36.7（保留一位小数），平均得分为 33 分（取整）</p>\n<p><strong>思路</strong>：这题用<code>IF</code>是判断的最方便的，因为涉及到 NULL 值的判断。当然 <code>case when</code>也可以，大同小异。这题的难点就在于空值的处理，其他的这些查询条件什么的，我相信难不倒大家。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 高级条件语句</h2>\n<h3> 筛选限定昵称成就值活跃日期的用户（较难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>1000</td>\n<td>2</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>进击的 3 号</td>\n<td>2200</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>2500</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5 号</td>\n<td>3000</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-01 12:01:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-02 12:11:01</td>\n<td>2020-02-02 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>16</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-06 12:01:01</td>\n<td>2021-09-06 12:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>17</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-07 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-02-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1004</td>\n<td>9002</td>\n<td>2021-08-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-02-01 11:01:01</td>\n<td>2021-02-01 11:31:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-02-01 11:01:01</td>\n<td>2021-02-01 11:31:01</td>\n<td>84</td>\n</tr>\n</tbody>\n</table>\n<p>题目练习记录表 <code>practice_record</code>（<code>uid</code> 用户 ID, <code>question_id</code> 题目 ID, <code>submit_time</code> 提交时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>question_id</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>8001</td>\n<td>2021-08-02 11:41:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:30:01</td>\n<td>50</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>8001</td>\n<td>2021-09-02 19:20:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1002</td>\n<td>8002</td>\n<td>2021-09-02 19:38:01</td>\n<td>70</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1003</td>\n<td>8002</td>\n<td>2021-09-01 19:38:01</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>请找到昵称以『牛客』开头『号』结尾、成就值在 1200~2500 之间，且最近一次活跃（答题或作答试卷）在 2021 年 9 月的用户信息。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：昵称以『牛客』开头『号』结尾且成就值在 1200~2500 之间的有 1002、1004；</p>\n<p>1002 最近一次试卷区活跃为 2021 年 9 月，最近一次题目区活跃为 2021 年 9 月；1004 最近一次试卷区活跃为 2021 年 8 月，题目区未活跃。</p>\n<p>因此最终满足条件的只有 1002。</p>\n<p><strong>思路</strong>：</p>\n<p>先根据条件列出主要查询语句</p>\n<p>昵称以『牛客』开头『号』结尾: <code>nick_name LIKE \"牛客%号\"</code></p>\n<p>成就值在 1200~2500 之间：<code>achievement BETWEEN 1200 AND 2500</code></p>\n<p>第三个条件因为限定了为 9 月，所以直接写就行：<code>( date_format( record.submit_time, '%Y%m' )= 202109 OR date_format( pr.submit_time, '%Y%m' )= 202109 )</code></p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 筛选昵称规则和试卷规则的作答记录（较难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>1900</td>\n<td>2</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>2200</td>\n<td>5</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>2500</td>\n<td>6</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 555 号</td>\n<td>2000</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>666666</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>C++</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>c#</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>16</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-06 12:01:01</td>\n<td>2021-09-06 12:21:01</td>\n<td>80</td>\n</tr>\n<tr>\n<td>17</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-07 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>2021-05-05 18:59:02</td>\n<td>90</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-01 12:01:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-02 12:11:01</td>\n<td>2020-02-02 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-02-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1004</td>\n<td>9002</td>\n<td>2021-08-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1005</td>\n<td>9001</td>\n<td>2021-02-01 11:01:01</td>\n<td>2021-02-01 11:31:01</td>\n<td>84</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1006</td>\n<td>9001</td>\n<td>2021-02-01 11:01:01</td>\n<td>2021-09-01 11:31:01</td>\n<td>84</td>\n</tr>\n</tbody>\n</table>\n<p>找到昵称以\"牛客\"+纯数字+\"号\"或者纯数字组成的用户对于字母 c 开头的试卷类别（如 C,C++,c#等）的已完成的试卷 ID 和平均得分，按用户 ID、平均分升序排序。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_id</th>\n<th>avg_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1002</td>\n<td>9001</td>\n<td>81</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9002</td>\n<td>85</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>9001</td>\n<td>84</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>9001</td>\n<td>84</td>\n</tr>\n</tbody>\n</table>\n<p>解释：昵称满足条件的用户有 1002、1004、1005、1006；</p>\n<p>c 开头的试卷有 9001、9002；</p>\n<p>满足上述条件的作答记录中，1002 完成 9001 的得分有 81、80，平均分为 81（80.5 取整四舍五入得 81）；</p>\n<p>1002 完成 9002 的得分有 90、82、83，平均分为 85；</p>\n<p><strong>思路</strong>：</p>\n<p>还是老样子，既然给出了条件，就先把各个条件先写出来</p>\n<p>找到昵称以\"牛客\"+纯数字+\"号\"或者纯数字组成的用户： 我最开始是这么写的：<code>nick_name LIKE '牛客%号' OR nick_name REGEXP '^[0-9]+$'</code>，如果表中有个 “牛客 H 号” ，那也能通过。</p>\n<p>所以这里还得用正则： <code>nick_name LIKE '^牛客[0-9]+号'</code></p>\n<p>对于字母 c 开头的试卷类别： <code>e_info.tag LIKE 'c%'</code> 或者 <code>tag regexp '^c|^C'</code> 第一个也能匹配到大写 C</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 根据指定记录是否存在输出不同情况（困难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>19</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>进击的 3 号</td>\n<td>22</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 555 号</td>\n<td>2000</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>666666</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>87</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9003</td>\n<td>2021-09-02 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9004</td>\n<td>2021-09-03 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-02-01 12:01:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-02-02 12:11:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9002</td>\n<td>2021-05-05 18:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9001</td>\n<td>2021-09-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1003</td>\n<td>9003</td>\n<td>2021-02-06 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1003</td>\n<td>9001</td>\n<td>2021-09-07 10:01:01</td>\n<td>2021-09-07 10:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>请你筛选表中的数据，当有任意一个 0 级用户未完成试卷数大于 2 时，输出每个 0 级用户的试卷未完成数和未完成率（保留 3 位小数）；若不存在这样的用户，则输出所有有作答记录的用户的这两个指标。结果按未完成率升序排序。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>incomplete_cnt</th>\n<th>incomplete_rate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1004</td>\n<td>0</td>\n<td>0.000</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>1</td>\n<td>0.500</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>4</td>\n<td>0.667</td>\n</tr>\n</tbody>\n</table>\n<p><strong>解释</strong>：0 级用户有 1001、1003、1004；他们作答试卷数和未完成数分别为：6:4、2:1、0:0；</p>\n<p>存在 1001 这个 0 级用户未完成试卷数大于 2，因此输出这三个用户的未完成数和未完成率（1004 未作答过试卷，未完成率默认填 0，保留 3 位小数后是 0.000）；</p>\n<p>结果按照未完成率升序排序。</p>\n<p>附：如果 1001 不满足『未完成试卷数大于 2』，则需要输出 1001、1002、1003 的这两个指标，因为试卷作答记录表里只有这三个用户的作答记录。</p>\n<p><strong>思路</strong>：</p>\n<p>先把可能满足条件**“0 级用户未完成试卷数大于 2”**的 SQL 写出来</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后再分别写出两种情况的 SQL 查询语句：</p>\n<p>情况 1. 查询存在条件要求的 0 级用户的试卷未完成率</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>情况 2. 查询不存在条件要求时所有有作答记录的 yong 用户的试卷未完成率</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>拼在一起，就是答案</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>V2 版本（根据上面做出的改进，答案缩短了，逻辑更强）：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 各用户等级的不同得分表现占比（较难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>19</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>22</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 555 号</td>\n<td>2000</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>666666</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-05-02 10:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-02-02 19:01:01</td>\n<td>2021-02-02 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-01 12:01:01</td>\n<td>2021-09-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1001</td>\n<td>9003</td>\n<td>2021-09-02 12:01:01</td>\n<td>2021-09-02 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1001</td>\n<td>9001</td>\n<td>2021-06-02 19:01:01</td>\n<td>2021-06-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1001</td>\n<td>9002</td>\n<td>2021-09-05 19:01:01</td>\n<td>2021-09-05 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1001</td>\n<td>9004</td>\n<td>2021-09-03 12:01:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1002</td>\n<td>9001</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-02-01 12:01:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-02-02 12:11:01</td>\n<td>2020-02-02 12:41:01</td>\n<td>76</td>\n</tr>\n</tbody>\n</table>\n<p>为了得到用户试卷作答的定性表现，我们将试卷得分按分界点[90,75,60]分为优良中差四个得分等级（分界点划分到左区间），请统计不同用户等级的人在完成过的试卷中各得分等级占比（结果保留 3 位小数），未完成过试卷的用户无需输出，结果按用户等级降序、占比降序排序。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>level</th>\n<th>score_grade</th>\n<th>ratio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>良</td>\n<td>0.667</td>\n</tr>\n<tr>\n<td>3</td>\n<td>优</td>\n<td>0.333</td>\n</tr>\n<tr>\n<td>0</td>\n<td>良</td>\n<td>0.500</td>\n</tr>\n<tr>\n<td>0</td>\n<td>中</td>\n<td>0.167</td>\n</tr>\n<tr>\n<td>0</td>\n<td>优</td>\n<td>0.167</td>\n</tr>\n<tr>\n<td>0</td>\n<td>差</td>\n<td>0.167</td>\n</tr>\n</tbody>\n</table>\n<p>解释：完成过试卷的用户有 1001、1002；完成了的试卷对应的用户等级和分数等级如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>exam_id</th>\n<th>score</th>\n<th>level</th>\n<th>score_grade</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>9001</td>\n<td>80</td>\n<td>0</td>\n<td>良</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9002</td>\n<td>75</td>\n<td>0</td>\n<td>良</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9002</td>\n<td>60</td>\n<td>0</td>\n<td>中</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9003</td>\n<td>90</td>\n<td>0</td>\n<td>优</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9001</td>\n<td>20</td>\n<td>0</td>\n<td>差</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>9002</td>\n<td>89</td>\n<td>0</td>\n<td>良</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9001</td>\n<td>99</td>\n<td>3</td>\n<td>优</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9003</td>\n<td>82</td>\n<td>3</td>\n<td>良</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>9003</td>\n<td>76</td>\n<td>3</td>\n<td>良</td>\n</tr>\n</tbody>\n</table>\n<p>因此 0 级用户（只有 1001）的各分数等级比例为：优 1/6，良 1/6，中 1/6，差 3/6；3 级用户（只有 1002）各分数等级比例为：优 1/3，良 2/3。结果保留 3 位小数。</p>\n<p><strong>思路</strong>：</p>\n<p>先把 **“将试卷得分按分界点[90,75,60]分为优良中差四个得分等级”**这个条件写出来，这里可以用到<code>case when</code></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这题的关键点就在于这，其他剩下的就是条件拼接了</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 限量查询</h2>\n<h3> 注册时间最早的三个人</h3>\n<p><strong>描述</strong>：</p>\n<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1 号</td>\n<td>19</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-02-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>22</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 555 号</td>\n<td>4000</td>\n<td>7</td>\n<td>C++</td>\n<td>2020-01-11 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>666666</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-11-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>请从中找到注册时间最早的 3 个人。由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>nick_name</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1001</td>\n<td>牛客 1</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>2020-01-02 10:00:00</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>解释：按注册时间排序后选取前三名，输出其用户 ID、昵称、注册时间。</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 注册当天就完成了试卷的名单第三页（较难）</h3>\n<p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1</td>\n<td>19</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>22</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 555 号</td>\n<td>4000</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-11 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 6 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1007</td>\n<td>牛客 7 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1008</td>\n<td>牛客 8 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1009</td>\n<td>牛客 9 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1010</td>\n<td>牛客 10 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1011</td>\n<td>666666</td>\n<td>3000</td>\n<td>6</td>\n<td>C++</td>\n<td>2020-01-02 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷信息表 examination_info（exam_id 试卷 ID, tag 试卷类别, difficulty 试卷难度, duration 考试时长, release_time 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>算法</td>\n<td>hard</td>\n<td>60</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>算法</td>\n<td>hard</td>\n<td>80</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-02 09:01:01</td>\n<td>2020-01-02 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-01-20 10:01:01</td>\n<td>2020-01-20 10:10:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-01-01 12:11:01</td>\n<td>2020-01-01 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-01-01 19:01:01</td>\n<td>2020-01-01 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9002</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1005</td>\n<td>9002</td>\n<td>2020-01-01 12:01:01</td>\n<td>2020-01-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1006</td>\n<td>9001</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1007</td>\n<td>9002</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1008</td>\n<td>9003</td>\n<td>2020-01-02 12:01:01</td>\n<td>2020-01-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1008</td>\n<td>9001</td>\n<td>2020-01-02 12:01:01</td>\n<td>2020-01-02 12:31:01</td>\n<td>98</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1009</td>\n<td>9002</td>\n<td>2020-01-02 12:01:01</td>\n<td>2020-01-02 12:31:01</td>\n<td>82</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1010</td>\n<td>9002</td>\n<td>2020-01-02 12:11:01</td>\n<td>2020-01-02 12:41:01</td>\n<td>76</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1011</td>\n<td>9001</td>\n<td>2020-01-02 10:01:01</td>\n<td>2020-01-02 10:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/sql/D2B491866B85826119EE3474F10D3636.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>找到求职方向为算法工程师，且注册当天就完成了算法类试卷的人，按参加过的所有考试最高得分排名。排名榜很长，我们将采用分页展示，每页 3 条，现在需要你取出第 3 页（页码从 1 开始）的人的信息。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>level</th>\n<th>register_time</th>\n<th>max_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1010</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>76</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>0</td>\n<td>2020-01-01 10:00:00</td>\n<td>75</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>0</td>\n<td>2020-01-01 11:00:00</td>\n<td>60</td>\n</tr>\n</tbody>\n</table>\n<p>解释：除了 1011 其他用户的求职方向都为算法工程师；算法类试卷有 9001 和 9002，11 个用户注册当天都完成了算法类试卷；计算他们的所有考试最大分时，只有 1002 和 1008 完成了两次考试，其他人只完成了一场考试，1002 两场考试最高分为 81，1008 最高分为 99。</p>\n<p>按最高分排名如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>level</th>\n<th>register_time</th>\n<th>max_score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1008</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>99</td>\n</tr>\n<tr>\n<td>1005</td>\n<td>7</td>\n<td>2020-01-01 10:00:00</td>\n<td>90</td>\n</tr>\n<tr>\n<td>1007</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>89</td>\n</tr>\n<tr>\n<td>1002</td>\n<td>3</td>\n<td>2020-01-01 10:00:00</td>\n<td>83</td>\n</tr>\n<tr>\n<td>1009</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>82</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>0</td>\n<td>2020-01-01 10:00:00</td>\n<td>80</td>\n</tr>\n<tr>\n<td>1010</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>76</td>\n</tr>\n<tr>\n<td>1003</td>\n<td>0</td>\n<td>2020-01-01 10:00:00</td>\n<td>75</td>\n</tr>\n<tr>\n<td>1004</td>\n<td>0</td>\n<td>2020-01-01 11:00:00</td>\n<td>60</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>0</td>\n<td>2020-01-02 11:00:00</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>每页 3 条，第三页也就是第 7~9 条，返回 1010、1003、1004 的行记录即可。</p>\n<p><strong>思路</strong>：</p>\n<ol>\n<li>\n<p>每页三条，即需要取出第三页的人的信息，要用到<code>limit</code></p>\n</li>\n<li>\n<p>统计求职方向为算法工程师且注册当天就完成了算法类试卷的人的<strong>信息和每次记录的得分</strong>，先求满足条件的用户，后用 left join 做连接查找信息和每次记录的得分</p>\n</li>\n</ol>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 文本转换函数</h2>\n<h3> 修复串列了的记录</h3>\n<p><strong>描述</strong>：现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>算法</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>算法</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>9004</td>\n<td>算法,medium,80</td>\n<td></td>\n<td>0</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>录题同学有一次手误将部分记录的试题类别 tag、难度、时长同时录入到了 tag 字段，请帮忙找出这些录错了的记录，并拆分后按正确的列类型输出。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9004</td>\n<td>算法</td>\n<td>medium</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思路</strong>：</p>\n<p>先来学习下本题要用到的函数</p>\n<p><code>SUBSTRING_INDEX</code> 函数用于提取字符串中指定分隔符的部分。它接受三个参数：原始字符串、分隔符和指定要返回的部分的数量。</p>\n<p>以下是 <code>SUBSTRING_INDEX</code> 函数的语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>str</code>：要进行分割的原始字符串。</li>\n<li><code>delimiter</code>：用作分割的字符串或字符。</li>\n<li><code>count</code>：指定要返回的部分的数量。\n<ul>\n<li>如果 <code>count</code> 大于 0，则返回从左边开始的前 <code>count</code> 个部分（以分隔符为界）。</li>\n<li>如果 <code>count</code> 小于 0，则返回从右边开始的前 <code>count</code> 个部分（以分隔符为界），即从右侧向左计数。</li>\n</ul>\n</li>\n</ul>\n<p>下面是一些示例，演示了 <code>SUBSTRING_INDEX</code> 函数的使用：</p>\n<ol>\n<li>\n<p>提取字符串中的第一个部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>提取字符串中的最后一个部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>提取字符串中的前两个部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>提取字符串中的最后两个部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ol>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对过长的昵称截取处理</h3>\n<p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>nick_name</th>\n<th>achievement</th>\n<th>level</th>\n<th>job</th>\n<th>register_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>牛客 1</td>\n<td>19</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>牛客 2 号</td>\n<td>1200</td>\n<td>3</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1003</td>\n<td>牛客 3 号 ♂</td>\n<td>22</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1004</td>\n<td>牛客 4 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-01 11:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1005</td>\n<td>牛客 5678901234 号</td>\n<td>4000</td>\n<td>7</td>\n<td>算法</td>\n<td>2020-01-11 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1006</td>\n<td>牛客 67890123456789 号</td>\n<td>25</td>\n<td>0</td>\n<td>算法</td>\n<td>2020-01-02 11:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>有的用户的昵称特别长，在一些展示场景会导致样式混乱，因此需要将特别长的昵称转换一下再输出，请输出字符数大于 10 的用户信息，对于字符数大于 13 的用户输出前 10 个字符然后加上三个点号：『...』。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>nick_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1005</td>\n<td>牛客 5678901234 号</td>\n</tr>\n<tr>\n<td>1006</td>\n<td>牛客 67890123...</td>\n</tr>\n</tbody>\n</table>\n<p>解释：字符数大于 10 的用户有 1005 和 1006，长度分别为 13、17；因此需要对 1006 的昵称截断输出。</p>\n<p><strong>思路</strong>：</p>\n<p>这题涉及到字符的计算，要计算字符串的字符数（即字符串的长度），可以使用 <code>LENGTH</code> 函数或 <code>CHAR_LENGTH</code> 函数。这两个函数的区别在于对待多字节字符的方式。</p>\n<ol>\n<li><code>LENGTH</code> 函数：它返回给定字符串的字节数。对于包含多字节字符的字符串，每个字符都会被当作一个字节来计算。</li>\n</ol>\n<p>示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li><code>CHAR_LENGTH</code> 函数：它返回给定字符串的字符数。对于包含多字节字符的字符串，每个字符会被当作一个字符来计算。</li>\n</ol>\n<p>示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 大小写混乱时的筛选统计（较难）</h3>\n<p><strong>描述</strong>：</p>\n<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>exam_id</th>\n<th>tag</th>\n<th>difficulty</th>\n<th>duration</th>\n<th>release_time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>9001</td>\n<td>算法</td>\n<td>hard</td>\n<td>60</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>2</td>\n<td>9002</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>3</td>\n<td>9003</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>4</td>\n<td>9004</td>\n<td>sql</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>5</td>\n<td>9005</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>6</td>\n<td>9006</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>7</td>\n<td>9007</td>\n<td>C++</td>\n<td>hard</td>\n<td>80</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>8</td>\n<td>9008</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>9</td>\n<td>9009</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n<tr>\n<td>10</td>\n<td>9010</td>\n<td>SQL</td>\n<td>medium</td>\n<td>70</td>\n<td>2021-01-01 10:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>试卷作答信息表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>uid</th>\n<th>exam_id</th>\n<th>start_time</th>\n<th>submit_time</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>9001</td>\n<td>2020-01-01 09:01:01</td>\n<td>2020-01-01 09:21:59</td>\n<td>80</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1002</td>\n<td>9003</td>\n<td>2020-01-20 10:01:01</td>\n<td>2020-01-20 10:10:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>9002</td>\n<td>2020-02-01 12:11:01</td>\n<td>2020-02-01 12:31:01</td>\n<td>83</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1003</td>\n<td>9002</td>\n<td>2020-03-01 19:01:01</td>\n<td>2020-03-01 19:30:01</td>\n<td>75</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1004</td>\n<td>9002</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:11:01</td>\n<td>60</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1005</td>\n<td>9002</td>\n<td>2020-03-01 12:01:01</td>\n<td>2020-03-01 12:41:01</td>\n<td>90</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1006</td>\n<td>9001</td>\n<td>2020-05-02 19:01:01</td>\n<td>2020-05-02 19:32:00</td>\n<td>20</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1007</td>\n<td>9003</td>\n<td>2020-01-02 19:01:01</td>\n<td>2020-01-02 19:40:01</td>\n<td>89</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1008</td>\n<td>9004</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:20:01</td>\n<td>99</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1008</td>\n<td>9001</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-02-02 12:31:01</td>\n<td>98</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1009</td>\n<td>9002</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-01-02 12:43:01</td>\n<td>81</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1010</td>\n<td>9001</td>\n<td>2020-01-02 12:11:01</td>\n<td>(NULL)</td>\n<td>(NULL)</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1010</td>\n<td>9001</td>\n<td>2020-02-02 12:01:01</td>\n<td>2020-01-02 10:31:01</td>\n<td>89</td>\n</tr>\n</tbody>\n</table>\n<p>试卷的类别 tag 可能出现大小写混乱的情况，请先筛选出试卷作答数小于 3 的类别 tag，统计将其转换为大写后对应的原本试卷作答数。</p>\n<p>如果转换后 tag 并没有发生变化，不输出该条结果。</p>\n<p>由示例数据结果输出如下：</p>\n<table>\n<thead>\n<tr>\n<th>tag</th>\n<th>answer_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>解释：被作答过的试卷有 9001、9002、9003、9004，他们的 tag 和被作答次数如下：</p>\n<table>\n<thead>\n<tr>\n<th>exam_id</th>\n<th>tag</th>\n<th>answer_cnt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9001</td>\n<td>算法</td>\n<td>4</td>\n</tr>\n<tr>\n<td>9002</td>\n<td>C++</td>\n<td>6</td>\n</tr>\n<tr>\n<td>9003</td>\n<td>c++</td>\n<td>2</td>\n</tr>\n<tr>\n<td>9004</td>\n<td>sql</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>作答次数小于 3 的 tag 有 c++和 sql，而转为大写后只有 C++本来就有作答数，于是输出 c++转化大写后的作答次数为 6。</p>\n<p><strong>思路</strong>：</p>\n<p>首先，这题有点混乱，9004 根据示例数据查出来只有 1 次，这里显示有 2 次。</p>\n<p>先看一下大小写转换函数：</p>\n<p>1.<code>UPPER(s)</code>或<code>UCASE(s)</code>函数可以将字符串 s 中的字母字符全部转换成大写字母；</p>\n<p>2.<code>LOWER(s)</code>或者<code>LCASE(s)</code>函数可以将字符串 s 中的字母字符全部转换成小写字母。</p>\n<p>难点在于相同表做连接要查询不同的值</p>\n<p><strong>答案</strong>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/sql/D2B491866B85826119EE3474F10D3636.png",
      "date_published": "2023-07-13T14:23:50.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "LinkedHashMap 源码分析",
      "url": "https://javaguide.cn/java/collection/linkedhashmap-source-code.html",
      "id": "https://javaguide.cn/java/collection/linkedhashmap-source-code.html",
      "summary": "LinkedHashMap 简介 LinkedHashMap 是 Java 提供的一个集合类，它继承自 HashMap，并在 HashMap 基础上维护一条双向链表，使得具备如下特性: 支持遍历时会按照插入顺序有序进行迭代。 支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。",
      "content_html": "<h2> LinkedHashMap 简介</h2>\n<p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，使得具备如下特性:</p>\n<ol>\n<li>支持遍历时会按照插入顺序有序进行迭代。</li>\n<li>支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li>\n</ol>\n<p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png\" alt=\"LinkedHashMap 逻辑结构\" tabindex=\"0\"><figcaption>LinkedHashMap 逻辑结构</figcaption></figure>\n<h2> LinkedHashMap 使用示例</h2>\n<h3> 插入顺序遍历</h3>\n<p>如下所示，我们按照顺序往 <code>LinkedHashMap</code> 添加元素然后进行遍历。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和插入顺序一致的,这一点是 <code>HashMap</code> 所不具备的。</p>\n<h3> 访问顺序遍历</h3>\n<p><code>LinkedHashMap</code> 定义了排序模式 <code>accessOrder</code>(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。</p>\n<p>为了实现访问顺序遍历，我们可以使用传入 <code>accessOrder</code> 属性的 <code>LinkedHashMap</code> 构造方法，并将 <code>accessOrder</code> 设置为 true，表示其具备访问有序性。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和访问顺序一致的。</p>\n<h3> LRU 缓存</h3>\n<p>从上一个我们可以了解到通过 <code>LinkedHashMap</code> 我们可以封装一个简易版的 LRU（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/lru-cache.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>具体实现思路如下：</p>\n<ul>\n<li>继承 <code>LinkedHashMap</code>;</li>\n<li>构造方法中指定 <code>accessOrder</code> 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>\n<li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试代码如下，笔者初始化缓存容量为 2，然后按照次序先后添加 4 个元素。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结果来看，由于缓存容量为 2 ，因此，添加第 3 个元素时，第 1 个元素会被删除。添加第 4 个元素时，第 2 个元素会被删除。</p>\n<h2> LinkedHashMap 源码解析</h2>\n<h3> Node 的设计</h3>\n<p>在正式讨论 <code>LinkedHashMap</code> 前，我们先来聊聊 <code>LinkedHashMap</code> 节点 <code>Entry</code> 的设计,我们都知道 <code>HashMap</code> 的 bucket 上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树:</p>\n<ol>\n<li><s>链表上的节点个数达到树化的阈值 7，即<code>TREEIFY_THRESHOLD - 1</code>。</s></li>\n<li>bucket 的容量达到最小的树化容量即<code>MIN_TREEIFY_CAPACITY</code>。</li>\n</ol>\n<blockquote>\n<p><strong>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/2147\" target=\"_blank\" rel=\"noopener noreferrer\">issue#2147</a>）</strong>：</p>\n<p>链表上的节点个数达到树化的阈值是 8 而非 7。因为源码的判断是从链表初始元素开始遍历，下标是从 0 开始的，所以判断条件设置为 8-1=7，其实是迭代到尾部元素时再判断整个链表长度大于等于 8 才进行树化操作。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/jvm/LinkedHashMap-putval-TREEIFY.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n</blockquote>\n<p>而 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 <code>TreeNode</code> 的设计就是一个比较棘手的问题。</p>\n<p>对此我们不妨来看看两者之间节点类的类图，可以看到:</p>\n<ol>\n<li><code>LinkedHashMap</code> 的节点内部类 <code>Entry</code> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</li>\n<li><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/map-hashmap-linkedhashmap.png\" alt=\"LinkedHashMap 和 HashMap 之间的关系\" tabindex=\"0\"><figcaption>LinkedHashMap 和 HashMap 之间的关系</figcaption></figure>\n<p>很多读者此时就会有这样一个疑问，为什么 <code>HashMap</code> 的树节点 <code>TreeNode</code> 要通过 <code>LinkedHashMap</code> 获取双向链表的特性呢?为什么不直接在 <code>Node</code> 上实现前驱和后继指针呢?</p>\n<p>先来回答第一个问题，我们都知道 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 基础上对节点增加双向指针实现双向链表的特性,所以 <code>LinkedHashMap</code> 内部链表转红黑树时，对应的节点会转为树节点 <code>TreeNode</code>,为了保证使用 <code>LinkedHashMap</code> 时树节点具备双向链表的特性，所以树节点 <code>TreeNode</code> 需要继承 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p>\n<p>再来说说第二个问题，我们直接在 <code>HashMap</code> 的节点 <code>Node</code> 上直接实现前驱和后继指针,然后 <code>TreeNode</code> 直接继承 <code>Node</code> 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 <code>HashMap</code> 时存储键值对的节点类 <code>Node</code> 多了两个没有必要的引用，占用没必要的内存空间。</p>\n<p>所以，为了保证 <code>HashMap</code> 底层的节点类 <code>Node</code> 没有多余的引用，又要保证 <code>LinkedHashMap</code> 的节点类 <code>Entry</code> 拥有存储链表的引用，设计者就让 <code>LinkedHashMap</code> 的节点 <code>Entry</code> 去继承 Node 并增加存储前驱后继节点的引用 <code>before</code>、<code>after</code>，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 <code>TreeNode</code> 再通过继承 <code>Entry</code> 获取 <code>before</code>、<code>after</code> 两个指针。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是这样做，不也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用吗?这不也是一种空间的浪费吗？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于这个问题,引用作者的一段注释，作者们认为在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 构造方法</h3>\n<p><code>LinkedHashMap</code> 构造方法有 4 个实现也比较简单，直接调用父类即 <code>HashMap</code> 的构造方法完成初始化。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们上面也提到了，默认情况下 <code>accessOrder</code> 为 false，如果我们要让 <code>LinkedHashMap</code> 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 <code>accessOrder</code> 设置为 true。</p>\n<h3> get 方法</h3>\n<p><code>get</code> 方法是 <code>LinkedHashMap</code> 增删改查操作中唯一一个重写的方法， <code>accessOrder</code> 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码可以看出，<code>get</code> 的执行步骤非常简单:</p>\n<ol>\n<li>调用父类即 <code>HashMap</code> 的 <code>getNode</code> 获取键值对，若为空则直接返回。</li>\n<li>判断 <code>accessOrder</code> 是否为 true，若为 true 则说明需要保证 <code>LinkedHashMap</code> 的链表访问有序性，执行步骤 3。</li>\n<li>调用 <code>LinkedHashMap</code> 重写的 <code>afterNodeAccess</code> 将当前元素添加到链表末尾。</li>\n</ol>\n<p>关键点在于 <code>afterNodeAccess</code> 方法的实现，这个方法负责将元素移动到链表末尾。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码可以看出， <code>afterNodeAccess</code> 方法完成了下面这些操作:</p>\n<ol>\n<li>如果 <code>accessOrder</code> 为 true 且链表尾部不为当前节点 p，我们则需要将当前节点移到链表尾部。</li>\n<li>获取当前节点 p、以及它的前驱节点 b 和后继节点 a。</li>\n<li>将当前节点 p 的后继指针设置为 null，使其和后继节点 p 断开联系。</li>\n<li>尝试将前驱节点指向后继节点，若前驱节点为空，则说明当前节点 p 就是链表首节点，故直接将后继节点 a 设置为首节点，随后我们再将 p 追加到 a 的末尾。</li>\n<li>再尝试让后继节点 a 指向前驱节点 b。</li>\n<li>上述操作让前驱节点和后继节点完成关联，并将当前节点 p 独立出来，这一步则是将当前节点 p 追加到链表末端，如果链表末端为空，则说明当前链表只有一个节点 p，所以直接让 head 指向 p 即可。</li>\n<li>上述操作已经将 p 成功到达链表末端，最后我们将 tail 指针即指向链表末端的指针指向 p 即可。</li>\n</ol>\n<p>可以结合这张图理解，展示了 key 为 13 的元素被移动到了链表尾部。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-get.png\" alt=\"LinkedHashMap 移动元素 13 到链表尾部\" tabindex=\"0\"><figcaption>LinkedHashMap 移动元素 13 到链表尾部</figcaption></figure>\n<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>\n<h3> remove 方法后置操作——afterNodeRemoval</h3>\n<p><code>LinkedHashMap</code> 并没有对 <code>remove</code> 方法进行重写，而是直接继承 <code>HashMap</code> 的 <code>remove</code> 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，<code>LinkedHashMap</code> 重写了 <code>HashMap</code> 的空实现方法 <code>afterNodeRemoval</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以看到从 <code>HashMap</code> 继承来的 <code>remove</code> 方法内部调用的 <code>removeNode</code> 方法将节点从 bucket 删除后，调用了 <code>afterNodeRemoval</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码可以看出， <code>afterNodeRemoval</code> 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收，整体步骤为:</p>\n<ol>\n<li>获取当前节点 p、以及 e 的前驱节点 b 和后继节点 a。</li>\n<li>让当前节点 p 和其前驱、后继节点断开联系。</li>\n<li>尝试让前驱节点 b 指向后继节点 a，若 b 为空则说明当前节点 p 在链表首部，我们直接将 head 指向后继节点 a 即可。</li>\n<li>尝试让后继节点 a 指向前驱节点 b，若 a 为空则说明当前节点 p 在链表末端，所以直接让 tail 指针指向前驱节点 a 即可。</li>\n</ol>\n<p>可以结合这张图理解，展示了 key 为 13 的元素被删除，也就是从链表中移除了这个元素。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-remove.png\" alt=\"LinkedHashMap 删除元素 13\" tabindex=\"0\"><figcaption>LinkedHashMap 删除元素 13</figcaption></figure>\n<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>\n<h3> put 方法后置操作——afterNodeInsertion</h3>\n<p>同样的 <code>LinkedHashMap</code> 并没有实现插入方法，而是直接继承 <code>HashMap</code> 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:</p>\n<ol>\n<li>重写 <code>afterNodeAccess</code>(上文提到过),如果当前被插入的 key 已存在与 <code>map</code> 中，因为 <code>LinkedHashMap</code> 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 <code>afterNodeAccess</code> 将其放到链表末端。</li>\n<li>重写了 <code>HashMap</code> 的 <code>afterNodeInsertion</code> 方法，当 <code>removeEldestEntry</code> 返回 true 时，会将链表首节点移除。</li>\n</ol>\n<p>这一点我们可以在 <code>HashMap</code> 的插入操作核心方法 <code>putVal</code> 中看到。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述步骤的源码上文已经解释过了，所以这里我们着重了解一下 <code>afterNodeInsertion</code> 的工作流程，假设我们的重写了 <code>removeEldestEntry</code>，当链表 <code>size</code> 超过 <code>capacity</code> 时，就返回 true。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以下图为例，假设笔者最后新插入了一个不存在的节点 19,假设 <code>capacity</code> 为 4，所以 <code>removeEldestEntry</code> 返回 true，我们要将链表首节点移除。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-1.png\" alt=\"LinkedHashMap 中插入新元素 19\" tabindex=\"0\"><figcaption>LinkedHashMap 中插入新元素 19</figcaption></figure>\n<p>移除的步骤很简单，查看链表首节点是否存在，若存在则断开首节点和后继节点的关系，并让首节点指针指向下一节点，所以 head 指针指向了 12，节点 10 成为没有任何引用指向的空对象，等待 GC。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-2.png\" alt=\"LinkedHashMap 中插入新元素 19\" tabindex=\"0\"><figcaption>LinkedHashMap 中插入新元素 19</figcaption></figure>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码可以看出， <code>afterNodeInsertion</code> 方法完成了下面这些操作:</p>\n<ol>\n<li>判断 <code>eldest</code> 是否为 true，只有为 true 才能说明可能需要将最年长的键值对(即链表首部的元素)进行移除，具体是否具体要进行移除，还得确定链表是否为空<code>((first = head) != null)</code>，以及 <code>removeEldestEntry</code> 方法是否返回 true，只有这两个方法返回 true 才能确定当前链表不为空，且链表需要进行移除操作了。</li>\n<li>获取链表第一个元素的 key。</li>\n<li>调用 <code>HashMap</code> 的 <code>removeNode</code> 方法，该方法我们上文提到过，它会将节点从 <code>HashMap</code> 的 bucket 中移除，并且 <code>LinkedHashMap</code> 还重写了 <code>removeNode</code> 中的 <code>afterNodeRemoval</code> 方法，所以这一步将通过调用 <code>removeNode</code> 将元素从 <code>HashMap</code> 的 bucket 中移除，并和 <code>LinkedHashMap</code> 的双向链表断开，等待 gc 回收。</li>\n</ol>\n<h2> LinkedHashMap 和 HashMap 遍历性能比较</h2>\n<p><code>LinkedHashMap</code> 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 <code>HashMap</code> 那种遍历整个 bucket 的方式来说，高效需多。</p>\n<p>这一点我们可以从两者的迭代器中得以印证，先来看看 <code>HashMap</code> 的迭代器，可以看到 <code>HashMap</code> 迭代键值对时会用到一个 <code>nextNode</code> 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相比之下 <code>LinkedHashMap</code> 的迭代器则是直接使用通过 <code>after</code> 指针快速定位到当前节点的后继节点，简洁高效需多。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了验证笔者所说的观点，笔者对这两个容器进行了压测，测试插入 1000w 和迭代 1000w 条数据的耗时，代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结果来看，因为 <code>LinkedHashMap</code> 需要维护双向链表的缘故，插入元素相较于 <code>HashMap</code> 会更耗时，但是有了双向链表明确的前后节点关系，迭代效率相对于前者高效了需多。不过，总体来说却别不大，毕竟数据量这么庞大。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> LinkedHashMap 常见面试题</h2>\n<h3> 什么是 LinkedHashMap？</h3>\n<p><code>LinkedHashMap</code> 是 Java 集合框架中 <code>HashMap</code> 的一个子类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n<h3> LinkedHashMap 如何按照插入顺序迭代元素？</h3>\n<p><code>LinkedHashMap</code> 按照插入顺序迭代元素是它的默认行为。<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</p>\n<h3> LinkedHashMap 如何按照访问顺序迭代元素？</h3>\n<p><code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>\n<h3> LinkedHashMap 如何实现 LRU 缓存？</h3>\n<p>将 <code>accessOrder</code> 设置为 true 并重写 <code>removeEldestEntry</code> 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 true 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。</p>\n<h3> LinkedHashMap 和 HashMap 有什么区别？</h3>\n<p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且迭代效率相较于 <code>HashMap</code> 更加高效。</p>\n<h2> 参考文献</h2>\n<ul>\n<li>LinkedHashMap 源码详细分析（JDK1.8）:<a href=\"https://www.imooc.com/article/22931\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.imooc.com/article/22931</a></li>\n<li>HashMap 与 LinkedHashMap:<a href=\"https://www.cnblogs.com/Spground/p/8536148.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/Spground/p/8536148.html</a></li>\n<li>源于 LinkedHashMap 源码: <a href=\"https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png",
      "date_published": "2023-07-11T13:02:50.000Z",
      "date_modified": "2023-10-08T08:33:50.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "DelayQueue 源码分析",
      "url": "https://javaguide.cn/java/collection/delayqueue-source-code.html",
      "id": "https://javaguide.cn/java/collection/delayqueue-source-code.html",
      "summary": "DelayQueue 简介 DelayQueue 是 JUC 包(java.util.concurrent)为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 BlockingQueue 的一种，底层是一个基于 PriorityQueue 实现的一个无界队列，是线程安全的。关于PriorityQueue可以参考笔者编写的这篇文章：PriorityQueue 源码分析 。",
      "content_html": "<h2> DelayQueue 简介</h2>\n<p><code>DelayQueue</code> 是 JUC 包(<code>java.util.concurrent)</code>为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 <code>BlockingQueue</code> 的一种，底层是一个基于 <code>PriorityQueue</code> 实现的一个无界队列，是线程安全的。关于<code>PriorityQueue</code>可以参考笔者编写的这篇文章：<a href=\"/java/collection/priorityqueue-source-code.html\" target=\"blank\">PriorityQueue 源码分析</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png\" alt=\"BlockingQueue 的实现类\" tabindex=\"0\"><figcaption>BlockingQueue 的实现类</figcaption></figure>\n<p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法（计算是否到期）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认情况下, <code>DelayQueue</code> 会按照到期时间升序编排任务。只有当元素过期时（<code>getDelay()</code>方法返回值小于等于 0），才能从队列中取出。</p>\n<h2> DelayQueue 发展史</h2>\n<ul>\n<li><code>DelayQueue</code> 最早是在 Java 5 中引入的，作为 <code>java.util.concurrent</code> 包中的一部分，用于支持基于时间的任务调度和缓存过期删除等场景，该版本仅仅支持延迟功能的实现，还未解决线程安全问题。</li>\n<li>在 Java 6 中，<code>DelayQueue</code> 的实现进行了优化，通过使用 <code>ReentrantLock</code> 和 <code>Condition</code> 解决线程安全及线程间交互的效率，提高了其性能和可靠性。</li>\n<li>在 Java 7 中，<code>DelayQueue</code> 的实现进行了进一步的优化，通过使用 CAS 操作实现元素的添加和移除操作，提高了其并发操作性能。</li>\n<li>在 Java 8 中，<code>DelayQueue</code> 的实现没有进行重大变化，但是在 <code>java.time</code> 包中引入了新的时间类，如 <code>Duration</code> 和 <code>Instant</code>，使得使用 <code>DelayQueue</code> 进行基于时间的调度更加方便和灵活。</li>\n<li>在 Java 9 中，<code>DelayQueue</code> 的实现进行了一些微小的改进，主要是对代码进行了一些优化和精简。</li>\n</ul>\n<p>总的来说，<code>DelayQueue</code> 的发展史主要是通过优化其实现方式和提高其性能和可靠性，使其更加适用于基于时间的调度和缓存过期删除等场景。</p>\n<h2> DelayQueue 常见使用场景示例</h2>\n<p>我们这里希望任务可以按照我们预期的时间执行，例如提交 3 个任务，分别要求 1s、2s、3s 后执行，即使是乱序添加，1s 后要求 1s 执行的任务会准时执行。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/delayed-task.png\" alt=\"延迟任务\" tabindex=\"0\"><figcaption>延迟任务</figcaption></figure>\n<p>对此我们可以使用 <code>DelayQueue</code> 来实现,所以我们首先需要继承 <code>Delayed</code> 实现 <code>DelayedTask</code>，实现 <code>getDelay</code> 方法以及优先级比较 <code>compareTo</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>完成任务的封装之后，使用就很简单了，设置好多久到期然后将任务提交到延迟队列中即可。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结果可以看出，即使笔者先提到 2s 到期的任务，1s 到期的任务 Task1 还是优先执行的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> DelayQueue 源码解析</h2>\n<p>这里以 JDK1.8 为例，分析一下 <code>DelayQueue</code> 的底层核心源码。</p>\n<p><code>DelayQueue</code> 的类定义如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>DelayQueue</code> 继承了 <code>AbstractQueue</code> 类，实现了 <code>BlockingQueue</code> 接口。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-class-diagram.png\" alt=\"DelayQueue类图\" tabindex=\"0\"><figcaption>DelayQueue类图</figcaption></figure>\n<h3> 核心成员变量</h3>\n<p><code>DelayQueue</code> 的 4 个核心成员变量如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>lock</code> : 我们都知道 <code>DelayQueue</code> 存取是线程安全的，所以为了保证存取元素时线程安全，我们就需要在存取时上锁，而 <code>DelayQueue</code> 就是基于 <code>ReentrantLock</code> 独占锁确保存取操作的线程安全。</li>\n<li><code>q</code> : 延迟队列要求元素按照到期时间进行升序排列，所以元素添加时势必需要进行优先级排序,所以 <code>DelayQueue</code> 底层元素的存取都是通过这个优先队列 <code>PriorityQueue</code> 的成员变量 <code>q</code> 来管理的。</li>\n<li><code>leader</code> : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,设计者就用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。</li>\n<li><code>available</code> : 上文讲述 <code>leader</code> 线程时提到的等待唤醒操作的交互就是通过 <code>available</code> 实现的，假如线程 1 尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就会将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</li>\n</ul>\n<h3> 构造方法</h3>\n<p>相较于其他的并发容器，延迟队列的构造方法比较简单，它只有两个构造方法，因为所有成员变量在类加载时都已经初始完成了，所以默认构造方法什么也没做。还有一个传入 <code>Collection</code> 对象的构造方法，它会将调用 <code>addAll()</code>方法将集合元素存到优先队列 <code>q</code> 中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 添加元素</h3>\n<p><code>DelayQueue</code> 添加元素的方法无论是 <code>add</code>、<code>put</code> 还是 <code>offer</code>,本质上就是调用一下 <code>offer</code> ,所以了解延迟队列的添加逻辑我们只需阅读 offer 方法即可。</p>\n<p><code>offer</code> 方法的整体逻辑为:</p>\n<ol>\n<li>尝试获取 <code>lock</code> 。</li>\n<li>如果上锁成功,则调 <code>q</code> 的 <code>offer</code> 方法将元素存放到优先队列中。</li>\n<li>调用 <code>peek</code> 方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)，于是将 <code>leader</code> 设置为空,通知因为队列为空时调用 <code>take</code> 等方法导致阻塞的线程来争抢元素。</li>\n<li>上述步骤执行完成，释放 <code>lock</code>。</li>\n<li>返回 true。</li>\n</ol>\n<p>源码如下，笔者已详细注释，读者可自行参阅:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取元素</h3>\n<p><code>DelayQueue</code> 中获取元素的方式分为阻塞式和非阻塞式，先来看看逻辑比较复杂的阻塞式获取元素方法 <code>take</code>,为了让读者可以更直观的了解阻塞式获取元素的全流程，笔者将以 3 个线程并发获取元素为例讲述 <code>take</code> 的工作流程。</p>\n<blockquote>\n<p>想要理解下面的内容，需要用到 AQS 相关的知识，推荐阅读下面这两篇文章：</p>\n<ul>\n<li><a href=\"https://xie.infoq.cn/article/5a3cc0b709012d40cb9f41986\" target=\"_blank\" rel=\"noopener noreferrer\">图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)</a></li>\n<li><a href=\"https://xie.infoq.cn/article/0223d5e5f19726b36b084b10d\" target=\"_blank\" rel=\"noopener noreferrer\">AQS 都看完了，Condition 原理可不能少！</a></li>\n</ul>\n</blockquote>\n<p>1、首先， 3 个线程会尝试获取可重入锁 <code>lock</code>,假设我们现在有 3 个线程分别是 t1、t2、t3,随后 t1 得到了锁，而 t2、t3 没有抢到锁，故将这两个线程存入等待队列中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-0.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>2、紧接着 t1 开始进行元素获取的逻辑。</p>\n<p>3、线程 t1 首先会查看 <code>DelayQueue</code> 队列首元素是否为空。</p>\n<p>4、如果元素为空，则说明当前队列没有任何元素，故 t1 就会被阻塞存到 <code>conditionWaiter</code> 这个队列中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>注意，调用 <code>await</code> 之后 t1 就会释放 <code>lcok</code> 锁，假如 <code>DelayQueue</code> 持续为空，那么 t2、t3 也会像 t1 一样执行相同的逻辑并进入 <code>conditionWaiter</code> 队列中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-2.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果元素不为空，则判断当前任务是否到期，如果元素到期，则直接返回出去。如果元素未到期，则判断当前 <code>leader</code> 线程(<code>DelayQueue</code> 中唯一一个可以等待并获取元素的线程引用)是否为空，若不为空，则说明当前 <code>leader</code> 正在等待执行一个优先级比当前元素还高的元素到期，故当前线程 t1 只能调用 <code>await</code> 进入无限期等待，等到 <code>leader</code> 取得元素后唤醒。反之，若 <code>leader</code> 线程为空，则将当前线程设置为 leader 并进入有限期等待,到期后取出元素并返回。</p>\n<p>自此我们阻塞式获取元素的逻辑都已完成后,源码如下，读者可自行参阅:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们再来看看非阻塞的获取元素方法 <code>poll</code> ，逻辑比较简单，整体步骤如下:</p>\n<ol>\n<li>尝试获取可重入锁。</li>\n<li>查看队列第一个元素,判断元素是否为空。</li>\n<li>若元素为空，或者元素未到期，则直接返回空。</li>\n<li>若元素不为空且到期了，直接调用 <code>poll</code> 返回出去。</li>\n<li>释放可重入锁 <code>lock</code> 。</li>\n</ol>\n<p>源码如下,读者可自行参阅源码及注释:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查看元素</h3>\n<p>上文获取元素时都会调用到 <code>peek</code> 方法，peek 顾名思义仅仅窥探一下队列中的元素，它的步骤就 4 步:</p>\n<ol>\n<li>上锁。</li>\n<li>调用优先队列 q 的 peek 方法查看索引 0 位置的元素。</li>\n<li>释放锁。</li>\n<li>将元素返回出去。</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> DelayQueue 常见面试题</h2>\n<h3> DelayQueue 的实现原理是什么？</h3>\n<p><code>DelayQueue</code> 底层是使用优先队列 <code>PriorityQueue</code> 来存储元素，而 <code>PriorityQueue</code> 采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得 <code>DelayQueue</code> 对于延迟任务优先级的管理就变得十分方便了。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，<code>DelayQueue</code> 还用到了 <code>Condition</code>，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>\n<h3> DelayQueue 的实现是否线程安全？</h3>\n<p><code>DelayQueue</code> 的实现是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>\n<h3> DelayQueue 的使用场景有哪些？</h3>\n<p><code>DelayQueue</code> 通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的 key 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。</p>\n<h3> DelayQueue 中 Delayed 接口的作用是什么？</h3>\n<p><code>Delayed</code> 接口定义了元素的剩余延迟时间(<code>getDelay</code>)和元素之间的比较规则(该接口继承了 <code>Comparable</code> 接口)。若希望元素能够存放到 <code>DelayQueue</code> 中，就必须实现 <code>Delayed</code> 接口的 <code>getDelay()</code> 方法和 <code>compareTo()</code> 方法，否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>\n<h3> DelayQueue 和 Timer/TimerTask 的区别是什么？</h3>\n<p><code>DelayQueue</code> 和 <code>Timer/TimerTask</code> 都可以用于实现定时任务调度，但是它们的实现方式不同。<code>DelayQueue</code> 是基于优先级队列和堆排序算法实现的，可以实现多个任务按照时间先后顺序执行；而 <code>Timer/TimerTask</code> 是基于单线程实现的，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。另外，<code>DelayQueue</code> 还支持动态添加和移除任务，而 <code>Timer/TimerTask</code> 只能在创建时指定任务。</p>\n<h2> 参考文献</h2>\n<ul>\n<li>《深入理解高并发编程：JDK 核心技术》:</li>\n<li>一口气说出 Java 6 种延时队列的实现方法(面试官也得服):<a href=\"https://www.jb51.net/article/186192.htm\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jb51.net/article/186192.htm</a></li>\n<li>图解 DelayQueue 源码（java 8）——延时队列的小九九: <a href=\"https://blog.csdn.net/every__day/article/details/113810985\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/every__day/article/details/113810985</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png",
      "date_published": "2023-06-30T11:46:59.000Z",
      "date_modified": "2023-12-21T06:15:20.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "PriorityQueue 源码分析（付费）",
      "url": "https://javaguide.cn/java/collection/priorityqueue-source-code.html",
      "id": "https://javaguide.cn/java/collection/priorityqueue-source-code.html",
      "summary": "PriorityQueue 源码分析 为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 必读源码系列》中。",
      "content_html": "<p><strong>PriorityQueue 源码分析</strong> 为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/source-code-reading.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 必读源码系列》</a>中。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20230727084055593.png\" alt=\"PriorityQueue 源码分析\" tabindex=\"0\"><figcaption>PriorityQueue 源码分析</figcaption></figure>\n<p><a href=\"/zhuanlan/source-code-reading.html\" target=\"blank\">《Java 必读源码系列》</a>（点击链接即可查看详细介绍）的部分内容展示如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220621091832348.png\" alt=\"《Java 必读源码系列》\" tabindex=\"0\"><figcaption>《Java 必读源码系列》</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/xingqiu/image-20230727084055593.png",
      "date_published": "2023-06-30T11:46:59.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "常见加密算法总结",
      "url": "https://javaguide.cn/system-design/security/encryption-algorithms.html",
      "id": "https://javaguide.cn/system-design/security/encryption-algorithms.html",
      "summary": "加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。 日常开发中常见的需要用到的加密算法的场景： 保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。 保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。 网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。 ……",
      "content_html": "<p>加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。</p>\n<p>日常开发中常见的需要用到的加密算法的场景：</p>\n<ol>\n<li>保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。</li>\n<li>保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。</li>\n<li>网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。</li>\n<li>……</li>\n</ol>\n<h2> 哈希算法</h2>\n<p>哈希算法也叫哈希函数、散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/hash-function-effect-demonstration.png\" alt=\"哈希算法效果演示\" tabindex=\"0\"><figcaption>哈希算法效果演示</figcaption></figure>\n<p>哈希值的作用是可以用来验证数据的完整性和一致性。</p>\n<p>举两个实际的例子：</p>\n<ul>\n<li>我们下载一个文件时，可以通过比较文件的哈希值和官方提供的哈希值是否一致，来判断文件是否被篡改或损坏；</li>\n<li>保存密码到数据库时使用哈希算法进行加密，可以通过比较用户输入密码的哈希值和数据库保存的哈希值是否一致，来判断密码是否正确。</li>\n</ul>\n<p>这种算法的特点是不可逆：</p>\n<ul>\n<li>不能从哈希值还原出原始数据。</li>\n<li>原始数据的任何改变都会导致哈希值的巨大变化。</li>\n</ul>\n<p>哈希算法主要下面几类：</p>\n<ul>\n<li>MD（Message Digest，消息摘要算法）：比如 MD5。</li>\n<li>SHA（Secure Hash Algorithm，安全哈希算法）：比如 SHA-1、SHA-256。</li>\n<li>MAC（Message Authentication Code，消息认证码算法）：比如 HMAC(Hash Message Authentication Code)。</li>\n<li>其他：国密算法（SM3）、密码哈希算法（Bcrypt）。</li>\n<li>……</li>\n</ul>\n<p>国密算法常见的如 SM2、SM3、SM4，其中 SM2 为非对称加密算法，SM4 为对称加密算法，SM3 为哈希算法（安全性及效率和 SHA-256 相当，但更适合国内的应用环境）。</p>\n<p>哈希算法一般是不需要密钥的，但也存在部分特殊哈希算法需要密钥。例如，MAC 算法就是一种基于密钥的哈希算法，它在哈希算法的基础上增加了一个密钥，使得只有知道密钥的人才能验证数据的完整性和来源。</p>\n<h3> MD</h3>\n<p>MD 算法有多个版本，包括 MD2、MD4、MD5 等，其中 MD5 是最常用的版本，它可以生成一个 128 位（16 字节）的哈希值。从安全性上说：MD5 &gt; MD4 &gt; MD2。除了这些版本，还有一些基于 MD4 或 MD5 改进的算法，如 RIPEMD、HAVAL 等。</p>\n<p>即使是最安全 MD 算法 MD5 也存在被破解的风险，攻击者可以通过暴力破解或彩虹表攻击等方式，找到与原始数据相同的哈希值，从而破解数据。</p>\n<p>为了增加破解难度，通常可以选择加盐。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。</p>\n<p>加盐之后就安全了吗？并不一定，这只是增加了破解难度，不代表无法破解。而且，MD5 算法本身就存在弱碰撞（Collision）问题，即多个不同的输入产生相同的 MD5 值。</p>\n<p>因此，MD 算法已经不被推荐使用，建议使用更安全的哈希算法比如 SHA-2、Bcrypt。</p>\n<p>Java 提供了对 MD 算法系列的支持，包括 MD2、MD5。</p>\n<p>MD5 代码示例（未加盐）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> SHA</h3>\n<p>SHA（Secure Hash Algorithm）系列算法是一组密码哈希函数，用于将任意长度的数据映射为固定长度的哈希值。SHA 系列算法由美国国家安全局（NSA）于 1993 年设计，目前共有 SHA-1、SHA-2、SHA-3 三种版本。</p>\n<p>SHA-1 算法将任意长度的数据映射为 160 位的哈希值。然而，SHA-1 算法存在一些严重的缺陷，比如安全性低，容易受到碰撞攻击和长度扩展攻击。因此，SHA-1 算法已经不再被推荐使用。 SHA-2 家族（如 SHA-256、SHA-384、SHA-512 等）和 SHA-3 系列是 SHA-1 算法的替代方案，它们都提供了更高的安全性和更长的哈希值长度。</p>\n<p>SHA-2 家族是在 SHA-1 算法的基础上改进而来的，它们采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。</p>\n<p>为了寻找一种更安全和更先进的密码哈希函数，美国国家标准与技术研究院（National Institute of Standards and Technology，简称 NIST）在 2007 年公开征集 SHA-3 的候选算法。NIST 一共收到了 64 个算法方案，经过多轮的评估和筛选，最终在 2012 年宣布 Keccak 算法胜出，成为 SHA-3 的标准算法（SHA-3 与 SHA-2 算法没有直接的关系）。 Keccak 算法具有与 MD 和 SHA-1/2 完全不同的设计思路，即海绵结构（Sponge Construction），使得传统攻击方法无法直接应用于 SHA-3 的攻击中（能够抵抗目前已知的所有攻击方式包括碰撞攻击、长度扩展攻击、差分攻击等）。</p>\n<p>由于 SHA-2 算法还没有出现重大的安全漏洞，而且在软件中的效率更高，所以大多数人还是倾向于使用 SHA-2 算法。</p>\n<p>相比 MD5 算法，SHA-2 算法之所以更强，主要有两个原因：</p>\n<ul>\n<li>哈希值长度更长：例如 SHA-256 算法的哈希值长度为 256 位，而 MD5 算法的哈希值长度为 128 位，这就提高了攻击者暴力破解或者彩虹表攻击的难度。</li>\n<li>更强的碰撞抗性：SHA 算法采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。目前还没有找到任何两个不同的数据，它们的 SHA-256 哈希值相同。</li>\n</ul>\n<p>当然，SHA-2 也不是绝对安全的，也有被暴力破解或者彩虹表攻击的风险，所以，在实际的应用中，加盐还是必不可少的。</p>\n<p>Java 提供了对 SHA 算法系列的支持，包括 SHA-1、SHA-256、SHA-384 和 SHA-512。</p>\n<p>SHA-256 代码示例（未加盐）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Bcrypt</h3>\n<p>Bcrypt 算法是一种基于 Blowfish 加密算法的密码哈希函数，专门为密码加密而设计，安全性高。</p>\n<p>由于 Bcrypt 采用了 salt（盐） 和 cost（成本） 两种机制，它可以有效地防止彩虹表攻击和暴力破解攻击，从而保证密码的安全性。salt 是一个随机生成的字符串，用于和密码混合，增加密码的复杂度和唯一性。cost 是一个数值参数，用于控制 Bcrypt 算法的迭代次数，增加密码哈希的计算时间和资源消耗。</p>\n<p>Bcrypt 算法可以根据实际情况进行调整加密的复杂度，可以设置不同的 cost 值和 salt 值，从而满足不同的安全需求，灵活性很高。</p>\n<p>Java 应用程序的安全框架 Spring Security 支持多种密码编码器，其中 <code>BCryptPasswordEncoder</code> 是官方推荐的一种，它使用 BCrypt 算法对用户的密码进行加密存储。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 对称加密</h2>\n<p>对称加密算法是指加密和解密使用同一个密钥的算法，也叫共享密钥加密算法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/symmetric-encryption.png\" alt=\"对称加密\" tabindex=\"0\"><figcaption>对称加密</figcaption></figure>\n<p>常见的对称加密算法有 DES、3DES、AES 等。</p>\n<h3> DES 和 3DES</h3>\n<p>DES（Data Encryption Standard）使用 64 位的密钥(有效秘钥长度为 56 位,8 位奇偶校验位)和 64 位的明文进行加密。</p>\n<p>虽然 DES 一次只能加密 64 位，但我们只需要把明文划分成 64 位一组的块，就可以实现任意长度明文的加密。如果明文长度不是 64 位的倍数，必须进行填充，常用的模式有 PKCS5Padding, PKCS7Padding, NOPADDING。</p>\n<p>DES 加密算法的基本思想是将 64 位的明文分成两半，然后对每一半进行多轮的变换，最后再合并成 64 位的密文。这些变换包括置换、异或、选择、移位等操作，每一轮都使用了一个子密钥，而这些子密钥都是由同一个 56 位的主密钥生成的。DES 加密算法总共进行了 16 轮变换，最后再进行一次逆置换，得到最终的密文。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/des-steps.jpg\" alt=\"DES（Data Encryption Standard）\" tabindex=\"0\"><figcaption>DES（Data Encryption Standard）</figcaption></figure>\n<p>这是一个经典的对称加密算法，但也有明显的缺陷，即 56 位的密钥安全性不足，已被证实可以在短时间内破解。</p>\n<p>为了提高 DES 算法的安全性，人们提出了一些变种或者替代方案，例如 3DES（Triple DES）。</p>\n<p>3DES（Triple DES）是 DES 向 AES 过渡的加密算法，它使用 2 个或者 3 个 56 位的密钥对数据进行三次加密。3DES 相当于是对每个数据块应用三次 DES 的对称加密算法。</p>\n<p>为了兼容普通的 DES，3DES 并没有直接使用 加密-&gt;加密-&gt;加密 的方式，而是采用了加密-&gt;解密-&gt;加密 的方式。当三种密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通 DES 加密算法的兼容。3DES 比 DES 更为安全，但其处理速度不高。</p>\n<h3> AES</h3>\n<p>AES（Advanced Encryption Standard）算法是一种更先进的对称密钥加密算法，它使用 128 位、192 位或 256 位的密钥对数据进行加密或解密，密钥越长，安全性越高。</p>\n<p>AES 也是一种分组(或者叫块)密码，分组长度只能是 128 位，也就是说，每个分组为 16 个字节。AES 加密算法有多种工作模式（mode of operation），如：ECB、CBC、OFB、CFB、CTR、XTS、OCB、GCM（目前使用最广泛的模式）。不同的模式参数和加密流程不同，但是核心仍然是 AES 算法。</p>\n<p>和 DES 类似，对于不是 128 位倍数的明文需要进行填充，常用的填充模式有 PKCS5Padding, PKCS7Padding, NOPADDING。不过，AES-GCM 是流加密算法，可以对任意长度的明文进行加密，所以对应的填充模式为 NoPadding，即无需填充。</p>\n<p>AES 的速度比 3DES 快，而且更安全。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/aes-steps.jpg\" alt=\"AES（Advanced Encryption Standard）\" tabindex=\"0\"><figcaption>AES（Advanced Encryption Standard）</figcaption></figure>\n<p>DES 算法和 AES 算法简单对比（图片来自于：<a href=\"https://cheapsslweb.com/blog/rsa-vs-aes-encryption\" target=\"_blank\" rel=\"noopener noreferrer\">RSA vs. AES Encryption: Key Differences Explained</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/des-vs-aes.png\" alt=\"DES 和 AES 对比\" tabindex=\"0\"><figcaption>DES 和 AES 对比</figcaption></figure>\n<p>基于 Java 实现 AES 算法代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 非对称加密</h2>\n<p>非对称加密算法是指加密和解密使用不同的密钥的算法，也叫公开密钥加密算法。这两个密钥互不相同，一个称为公钥，另一个称为私钥。公钥可以公开给任何人使用，私钥则要保密。</p>\n<p>如果用公钥加密数据，只能用对应的私钥解密（加密）；如果用私钥加密数据，只能用对应的公钥解密（签名）。这样就可以实现数据的安全传输和身份认证。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/asymmetric-encryption.png\" alt=\"非对称加密\" tabindex=\"0\"><figcaption>非对称加密</figcaption></figure>\n<p>常见的非对称加密算法有 RSA、DSA、ECC 等。</p>\n<h3> RSA</h3>\n<p>RSA（Rivest–Shamir–Adleman algorithm）算法是一种基于大数分解的困难性的非对称加密算法，它需要选择两个大素数作为私钥的一部分，然后计算出它们的乘积作为公钥的一部分（寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难）。RSA 算法原理的详细介绍，可以参考这篇文章：<a href=\"https://www.cnblogs.com/xiaofuge/p/16954187.html\" target=\"_blank\" rel=\"noopener noreferrer\">你真的了解 RSA 加密算法吗？ - 小傅哥</a>。</p>\n<p>RSA 算法的安全性依赖于大数分解的难度，目前已经有 512 位和 768 位的 RSA 公钥被成功分解，因此建议使用 2048 位或以上的密钥长度。</p>\n<p>RSA 算法的优点是简单易用，可以用于数据加密和数字签名；缺点是运算速度慢，不适合大量数据的加密。</p>\n<p>RSA 算法是是目前应用最广泛的非对称加密算法，像 SSL/TLS、SSH 等协议中就用到了 RSA 算法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/https-rsa-sha-256.png\" alt=\"HTTPS 证书签名算法中带RSA 加密的SHA-256 \" tabindex=\"0\"><figcaption>HTTPS 证书签名算法中带RSA 加密的SHA-256 </figcaption></figure>\n<p>基于 Java 实现 RSA 算法代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> DSA</h3>\n<p>DSA（Digital Signature Algorithm）算法是一种基于离散对数的困难性的非对称加密算法，它需要选择一个素数 q 和一个 q 的倍数 p 作为私钥的一部分，然后计算出一个模 p 的原根 g 和一个模 q 的整数 y 作为公钥的一部分。DSA 算法的安全性依赖于离散对数的难度，目前已经有 1024 位的 DSA 公钥被成功破解，因此建议使用 2048 位或以上的密钥长度。</p>\n<p>DSA 算法的优点是数字签名速度快，适合生成数字证书；缺点是不能用于数据加密，且签名过程需要随机数。</p>\n<p>DSA 算法签名过程：</p>\n<ol>\n<li>使用消息摘要算法对要发送的数据进行加密，生成一个信息摘要，也就是一个短的、唯一的、不可逆的数据表示。</li>\n<li>发送方用自己的 DSA 私钥对信息摘要再进行加密，形成一个数字签名，也就是一个可以证明数据来源和完整性的数据附加。</li>\n<li>将原始数据和数字签名一起通过互联网传送给接收方。</li>\n<li>接收方用发送方的公钥对数字签名进行解密，得到信息摘要。同时，接收方也用消息摘要算法对收到的原始数据进行加密，得到另一个信息摘要。接收方将两个信息摘要进行比较，如果两者一致，则说明在传送过程中数据没有被篡改或损坏；否则，则说明数据已经失去了安全性和保密性。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/dsa-algorithm-signing-process.png\" alt=\"DSA 算法签名过程\" tabindex=\"0\"><figcaption>DSA 算法签名过程</figcaption></figure>\n<h2> 总结</h2>\n<p>这篇文章介绍了三种加密算法：哈希算法、对称加密算法和非对称加密算法。</p>\n<ul>\n<li>哈希算法是一种用数学方法对数据生成一个固定长度的唯一标识的技术，可以用来验证数据的完整性和一致性，常见的哈希算法有 MD、SHA、MAC 等。</li>\n<li>对称加密算法是一种加密和解密使用同一个密钥的算法，可以用来保护数据的安全性和保密性，常见的对称加密算法有 DES、3DES、AES 等。</li>\n<li>非对称加密算法是一种加密和解密使用不同的密钥的算法，可以用来实现数据的安全传输和身份认证，常见的非对称加密算法有 RSA、DSA、ECC 等。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>奇妙的安全旅行之 DSA 算法：<a href=\"https://zhuanlan.zhihu.com/p/347025157\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/347025157</a></li>\n<li>AES-GCM 加密简介：<a href=\"https://juejin.cn/post/6844904122676690951\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904122676690951</a></li>\n<li>Java AES 256 GCM Encryption and Decryption Example | JCE Unlimited Strength：<a href=\"https://www.javainterviewpoint.com/java-aes-256-gcm-encryption-and-decryption/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.javainterviewpoint.com/java-aes-256-gcm-encryption-and-decryption/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/hash-function-effect-demonstration.png",
      "date_published": "2023-06-27T12:05:39.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Java NIO 核心知识总结",
      "url": "https://javaguide.cn/java/io/nio-basis.html",
      "id": "https://javaguide.cn/java/io/nio-basis.html",
      "summary": "在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：Java IO 模型详解。 NIO 简介 在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。",
      "content_html": "<p>在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：<a href=\"https://javaguide.cn/java/io/io-model.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java IO 模型详解</a>。</p>\n<h2> NIO 简介</h2>\n<p>在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>\n<p>为了解决这个问题，在 Java1.4 版本引入了一种新的 I/O 模型 — <strong>NIO</strong> （New IO，也称为 Non-blocking IO） 。NIO 弥补了同步阻塞 I/O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I/O，可以使用少量的线程来处理多个连接，大大提高了 I/O 效率和并发。</p>\n<p>下图是 BIO、NIO 和 AIO 处理客户端请求的简单对比图（关于 AIO 的介绍，可以看我写的这篇文章：<a href=\"https://javaguide.cn/java/io/io-model.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java IO 模型详解</a>，不是重点，了解即可）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png\" alt=\"BIO、NIO 和 AIO 对比\" tabindex=\"0\"><figcaption>BIO、NIO 和 AIO 对比</figcaption></figure>\n<p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p>\n<h2> NIO 核心组件</h2>\n<p>NIO 主要包括以下三个核心组件：</p>\n<ul>\n<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>\n<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>\n<li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>\n</ul>\n<p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png\" alt=\"Buffer、Channel和Selector三者之间的关系\" tabindex=\"0\"><figcaption>Buffer、Channel和Selector三者之间的关系</figcaption></figure>\n<p>下面详细介绍一下这三个组件。</p>\n<h3> Buffer（缓冲区）</h3>\n<p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p>\n<p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p>\n<p><code>Buffer</code> 的子类如下图所示。其中，最常用的是 <code>ByteBuffer</code>，它可以用来存储和操作字节数据。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/buffer-subclasses.png\" alt=\"Buffer 的子类\" tabindex=\"0\"><figcaption>Buffer 的子类</figcaption></figure>\n<p>你可以将 Buffer 理解为一个数组，<code>IntBuffer</code>、<code>FloatBuffer</code>、<code>CharBuffer</code> 等分别对应 <code>int[]</code>、<code>float[]</code>、<code>char[]</code> 等。</p>\n<p>为了更清晰地认识缓冲区，我们来简单看看<code>Buffer</code> 类中定义的四个成员变量：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这四个成员变量的具体含义如下：</p>\n<ol>\n<li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li>\n<li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读/写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li>\n<li>位置（<code>position</code>）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li>\n<li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>\n</ol>\n<p>并且，上述变量满足如下的关系：<strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong> 。</p>\n<p>另外，Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/JavaNIOBuffer.png\" alt=\"position 、limit 和 capacity 之前的关系\" tabindex=\"0\"><figcaption>position 、limit 和 capacity 之前的关系</figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png\" alt=\"position 、limit 和 capacity 之前的关系\" tabindex=\"0\"><figcaption>position 、limit 和 capacity 之前的关系</figcaption></figure>\n<p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code>Buffer</code>。</p>\n<p>这里以 <code>ByteBuffer</code>为例进行介绍：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Buffer 最核心的两个方法：</p>\n<ol>\n<li><code>get</code> : 读取缓冲区的数据</li>\n<li><code>put</code> ：向缓冲区写入数据</li>\n</ol>\n<p>除上述两个方法之外，其他的重要方法：</p>\n<ul>\n<li><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li>\n<li><code>clear</code>: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li>\n<li>……</li>\n</ul>\n<p>Buffer 中数据变化的过程：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了帮助理解，我绘制了一张图片展示 <code>capacity</code>、<code>limit</code>和<code>position</code>每一阶段的变化。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributesDataChanges.png\" alt=\"capacity、limit和position每一阶段的变化\" tabindex=\"0\"><figcaption>capacity、limit和position每一阶段的变化</figcaption></figure>\n<h3> Channel（通道）</h3>\n<p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p>\n<p>BIO 中的流是单向的，分为各种 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</p>\n<p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer.png\" alt=\"Channel 和 Buffer之间的关系\" tabindex=\"0\"><figcaption>Channel 和 Buffer之间的关系</figcaption></figure>\n<p>另外，因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p>\n<p><code>Channel</code> 的子类如下图所示。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/channel-subclasses.png\" alt=\"Channel 的子类\" tabindex=\"0\"><figcaption>Channel 的子类</figcaption></figure>\n<p>其中，最常用的是以下几种类型的通道：</p>\n<ul>\n<li><code>FileChannel</code>：文件访问通道；</li>\n<li><code>SocketChannel</code>、<code>ServerSocketChannel</code>：TCP 通信通道；</li>\n<li><code>DatagramChannel</code>：UDP 通信通道；</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/channel-inheritance-relationship.png\" alt=\"Channel继承关系图\" tabindex=\"0\"><figcaption>Channel继承关系图</figcaption></figure>\n<p>Channel 最核心的两个方法：</p>\n<ol>\n<li><code>read</code> ：读取数据并写入到 Buffer 中。</li>\n<li><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</li>\n</ol>\n<p>这里我们以 <code>FileChannel</code> 为例演示一下是读取文件数据的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Selector（选择器）</h3>\n<p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I/O 操作。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/selector-channel-selectionkey.png\" alt=\"Selector 选择器工作示意图\" tabindex=\"0\"><figcaption>Selector 选择器工作示意图</figcaption></figure>\n<p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p>\n<p>Selector 可以监听以下四种事件类型：</p>\n<ol>\n<li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li>\n<li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li>\n<li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li>\n<li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li>\n</ol>\n<p><code>Selector</code>是抽象类，可以通过调用此类的 <code>open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p>\n<p>一个 Selector 实例有三个 <code>SelectionKey</code> 集合：</p>\n<ol>\n<li>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</li>\n<li>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li>\n<li>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li>\n</ol>\n<p>简单演示一下如何遍历被选择的 <code>SelectionKey</code> 集合并进行处理：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Selector 还提供了一系列和 <code>select()</code> 相关的方法：</p>\n<ul>\n<li><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，该方法返回，并将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</li>\n<li><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</li>\n<li><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，该方法不会阻塞线程。</li>\n<li><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</li>\n<li>……</li>\n</ul>\n<p>使用 Selector 实现网络读写的简单示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 \"Hello, Client!\"。</p>\n<h2> NIO 零拷贝</h2>\n<p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p>\n<p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p>\n<p>下图展示了各种零拷贝技术的对比图：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>CPU 拷贝</th>\n<th>DMA 拷贝</th>\n<th>系统调用</th>\n<th>上下文切换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传统方法</td>\n<td>2</td>\n<td>2</td>\n<td>read+write</td>\n<td>4</td>\n</tr>\n<tr>\n<td>mmap+write</td>\n<td>1</td>\n<td>2</td>\n<td>mmap+write</td>\n<td>4</td>\n</tr>\n<tr>\n<td>sendfile</td>\n<td>1</td>\n<td>2</td>\n<td>sendfile</td>\n<td>2</td>\n</tr>\n<tr>\n<td>sendfile + DMA gather copy</td>\n<td>0</td>\n<td>2</td>\n<td>sendfile</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p>\n<p>Java 对零拷贝的支持：</p>\n<ul>\n<li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li>\n<li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。关于<code>FileChannel</code>的用法可以看看这篇文章：<a href=\"https://www.cnblogs.com/robothy/p/14235598.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java NIO 文件通道 FileChannel 用法</a>。</li>\n</ul>\n<p>代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 总结</h2>\n<p>这篇文章我们主要介绍了 NIO 的核心知识点，包括 NIO 的核心组件和零拷贝。</p>\n<p>如果我们需要使用 NIO 构建网络程序的话，不建议直接使用原生 NIO，编程复杂且功能性太弱，推荐使用一些成熟的基于 NIO 的网络编程框架比如 Netty。Netty 在 NIO 的基础上进行了一些优化和扩展比如支持多种协议、支持 SSL/TLS 等等。</p>\n<h2> 参考</h2>\n<ul>\n<li>\n<p>Java NIO 浅析：<a href=\"https://tech.meituan.com/2016/11/04/nio.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.meituan.com/2016/11/04/nio.html</a></p>\n</li>\n<li>\n<p>面试官：Java NIO 了解？<a href=\"https://mp.weixin.qq.com/s/mZobf-U8OSYQfHfYBEB6KA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/mZobf-U8OSYQfHfYBEB6KA</a></p>\n</li>\n<li>\n<p>Java NIO：Buffer、Channel 和 Selector：<a href=\"https://www.javadoop.com/post/java-nio\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.javadoop.com/post/java-nio</a></p>\n</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png",
      "date_published": "2023-06-26T15:16:09.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "ArrayBlockingQueue 源码分析",
      "url": "https://javaguide.cn/java/collection/arrayblockingqueue-source-code.html",
      "id": "https://javaguide.cn/java/collection/arrayblockingqueue-source-code.html",
      "summary": "阻塞队列简介 阻塞队列的历史 Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 java.util.concurrent，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。 为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 ArrayBlockingQueue 和 LinkedBlockingQueue，它们是带有生产者-消费者模式实现的并发容器。其中，ArrayBlockingQueue 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 LinkedBlockingQueue 则由链表构成的队列，正是因为链表的特性，所以 LinkedBlockingQueue 在添加元素上并不会向 ArrayBlockingQueue 那样有着较多的约束，所以 LinkedBlockingQueue 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 Integer.MAX_VALUE，近乎于无限大)。",
      "content_html": "<h2> 阻塞队列简介</h2>\n<h3> 阻塞队列的历史</h3>\n<p>Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 <code>java.util.concurrent</code>，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。</p>\n<p>为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>，它们是带有生产者-消费者模式实现的并发容器。其中，<code>ArrayBlockingQueue</code> 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 <code>LinkedBlockingQueue</code> 则由链表构成的队列，正是因为链表的特性，所以 <code>LinkedBlockingQueue</code> 在添加元素上并不会向 <code>ArrayBlockingQueue</code> 那样有着较多的约束，所以 <code>LinkedBlockingQueue</code> 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 <code>Integer.MAX_VALUE</code>，近乎于无限大)。</p>\n<p>随着 Java 的不断发展，JDK 后续的几个版本又对阻塞队列进行了不少的更新和完善:</p>\n<ol>\n<li>JDK1.6 版本:增加 <code>SynchronousQueue</code>，一个不存储元素的阻塞队列。</li>\n<li>JDK1.7 版本:增加 <code>TransferQueue</code>，一个支持更多操作的阻塞队列。</li>\n<li>JDK1.8 版本:增加 <code>DelayQueue</code>，一个支持延迟获取元素的阻塞队列。</li>\n</ol>\n<h3> 阻塞队列的思想</h3>\n<p>阻塞队列就是典型的生产者-消费者模型，它可以做到以下几点:</p>\n<ol>\n<li>当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。</li>\n<li>当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。</li>\n<li>当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。</li>\n<li>当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。</li>\n</ol>\n<p>总结一下：阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 <code>put</code>、<code>take</code>、<code>offfer</code>、<code>poll</code> 等 API 即可实现多线程之间的生产和消费。</p>\n<p>这也使得阻塞队列在多线程开发中有着广泛的运用，最常见的例子无非是我们的线程池,从源码中我们就能看出当核心线程无法及时处理任务时，这些任务都会扔到 <code>workQueue</code> 中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ArrayBlockingQueue 常见方法及测试</h2>\n<p>简单了解了阻塞队列的历史之后，我们就开始重点讨论本篇文章所要介绍的并发容器——<code>ArrayBlockingQueue</code>。为了后续更加深入的了解 <code>ArrayBlockingQueue</code>，我们不妨基于下面几个实例了解以下 <code>ArrayBlockingQueue</code> 的使用。</p>\n<p>先看看第一个例子，我们这里会用两个线程分别模拟生产者和消费者，生产者生产完会使用 <code>put</code> 方法生产 10 个元素给消费者进行消费，当队列元素达到我们设置的上限 5 时，<code>put</code> 方法就会阻塞。<br>\n同理消费者也会通过 <code>take</code> 方法消费元素，当队列为空时，<code>take</code> 方法就会阻塞消费者线程。这里笔者为了保证消费者能够在消费完 10 个元素后及时退出。便通过倒计时门闩，来控制消费者结束，生产者在这里只会生产 10 个元素。当消费者将 10 个元素消费完成之后，按下倒计时门闩，所有线程都会停止。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>代码输出结果如下，可以看到只有生产者往队列中投放元素之后消费者才能消费，这也就意味着当队列中没有数据的时消费者就会阻塞，等待队列非空再继续消费。</p>\n<div class=\"language-cpp line-numbers-mode\" data-ext=\"cpp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>了解了 <code>put</code>、<code>take</code> 这两个会阻塞的存和取方法之后，我我们再来看看阻塞队列中非阻塞的入队和出队方法 <code>offer</code> 和 <code>poll</code>。</p>\n<p>如下所示，我们设置了一个大小为 3 的阻塞队列，我们会尝试在队列用 offer 方法存放 4 个元素，然后再从队列中用 <code>poll</code> 尝试取 4 次。</p>\n<div class=\"language-cpp line-numbers-mode\" data-ext=\"cpp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最终代码的输出结果如下，可以看到因为队列的大小为 3 的缘故，我们前 3 次存放到队列的结果为 true，第 4 次存放时，由于队列已满，所以存放结果返回 false。这也是为什么我们后续的 <code>poll</code> 方法只得到了 3 个元素的值。</p>\n<div class=\"language-cpp line-numbers-mode\" data-ext=\"cpp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>了解了阻塞存取和非阻塞存取，我们再来看看阻塞队列的一个比较特殊的操作，某些场景下，我们希望能够一次性将阻塞队列的结果存到列表中再进行批量操作，我们就可以使用阻塞队列的 <code>drainTo</code> 方法，这个方法会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，反之若队列为空，<code>drainTo</code> 则直接返回 0。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>代码输出结果如下</p>\n<div class=\"language-cpp line-numbers-mode\" data-ext=\"cpp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> ArrayBlockingQueue 源码分析</h2>\n<p>自此我们对阻塞队列的使用有了基本的印象，接下来我们就可以进一步了解一下 <code>ArrayBlockingQueue</code> 的工作机制了。</p>\n<h3> 整体设计</h3>\n<p>在了解 <code>ArrayBlockingQueue</code> 的具体细节之前，我们先来看看 <code>ArrayBlockingQueue</code> 的类图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/arrayblockingqueue-class-diagram.png\" alt=\"ArrayBlockingQueue 类图\" tabindex=\"0\"><figcaption>ArrayBlockingQueue 类图</figcaption></figure>\n<p>从图中我们可以看出，<code>ArrayBlockingQueue</code> 继承了阻塞队列 <code>BlockingQueue</code> 这个接口，不难猜出通过继承 <code>BlockingQueue</code> 这个接口之后，<code>ArrayBlockingQueue</code> 就拥有了阻塞队列那些常见的操作行为。</p>\n<p>同时， <code>ArrayBlockingQueue</code> 还继承了 <code>AbstractQueue</code> 这个抽象类，这个继承了 <code>AbstractCollection</code> 和 <code>Queue</code> 的抽象类，从抽象类的特定和语义我们也可以猜出，这个继承关系使得 <code>ArrayBlockingQueue</code> 拥有了队列的常见操作。</p>\n<p>所以我们是否可以得出这样一个结论，通过继承 <code>AbstractQueue</code> 获得队列所有的操作模板，其实现的入队和出队操作的整体框架。然后 <code>ArrayBlockingQueue</code> 通过继承 <code>BlockingQueue</code> 获取到阻塞队列的常见操作并将这些操作实现，填充到 <code>AbstractQueue</code> 模板方法的细节中，由此 <code>ArrayBlockingQueue</code> 成为一个完整的阻塞队列。</p>\n<p>为了印证这一点，我们到源码中一探究竟。首先我们先来看看 <code>AbstractQueue</code>，从类的继承关系我们可以大致得出，它通过 <code>AbstractCollection</code> 获得了集合的常见操作方法，然后通过 <code>Queue</code> 接口获得了队列的特性。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于集合的操作无非是增删改查，所以我们不妨从添加方法入手，从源码中我们可以看到，它实现了 <code>AbstractCollection</code> 的 <code>add</code> 方法，其内部逻辑如下:</p>\n<ol>\n<li>调用继承 <code>Queue</code> 接口的来的 <code>offer</code> 方法，如果 <code>offer</code> 成功则返回 <code>true</code>。</li>\n<li>如果 <code>offer</code> 失败，即代表当前元素入队失败直接抛异常。</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而 <code>AbstractQueue</code> 中并没有对 <code>Queue</code> 的 <code>offer</code> 的实现，很明显这样做的目的是定义好了 <code>add</code> 的核心逻辑，将 <code>offer</code> 的细节交由其子类即我们的 <code>ArrayBlockingQueue</code> 实现。</p>\n<p>到此，我们对于抽象类 <code>AbstractQueue</code> 的分析就结束了，我们继续看看 <code>ArrayBlockingQueue</code> 中另一个重要的继承接口 <code>BlockingQueue</code>。</p>\n<p>点开 <code>BlockingQueue</code> 之后，我们可以看到这个接口同样继承了 <code>Queue</code> 接口，这就意味着它也具备了队列所拥有的所有行为。同时，它还定义了自己所需要实现的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>了解了 <code>BlockingQueue</code> 的常见操作后，我们就知道了 <code>ArrayBlockingQueue</code> 通过继承 <code>BlockingQueue</code> 的方法并实现后，填充到 <code>AbstractQueue</code> 的方法上，由此我们便知道了上文中 <code>AbstractQueue</code> 的 <code>add</code> 方法的 <code>offer</code> 方法是哪里是实现的了。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 初始化</h3>\n<p>了解 <code>ArrayBlockingQueue</code> 的细节前，我们不妨先看看其构造函数，了解一下其初始化过程。从源码中我们可以看出 <code>ArrayBlockingQueue</code> 有 3 个构造方法，而最核心的构造方法就是下方这一个。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个构造方法里面有两个比较核心的成员变量 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满） ，需要我们格外留意，它们是实现生产者和消费者有序工作的关键所在，这一点笔者会在后续的源码解析中详细说明，这里我们只需初步了解一下阻塞队列的构造即可。</p>\n<p>另外两个构造方法都是基于上述的构造方法，默认情况下，我们会使用下面这个构造方法，该构造方法就意味着 <code>ArrayBlockingQueue</code> 用的是非公平锁，即各个生产者或者消费者线程收到通知后，对于锁的争抢是随机的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还有一个不怎么常用的构造方法，在初始化容量和锁的非公平性之后，它还提供了一个 <code>Collection</code> 参数，从源码中不难看出这个构造方法是将外部传入的集合的元素在初始化时直接存放到阻塞队列中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 阻塞式获取和新增元素</h3>\n<p><code>ArrayBlockingQueue</code> 阻塞式获取和新增元素对应的就是生产者-消费者模型，虽然它也支持非阻塞式获取和新增元素（例如 <code>poll()</code> 和 <code>offer(E e)</code> 方法，后文会介绍到），但一般不会使用。</p>\n<p><code>ArrayBlockingQueue</code> 阻塞式获取和新增元素的方法为：</p>\n<ul>\n<li><code>put(E e)</code>：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。</li>\n<li><code>take()</code> ：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。</li>\n</ul>\n<p>这两个方法实现的关键就是在于两个条件对象 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满），这个我们在上文的构造方法中有提到。</p>\n<p>接下来笔者就通过两张图让大家了解一下这两个条件是如何在阻塞队列中运用的。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-take.png\" alt=\"ArrayBlockingQueue 非空条件\" tabindex=\"0\"><figcaption>ArrayBlockingQueue 非空条件</figcaption></figure>\n<p>假设我们的代码消费者先启动，当它发现队列中没有数据，那么非空条件就会将这个线程挂起，即等待条件非空时挂起。然后 CPU 执行权到达生产者，生产者发现队列中可以存放数据，于是将数据存放进去，通知此时条件非空，此时消费者就会被唤醒到队列中使用 <code>take</code> 等方法获取值了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notFull-put.png\" alt=\"ArrayBlockingQueue 非满条件\" tabindex=\"0\"><figcaption>ArrayBlockingQueue 非满条件</figcaption></figure>\n<p>随后的执行中，生产者生产速度远远大于消费者消费速度，于是生产者将队列塞满后再次尝试将数据存入队列，发现队列已满，于是阻塞队列就将当前线程挂起，等待非满。然后消费者拿着 CPU 执行权进行消费，于是队列可以存放新数据了，发出一个非满的通知，此时挂起的生产者就会等待 CPU 执行权到来时再次尝试将数据存到队列中。</p>\n<p>简单了解阻塞队列的基于两个条件的交互流程之后，我们不妨看看 <code>put</code> 和 <code>take</code> 方法的源码。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>put</code>方法内部调用了 <code>enqueue</code> 方法来实现元素入队，我们继续深入查看一下 <code>enqueue</code> 方法的实现细节：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码中可以看到入队操作的逻辑就是在数组中追加一个新元素，整体执行步骤为:</p>\n<ol>\n<li>获取 <code>ArrayBlockingQueue</code> 底层的数组 <code>items</code>。</li>\n<li>将元素存到 <code>putIndex</code> 位置。</li>\n<li>更新 <code>putIndex</code> 到下一个位置，如果 <code>putIndex</code> 等于队列长度，则说明 <code>putIndex</code> 已经到达数组末尾了，下一次插入则需要 0 开始。(<code>ArrayBlockingQueue</code> 用到了循环队列的思想，即从头到尾循环复用一个数组)</li>\n<li>更新 <code>count</code> 的值，表示当前队列长度+1。</li>\n<li>调用 <code>notEmpty.signal()</code> 通知队列非空，消费者可以从队列中获取值了。</li>\n</ol>\n<p>自此我们了解了 <code>put</code> 方法的流程，为了更加完整的了解 <code>ArrayBlockingQueue</code> 关于生产者-消费者模型的设计，我们继续看看阻塞获取队列元素的 <code>take</code> 方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>理解了 <code>put</code> 方法再看<code>take</code> 方法就很简单了，其核心逻辑和<code>put</code> 方法正好是相反的，比如<code>put</code> 方法在队列满的时候等待队列非满时插入元素（非满条件），而<code>take</code> 方法等待队列非空时获取并移除元素（非空条件）。</p>\n<p><code>take</code>方法内部调用了 <code>dequeue</code> 方法来实现元素出队，其核心逻辑和 <code>enqueue</code> 方法也是相反的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于<code>dequeue</code> 方法（出队）和上面介绍的 <code>enqueue</code> 方法（入队）的步骤大致类似，这里就不重复介绍了。</p>\n<p>为了帮助理解，我专门画了一张图来展示 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满）这两个条件对象是如何控制 <code>ArrayBlockingQueue</code> 的存和取的。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-notFull.png\" alt=\"ArrayBlockingQueue 非空非满\" tabindex=\"0\"><figcaption>ArrayBlockingQueue 非空非满</figcaption></figure>\n<ul>\n<li><strong>消费者</strong>：当消费者从队列中 <code>take</code> 或者 <code>poll</code> 等操作取出一个元素之后，就会通知队列非满，此时那些等待非满的生产者就会被唤醒等待获取 CPU 时间片进行入队操作。</li>\n<li><strong>生产者</strong>：当生产者将元素存到队列中后，就会触发通知队列非空，此时消费者就会被唤醒等待 CPU 时间片尝试获取元素。如此往复，两个条件对象就构成一个环路，控制着多线程之间的存和取。</li>\n</ul>\n<h3> 非阻塞式获取和新增元素</h3>\n<p><code>ArrayBlockingQueue</code> 非阻塞式获取和新增元素的方法为：</p>\n<ul>\n<li><code>offer(E e)</code>：将元素插入队列尾部。如果队列已满，则该方法会直接返回 false，不会等待并阻塞线程。</li>\n<li><code>poll()</code>：获取并移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。</li>\n<li><code>add(E e)</code>：将元素插入队列尾部。如果队列已满则会抛出 <code>IllegalStateException</code> 异常，底层基于 <code>offer(E e)</code> 方法。</li>\n<li><code>remove()</code>：移除队列头部的元素，如果队列为空则会抛出 <code>NoSuchElementException</code> 异常，底层基于 <code>poll()</code>。</li>\n<li><code>peek()</code>：获取但不移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。</li>\n</ul>\n<p>先来看看 <code>offer</code> 方法，逻辑和 <code>put</code> 差不多，唯一的区别就是入队失败时不会阻塞当前线程，而是直接返回 <code>false</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>poll</code> 方法同理，获取元素失败也是直接返回空，并不会阻塞获取元素的线程。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>add</code> 方法其实就是对于 <code>offer</code> 做了一层封装，如下代码所示，可以看到 <code>add</code> 会调用没有规定时间的 <code>offer</code>，如果入队失败则直接抛异常。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>remove</code> 方法同理，调用 <code>poll</code>，如果返回 <code>null</code> 则说明队列没有元素，直接抛出异常。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>peek()</code> 方法的逻辑也很简单，内部调用了 <code>itemAt</code> 方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 指定超时时间内阻塞式获取和新增元素</h3>\n<p>在 <code>offer(E e)</code> 和 <code>poll()</code> 非阻塞获取和新增元素的基础上，设计者提供了带有等待时间的 <code>offer(E e, long timeout, TimeUnit unit)</code> 和 <code>poll(long timeout, TimeUnit unit)</code> ，用于在指定的超时时间内阻塞式地添加和获取元素。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，带有超时时间的 <code>offer</code> 方法在队列已满的情况下，会等待用户所传的时间段，如果规定时间内还不能存放元素则直接返回 <code>false</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同理，带有超时时间的 <code>poll</code> 也一样，队列为空则在规定时间内等待，若时间到了还是空的，则直接返回 null。</p>\n<h3> 判断元素是否存在</h3>\n<p><code>ArrayBlockingQueue</code> 提供了 <code>contains(Object o)</code> 来判断指定元素是否存在于队列中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ArrayBlockingQueue 获取和新增元素的方法对比</h2>\n<p>为了帮助理解 <code>ArrayBlockingQueue</code> ，我们再来对比一下上面提到的这些获取和新增元素的方法。</p>\n<p>新增元素：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>队列满时处理方式</th>\n<th>方法返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>put(E e)</code></td>\n<td>线程阻塞，直到中断或被唤醒</td>\n<td>void</td>\n</tr>\n<tr>\n<td><code>offer(E e)</code></td>\n<td>直接返回 false</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>offer(E e, long timeout, TimeUnit unit)</code></td>\n<td>指定超时时间内阻塞，超过规定时间还未添加成功则返回 false</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>add(E e)</code></td>\n<td>直接抛出 <code>IllegalStateException</code> 异常</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p>获取/移除元素：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>队列空时处理方式</th>\n<th>方法返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>take()</code></td>\n<td>线程阻塞，直到中断或被唤醒</td>\n<td>E</td>\n</tr>\n<tr>\n<td><code>poll()</code></td>\n<td>返回 null</td>\n<td>E</td>\n</tr>\n<tr>\n<td><code>poll(long timeout, TimeUnit unit)</code></td>\n<td>指定超时时间内阻塞，超过规定时间还是空的则返回 null</td>\n<td>E</td>\n</tr>\n<tr>\n<td><code>peek()</code></td>\n<td>返回 null</td>\n<td>E</td>\n</tr>\n<tr>\n<td><code>remove()</code></td>\n<td>直接抛出 <code>NoSuchElementException</code> 异常</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-get-add-element-methods.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> ArrayBlockingQueue 相关面试题</h2>\n<h3> ArrayBlockingQueue 是什么？它的特点是什么？</h3>\n<p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现，从其名字就能看出来了。</p>\n<p><code>ArrayBlockingQueue</code> 的容量有限，一旦创建，容量不能改变。</p>\n<p>为了保证线程安全，<code>ArrayBlockingQueue</code> 的并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。并且，它还支持公平和非公平两种方式的锁访问机制，默认是非公平锁。</p>\n<p><code>ArrayBlockingQueue</code> 虽名为阻塞队列，但也支持非阻塞获取和新增元素（例如 <code>poll()</code> 和 <code>offer(E e)</code> 方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为 null，一般不会使用。</p>\n<h3> ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3>\n<p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>\n<li>锁是否分离： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>\n<li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>\n</ul>\n<h3> ArrayBlockingQueue 和 ConcurrentLinkedQueue 有什么区别？</h3>\n<p><code>ArrayBlockingQueue</code> 和 <code>ConcurrentLinkedQueue</code> 是 Java 并发包中常用的两种队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>ConcurrentLinkedQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小，而 <code>ConcurrentLinkedQueue</code> 是无界队列，可以动态地增加容量。</li>\n<li>是否阻塞：<code>ArrayBlockingQueue</code> 支持阻塞和非阻塞两种获取和新增元素的方式（一般只会使用前者）， <code>ConcurrentLinkedQueue</code> 是无界的，仅支持非阻塞式获取和新增元素。</li>\n</ul>\n<h3> ArrayBlockingQueue 的实现原理是什么？</h3>\n<p><code>ArrayBlockingQueue</code> 的实现原理主要分为以下几点（这里以阻塞式获取和新增元素为例介绍）：</p>\n<ul>\n<li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li>\n<li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li>\n<li>通过 <code>Condition</code> 实现线程间的等待和唤醒操作。</li>\n</ul>\n<p>这里再详细介绍一下线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）：</p>\n<ul>\n<li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入（非满条件）。</li>\n<li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费（非空条件）。</li>\n<li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li>\n<li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li>\n</ul>\n<p>关于 <code>Condition</code>接口的补充：</p>\n<blockquote>\n<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>\n</blockquote>\n<h2> 参考文献</h2>\n<ul>\n<li>深入理解 Java 系列 | BlockingQueue 用法详解：<a href=\"https://juejin.cn/post/6999798721269465102\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6999798721269465102</a></li>\n<li>深入浅出阻塞队列 BlockingQueue 及其典型实现 ArrayBlockingQueue：<a href=\"https://zhuanlan.zhihu.com/p/539619957\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/539619957</a></li>\n<li>并发编程大扫盲：ArrayBlockingQueue 底层原理和实战：<a href=\"https://zhuanlan.zhihu.com/p/339662987\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/339662987</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/collection/arrayblockingqueue-class-diagram.png",
      "date_published": "2023-06-21T05:03:13.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "《后端面试高频系统设计&场景题》",
      "url": "https://javaguide.cn/zhuanlan/back-end-interview-high-frequency-system-design-and-scenario-questions.html",
      "id": "https://javaguide.cn/zhuanlan/back-end-interview-high-frequency-system-design-and-scenario-questions.html",
      "summary": "介绍 《后端面试高频系统设计&amp;场景题》 是我的知识星球的一个内部小册，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。 近年来，随着国内的技术面试越来越卷，越来越多的公司开始在面试中考察系统设计和场景问题，以此来更全面的考察求职者，不论是校招还是社招。不过，正常面试全是场景题的情况还是极少的，面试官一般会在面试中穿插一两个系统设计和场景题来考察你。",
      "content_html": "<h2> 介绍</h2>\n<p><strong>《后端面试高频系统设计&amp;场景题》</strong> 是我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>的一个内部小册，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。</p>\n<p>近年来，随着国内的技术面试越来越卷，越来越多的公司开始在面试中考察系统设计和场景问题，以此来更全面的考察求职者，不论是校招还是社招。不过，正常面试全是场景题的情况还是极少的，面试官一般会在面试中穿插一两个系统设计和场景题来考察你。</p>\n<p>于是，我总结了这份《后端面试高频系统设计&amp;场景题》，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。</p>\n<p>即使不是准备面试，我也强烈推荐你认真阅读这一系列文章，这对于提升自己系统设计思维和解决实际问题的能力还是非常有帮助的。并且，涉及到的很多案例都可以用到自己的项目上比如抽奖系统设计、第三方授权登录、Redis 实现延时任务的正确方式。</p>\n<p>《后端面试高频系统设计&amp;场景题》本身是属于《Java 面试指北》的一部分，后面由于内容篇幅较多，因此被单独提了出来。</p>\n<h2> 内容概览</h2>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/back-end-interview-high-frequency-system-design-and-scenario-questions-fengmian.png\" alt=\"《后端面试高频系统设计&amp;场景题》\" tabindex=\"0\"><figcaption>《后端面试高频系统设计&amp;场景题》</figcaption></figure>\n<h2> 星球其他资源</h2>\n<p><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>除了提供了 <strong>《Java 面试指北》</strong> 、 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《手写 RPC 框架》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册，还有 读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220211231206733.png\" alt=\"知识星球专栏概览\" tabindex=\"0\"><figcaption>知识星球专栏概览</figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220723120918434.png\" alt=\"星球 PDF 面试手册\" tabindex=\"0\"><figcaption>星球 PDF 面试手册</figcaption></figure>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a>。</p>\n<h2> 星球限时优惠</h2>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n",
      "image": "https://oss.javaguide.cn/xingqiu/back-end-interview-high-frequency-system-design-and-scenario-questions-fengmian.png",
      "date_published": "2023-06-15T08:04:34.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "分布式锁常见实现方案总结",
      "url": "https://javaguide.cn/distributed-system/distributed-lock-implementations.html",
      "id": "https://javaguide.cn/distributed-system/distributed-lock-implementations.html",
      "summary": "这是一则或许对你有用的小广告 面试专版：准备 Java 面试的小伙伴可以考虑面试专版：《Java 面试指北 》 (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。 知识星球：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 JavaGuide 官方知识星球。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">这是一则或许对你有用的小广告</p>\n<ul>\n<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>\n<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 官方知识星球</a></strong>。</li>\n</ul>\n</div>\n<p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。</p>\n<h2> 基于 Redis 实现分布式锁</h2>\n<h3> 如何基于 Redis 实现一个最简易的分布式锁？</h3>\n<p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p>\n<p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p>\n<p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p>\n<div class=\"language-lua line-numbers-mode\" data-ext=\"lua\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-setnx.png\" alt=\"Redis 实现简易分布式锁\" tabindex=\"0\"><figcaption>Redis 实现简易分布式锁</figcaption></figure>\n<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p>\n<h3> 为什么要给锁设置一个过期时间？</h3>\n<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>lockKey</strong>：加锁的锁名；</li>\n<li><strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li>\n<li><strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>\n<li><strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>\n</ul>\n<p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p>\n<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p>\n<p>你或许在想：<strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p>\n<h3> 如何实现锁的优雅续期？</h3>\n<p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：<strong><a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener noreferrer\">Redisson</a></strong> 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：<a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/distlock</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/redis-distributed-lock.png\" alt=\"Distributed locks with Redis\" tabindex=\"0\"><figcaption>Distributed locks with Redis</figcaption></figure>\n<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p>\n<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redisson-renew-expiration.png\" alt=\"Redisson 看门狗自动续期\" tabindex=\"0\"><figcaption>Redisson 看门狗自动续期</figcaption></figure>\n<p>看门狗名字的由来于 <code>getLockWatchdogTimeout()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a href=\"https://github.com/redisson/redisson/releases/tag/redisson-3.17.6\" target=\"_blank\" rel=\"noopener noreferrer\">redisson-3.17.6</a>）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>\n<p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p>\n<p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p>\n<h3> 如何实现可重入锁？</h3>\n<p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>\n<p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p>\n<p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p>\n<p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redisson-readme-locks.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> Redis 如何解决集群情况下分布式锁的可靠性？</h3>\n<p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p>\n<p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redis-master-slave-distributed-lock.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>针对这个问题，Redis 之父 antirez 设计了 <a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener noreferrer\">Redlock 算法</a> 来解决。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redis.io-realock.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>\n<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>\n<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>\n<p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href=\"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\" target=\"_blank\" rel=\"noopener noreferrer\">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505097&amp;idx=1&amp;sn=5c03cb769c4458350f4d4a321ad51f5a&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p>\n<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p>\n<p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p>\n<h2> 基于 ZooKeeper 实现分布式锁</h2>\n<p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。</p>\n<h3> 如何基于 ZooKeeper 实现分布式锁？</h3>\n<p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p>\n<p>获取锁：</p>\n<ol>\n<li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li>\n<li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li>\n<li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li>\n<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>\n</ol>\n<p>释放锁：</p>\n<ol>\n<li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li>\n<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li>\n<li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-zookeeper.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>\n<p><code>Curator</code>主要实现了下面四种锁：</p>\n<ul>\n<li><code>InterProcessMutex</code>：分布式可重入排它锁</li>\n<li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li>\n<li><code>InterProcessReadWriteLock</code>：分布式读写锁</li>\n<li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 为什么要用临时顺序节点？</h3>\n<p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p>\n<p>我们通常是将 znode 分为 4 大类：</p>\n<ul>\n<li><strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>\n<li><strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>\n<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li>\n<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>\n</ul>\n<p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p>\n<p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p>\n<p>假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p>\n<h3> 为什么要设置对前一个节点的监听？</h3>\n<blockquote>\n<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>\n</blockquote>\n<p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p>\n<p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p>\n<h3> 如何实现可重入锁？</h3>\n<p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍（源码地址：<a href=\"https://github.com/apache/curator/blob/master/curator-recipes/src/main/java/org/apache/curator/framework/recipes/locks/InterProcessMutex.java\" target=\"_blank\" rel=\"noopener noreferrer\">InterProcessMutex.java</a>）。</p>\n<p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p>\n<p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p>\n<p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>\n<h2> 总结</h2>\n<p>在这篇文章中，我介绍了实现分布式锁的两种常见方式： Redis 和 ZooKeeper。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。</p>\n<ul>\n<li>如果对性能要求比较高的话，建议使用 Redis 实现分布式锁（优先选择 Redisson 提供的现成的分布式锁，而不是自己实现）。</li>\n<li>如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁（推荐基于 Curator 框架实现）。不过，现在很多项目都不会用到 ZooKeeper，如果单纯是因为分布式锁而引入  ZooKeeper 的话，那是不太可取的，不建议这样做，为了一个小小的功能增加了系统的复杂度。</li>\n</ul>\n<p>最后，再分享两篇我觉得写的还不错的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/JzCHpIOiFVmBoAko58ZuGw\" target=\"_blank\" rel=\"noopener noreferrer\">分布式锁实现原理与最佳实践 - 阿里云开发者</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/-N4x6EkxwAYDGdJhwvmZLw\" target=\"_blank\" rel=\"noopener noreferrer\">聊聊分布式锁 - 字节跳动技术团队</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-setnx.png",
      "date_published": "2023-06-13T13:47:00.000Z",
      "date_modified": "2023-11-29T15:27:36.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "CopyOnWriteArrayList 源码分析",
      "url": "https://javaguide.cn/java/collection/copyonwritearraylist-source-code.html",
      "id": "https://javaguide.cn/java/collection/copyonwritearraylist-source-code.html",
      "summary": "CopyOnWriteArrayList 简介 在 JDK1.5 之前，如果想要使用并发安全的 List 只能选择 Vector。而 Vector 是一种老旧的集合，已经被淘汰。Vector 对于增删改查等方法基本都加了 synchronized，这种方式虽然能够保证同步，但这相当于对整个 Vector 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。 JDK1.5 引入了 Java.util.concurrent（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 List 实现就是 CopyOnWriteArrayList 。关于java.util.concurrent 包下常见并发容器的总结，可以看我写的这篇文章：Java 常见并发容器总结 。",
      "content_html": "<h2> CopyOnWriteArrayList 简介</h2>\n<p>在 JDK1.5 之前，如果想要使用并发安全的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <code>synchronized</code>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。</p>\n<p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。关于<code>java.util.concurrent</code> 包下常见并发容器的总结，可以看我写的这篇文章：<a href=\"https://javaguide.cn/java/concurrent/java-concurrent-collections.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 常见并发容器总结</a> 。</p>\n<h3> CopyOnWriteArrayList 到底有什么厉害之处？</h3>\n<p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 <code>List</code> 的内部数据，毕竟对于读取操作来说是安全的。</p>\n<p>这种思路与 <code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p>\n<p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p>\n<h3> Copy-On-Write 的思想是什么？</h3>\n<p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即写时复制，简称 COW。</p>\n<p>下面是维基百科对 Copy-On-Write 的介绍，介绍的挺不错：</p>\n<blockquote>\n<p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>\n</blockquote>\n<p>这里再以 <code>CopyOnWriteArrayList</code>为例介绍：当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p>\n<p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。</p>\n<p>不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：</p>\n<ol>\n<li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li>\n<li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li>\n<li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li>\n<li>……</li>\n</ol>\n<h2> CopyOnWriteArrayList 源码分析</h2>\n<p>这里以 JDK1.8 为例，分析一下 <code>CopyOnWriteArrayList</code> 的底层核心源码。</p>\n<p><code>CopyOnWriteArrayList</code> 的类定义如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>CopyOnWriteArrayList</code> 实现了以下接口：</p>\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/copyonwritearraylist-class-diagram.png\" alt=\"CopyOnWriteArrayList 类图\" tabindex=\"0\"><figcaption>CopyOnWriteArrayList 类图</figcaption></figure>\n<h3> 初始化</h3>\n<p><code>CopyOnWriteArrayList</code> 中有一个无参构造函数和两个有参构造函数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入元素</h3>\n<p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p>\n<ul>\n<li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li>\n<li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li>\n<li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li>\n</ul>\n<p>这里以<code>add(E e)</code>为例进行介绍：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面的源码可以看出：</p>\n<ul>\n<li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 <code>finally</code> 中，可以保证锁能被释放。</li>\n<li><code>CopyOnWriteArrayList</code> 通过复制底层数组的方式实现写操作，即先创建一个新的数组来容纳新添加的元素，然后在新数组中进行写操作，最后将新数组赋值给底层数组的引用，替换掉旧的数组。这也就证明了我们前面说的：<code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略。</li>\n<li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，<code>CopyOnWriteArrayList</code> 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。</li>\n<li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li>\n</ul>\n<blockquote>\n<p><code>Arrays.copyOf</code> 方法的时间复杂度是 O(n)，其中 n 表示需要复制的数组长度。因为这个方法的实现原理是先创建一个新的数组，然后将源数组中的数据复制到新数组中，最后返回新数组。这个方法会复制整个数组，因此其时间复杂度与数组长度成正比，即 O(n)。值得注意的是，由于底层调用了系统级别的拷贝指令，因此在实际应用中这个方法的性能表现比较优秀，但是也需要注意控制复制的数据量，避免出现内存占用过高的情况。</p>\n</blockquote>\n<h3> 读取元素</h3>\n<p><code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，<code>get</code>方法是弱一致性的，在某些情况下可能读到旧的元素值。</p>\n<p><code>get(int index)</code>方法是分两步进行的：</p>\n<ol>\n<li>通过<code>getArray()</code>获取当前数组的引用；</li>\n<li>直接从数组中获取下标为 index 的元素。</li>\n</ol>\n<p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p>\n<ol>\n<li>线程 1 调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了 array 属性值；</li>\n<li>线程 2 调用<code>CopyOnWriteArrayList</code>的<code>add</code>、<code>set</code>、<code>remove</code> 等修改方法时，内部通过<code>setArray</code>方法修改了<code>array</code>属性的值；</li>\n<li>线程 1 还是从旧的 <code>array</code> 数组中取值。</li>\n</ol>\n<h3> 获取列表中元素的个数</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>CopyOnWriteArrayList</code>中的<code>array</code>数组每次复制都刚好能够容纳下所有元素，并不像<code>ArrayList</code>那样会预留一定的空间。因此，<code>CopyOnWriteArrayList</code>中并没有<code>size</code>属性<code>CopyOnWriteArrayList</code>的底层数组的长度就是元素个数，因此<code>size()</code>方法只要返回数组长度就可以了。</p>\n<h3> 删除元素</h3>\n<p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p>\n<ol>\n<li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li>\n<li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li>\n<li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li>\n<li><code>void clear()</code>：移除此列表中的所有元素。</li>\n</ol>\n<p>这里以<code>remove(int index)</code>为例进行介绍：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 判断元素是否存在</h3>\n<p><code>CopyOnWriteArrayList</code>提供了两个用于判断指定元素是否在列表中的方法：</p>\n<ul>\n<li><code>contains(Object o)</code>：判断是否包含指定元素。</li>\n<li><code>containsAll(Collection&lt;?&gt; c)</code>：判断是否保证指定集合的全部元素。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> CopyOnWriteArrayList 常用方法测试</h2>\n<p>代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/collection/copyonwritearraylist-class-diagram.png",
      "date_published": "2023-06-08T12:34:44.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "LinkedList 源码分析",
      "url": "https://javaguide.cn/java/collection/linkedlist-source-code.html",
      "id": "https://javaguide.cn/java/collection/linkedlist-source-code.html",
      "summary": "JavaGuide官方知识星球 LinkedList 简介 LinkedList 是一个基于双向链表实现的集合类，经常被拿来和 ArrayList 做比较。关于 LinkedList 和ArrayList的详细对比，我们 Java 集合常见面试题总结(上)有详细介绍到。",
      "content_html": "<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiu.png\" alt=\"JavaGuide官方知识星球\" tabindex=\"0\"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>\n<h2> LinkedList 简介</h2>\n<p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。关于 <code>LinkedList</code> 和<code>ArrayList</code>的详细对比，我们 <a href=\"/java/collection/java-collection-questions-01.html\" target=\"blank\">Java 集合常见面试题总结(上)</a>有详细介绍到。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png\" alt=\"双向链表\" tabindex=\"0\"><figcaption>双向链表</figcaption></figure>\n<p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>另外，不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>\n<h3> LinkedList 插入和删除元素的时间复杂度？</h3>\n<ul>\n<li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>\n<li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>\n<li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>\n</ul>\n<h3> LinkedList 为什么不能实现 RandomAccess 接口？</h3>\n<p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p>\n<h2> LinkedList 源码分析</h2>\n<p>这里以 JDK1.8 为例，分析一下 <code>LinkedList</code> 的底层核心源码。</p>\n<p><code>LinkedList</code> 的类定义如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p>\n<p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p>\n<p><code>LinkedList</code> 实现了以下接口：</p>\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 \"deck\" [dɛk]，这个大部分人都会读错。</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist--class-diagram.png\" alt=\"LinkedList 类图\" tabindex=\"0\"><figcaption>LinkedList 类图</figcaption></figure>\n<p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 初始化</h3>\n<p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入元素</h3>\n<p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p>\n<p>我们这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p>\n<p><code>add()</code> 方法有两个版本：</p>\n<ul>\n<li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li>\n<li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取元素</h3>\n<p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p>\n<ol>\n<li><code>getFirst()</code>：获取链表的第一个元素。</li>\n<li><code>getLast()</code>：获取链表的最后一个元素。</li>\n<li><code>get(int index)</code>：获取链表指定位置的元素。</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里的核心在于 <code>node(int index)</code> 这个方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p>\n<p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p>\n<h3> 删除元素</h3>\n<p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p>\n<ol>\n<li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li>\n<li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li>\n<li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li>\n<li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li>\n<li><code>void clear()</code>：移除此链表中的所有元素。</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>unlink()</code> 方法的逻辑如下：</p>\n<ol>\n<li>首先获取待删除节点 x 的前驱和后继节点；</li>\n<li>判断待删除节点是否为头节点或尾节点：\n<ul>\n<li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li>\n<li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li>\n<li>如果 x 不是头节点也不是尾节点，执行下一步操作</li>\n</ul>\n</li>\n<li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li>\n<li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li>\n<li>将待删除节点 x 的元素置空，修改链表长度。</li>\n</ol>\n<p>可以参考下图理解（图源：<a href=\"https://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8/\" target=\"_blank\" rel=\"noopener noreferrer\">LinkedList 源码分析(JDK 1.8)</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist-unlink.jpg\" alt=\"unlink 方法逻辑\" tabindex=\"0\"><figcaption>unlink 方法逻辑</figcaption></figure>\n<h3> 遍历链表</h3>\n<p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面我们对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p>\n<p>我们先来看下从头到尾方向的迭代：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看一下从尾到头方向的迭代：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>迭代器对应的移除元素的方法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> LinkedList 常用方法测试</h2>\n<p>代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png",
      "date_published": "2023-06-07T05:18:39.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "工作五年之后，对技术和业务的思考",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html",
      "summary": "推荐语：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。 原文地址： https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA</a></p>\n</blockquote>\n<p>苦海无边，回头无岸。</p>\n<h2> 01 前言</h2>\n<p>晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？</p>\n<p>初入职场，大部分程序员会觉得苦学技术，以后会顺风顺水升职加薪，这样的想法没有错，但是不算全面，五年后你会不会继续做技术写代码这是核心问题。</p>\n<p>初入职场，会觉得努力加班可以不断提升能力，可以学到技术的公司就算薪水低点也可以接受，但是五年之后会认为加班都是在不断挤压自己的上升空间，薪水低是人生的天花板。</p>\n<p>这里想说的关键问题就是：初入职场的认知和想法大部分不会再适用于五年后的认知。</p>\n<p>工作五年之后面临的最大压力就是选择：职场天花板，技术能力天花板，薪水天花板，三十岁天花板。</p>\n<p>如何面对这些问题，是大部分程序员都在思考和纠结的。做选择的唯一参考点就是：利益最大化，这里可以理解为职场更好的升职加薪，顺风顺水。</p>\n<p>五年，变化最大不是工作经验，能力积累，而是心态，清楚的知道现实和理想之间是存在巨大的差距。</p>\n<h2> 02 学会适应变化，并积累能力</h2>\n<p>回首自己的职场五年，最认可的一句话就是：学会适应变化，并积累能力。</p>\n<p>变化的就是，五年的时间技术框架更新迭代，开发工具的变迁，公司环境队友的更换，甚至是不同城市的流浪，想着能把肉体和灵魂安放在一处，有句很经典的话就是：唯一不变的就是变化本身。</p>\n<p>要积累的是：解决问题的能力，思考方式，拓宽认知。</p>\n<p>这种很难直白的描述，属于个人认知的范畴，不同的人有不一样的看法，所以只能站在大众化的角度去思考。</p>\n<p>首先聊聊技术，大部分小白级别的，都希望自己的技术能力不断提高，争取做到架构师级别，但是站在当前的互联网环境中，这种想法实现难度还是偏高，这里既不是打击也不是为了抬杠。</p>\n<p>可以观察一下现状，技术团队大的 20-30 人，小的 10-15 人，能有一个架构师去专门管理底层框架都是少有现象。</p>\n<p>这个问题的原因很多，首先架构师的成本过高，环境架构也不是需要经常升级，说的难听点可能框架比项目生命周期更高。</p>\n<p>所以大部分公司的大部分业务，基于现有大部分成熟的开源框架都可以解决，这也就导致架构师这个角色通常由项目主管代替或者级别较高的开发直接负责，这就是现实情况。</p>\n<p>这就导致技术框架的选择思路就是：只选对的。即这方面的人才多，开源解决方案多，以此降低技术方面对公司业务发展的影响。</p>\n<p>那为什么还要不断学习和积累技术能力？如果没有这个能力，程序员岗位可能根本走不了五年之久，需要用技术深度积累不断解决工作中的各种问题，用技术的广度提升自己实现业务需求的认知边界，这是安放肉体的根本保障。</p>\n<p>这就是导致很多五年以后的程序员压力陡然升高的原因，走向管理岗的另一个壁垒就是业务思维和认知。</p>\n<h2> 03 提高业务能力的积累</h2>\n<p>程序员该不该用心研究业务，这个问题真的没有纠结的必要，只要不是纯技术型的公司，都需要面对业务。</p>\n<p>不管技术、运营、产品、管理层，都是在面向业务工作。</p>\n<p>从自己职场轨迹来看，五年变化最大就是解决业务问题的能力，职场之初面对很多业务场景都不知道如何下手，到几年之后设计业务的解决方案。</p>\n<p>这是大部分程序员在职场前五年跳槽就能涨薪的根本原因，面对业务场景，基于积累的经验和现有的开源工具，能快速给出合理的解决思路和实现过程。</p>\n<p>工作五年可能对技术底层的清晰程度都没有初入职场的小白清楚，但是写的程序却可以避开很多坑坑洼洼，对于业务的审视也是很细节全面。</p>\n<p>解决业务能力的积累，对于技术视野的宽度需求更甚，比如职场初期对于海量数据的处理束手无策，但是在工作几年之后见识数据行业的技术栈，真的就是技术选型的视野问题。</p>\n<p>什么是衡量技术能力的标准？站在一个共识的角度上看：系统的架构与代码设计能适应业务的不断变化和各种需求。</p>\n<p>相对比与技术，业务的变化更加快速频繁，高级工程师或者架构师之所以薪资高，这些角色一方面能适应业务的迭代，并且在工作中具有一定前瞻性，会考虑业务变化的情况下代码复用逻辑，这样的能力是需要一定的技术视野和业务思维的沉淀。</p>\n<p>所以职场中：业务能说的井井有条，代码能写的明明白白，得到机会的可能性更大。</p>\n<h2> 04 不同的阶段技术和业务的平衡和选择</h2>\n<p>从理性的角度看技术和业务两个方面，能让大部分人职场走的平稳顺利，但是不同的阶段对两者的平衡和选择是不一样的。</p>\n<p>在思考如何选择的时候，可以参考二八原则的逻辑，即在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80%尽管是多数，却是次要的，因此又称二八定律。</p>\n<p>个人真的非常喜欢这个原则，大部分人都不是天才，所以很难三心二意同时做好几件事情，在同一时间段内应该集中精力做好一件事件。</p>\n<p>但是单纯的二八原则模式可能不适应大部分职场初期的人，因为初期要学习很多内容，如何在职场生存：专业能力，职场关系，为人处世，产品设计等等。</p>\n<p>当然这些东西不是都要用心刻意学习，但是合理安排二二六原则或其他组合是更明智的，首先是专业能力要重点练习，其次可以根据自己的兴趣合理选择一到两个方面去慢慢了解，例如产品，运营，运维，数据等，毕竟三五年以后会不会继续写代码很难说，多给自己留个机会总是有备无患。</p>\n<p>在职场初期，基本都是从技术角度去思考问题，如何快速提升自己的编码能力，在公司能稳定是首要目标，因此大部分时间都是在做基础编码和学习规范，这时可能 90%的心思都是放在基础编码上，另外 10%会学习环境架构。</p>\n<p>最多一到两年，就会开始独立负责模块需求开发，需要自己设计整个代码思路，这里业务就会进入视野，要懂得业务上下游关联关系，学会思考如何设计代码结构，才能在需求变动的情况下代码改动较少，这个时候可能就会放 20%的心思在业务方面，30%学习架构方式。</p>\n<p>三到五年这个时间段，是解决问题能力提升最快的时候，因为这个阶段的程序员基本都是在开发核心业务链路，例如交易、支付、结算、智能商业等模块，需要对业务整体有较清晰的把握能力，不然就是给自己挖坑，这个阶段要对业务流付出大量心血思考。</p>\n<p>越是核心的业务线，越是容易爆发各种问题，如果在日常工作中不花心思处理各种细节问题，半夜异常自动的消息和邮件总是容易让人憔悴。</p>\n<p>所以努力学习技术是提升自己，培养自己的业务认知也同样重要，个人认为这二者的分量平分秋色，只是需要在合适的阶段做出合理的权重划分。</p>\n<h2> 05 学会在职场做选择和生存</h2>\n<p>基于技术能力和业务思维，学会在职场做选择和生存，这些是职场前五年一路走来的最大体会。</p>\n<p>不管是技术还是业务，这两个概念依旧是个很大的命题，不容易把握，所以学会理清这两个方面能力中的公共模块是关键。</p>\n<p>不管技术还是业务，都不可能从一家公司完全复制到另一家公司，但是可以把一家公司的技术框架，业务解决方案学会，并且带到另一家公司，例如技术领域内的架构、设计、流程、数据管理，业务领域内的思考方式、产品逻辑、分析等，这些是核心能力并且是大部分公司人才招聘的要求，所以这些才是工作中需要重点积累的。</p>\n<p>人的精力是有限的，而且面对三十这个天花板，各种事件也会接连而至，在职场中学会合理安排时间并不断提升核心能力，这样才能保证自己的竞争力。</p>\n<p>职场就像苦海无边，回首望去可能也没有岸边停泊，但是要具有换船的能力或者有个小木筏也就大差不差了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-06-04T16:54:06.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [
        {
          "name": "知了一笑"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "使用建议",
      "url": "https://javaguide.cn/javaguide/use-suggestion.html",
      "id": "https://javaguide.cn/javaguide/use-suggestion.html",
      "summary": "对于不准备面试的同学来说 ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。 对于准备面试的同学来说 ，本文档涵盖 Java 程序员所需要掌握的核心知识的常见面试问题总结。 大部分人看 JavaGuide 应该都是为了准备技术八股文。那如何才能更高效地准备技术八股文？",
      "content_html": "<p><strong>对于不准备面试的同学来说</strong> ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。</p>\n<p><strong>对于准备面试的同学来说</strong> ，本文档涵盖 Java 程序员所需要掌握的核心知识的常见面试问题总结。</p>\n<p>大部分人看 JavaGuide 应该都是为了准备技术八股文。<strong>那如何才能更高效地准备技术八股文？</strong></p>\n<p>对于技术八股文来说，尽量不要死记硬背，这种方式非常枯燥且对自身能力提升有限！但是！想要一点不背是不太现实的，只是说要结合实际应用场景和实战来理解记忆。</p>\n<p>我一直觉得面试八股文最好是和实际应用场景和实战相结合。很多同学现在的方向都错了，上来就是直接背八股文，硬生生学成了文科，那当然无趣了。</p>\n<p>举个例子：你的项目中需要用到 Redis 来做缓存，你对照着官网简单了解并实践了简单使用 Redis 之后，你去看了 Redis 对应的八股文。你发现 Redis 可以用来做限流、分布式锁，于是你去在项目中实践了一下并掌握了对应的八股文。紧接着，你又发现 Redis 内存不够用的情况下，还能使用 Redis Cluster 来解决，于是你就又去实践了一下并掌握了对应的八股文。</p>\n<p>而且， <strong>面试中有水平的面试官都是根据你的项目经历来顺带着问一些技术八股文</strong> 。</p>\n<p>举个例子：你的项目用到了消息队列，那面试官可能就会问你：为什么使用消息队列？项目中什么模块用到了消息队列？如何保证消息不丢失？如何保证消息的顺序性?（结合你使用的具体的消息队列来准备）……。</p>\n<p><strong>一定要记住你的主要目标是理解和记关键词，而不是像背课文一样一字一句地记下来！</strong></p>\n<p>另外，记录博客或者用自己的理解把对应的知识点讲给别人听也是一个不错的选择。</p>\n<p>最后，准备技术面试的同学一定要定期复习（自测的方式非常好），不然确实会遗忘的。</p>\n",
      "date_published": "2023-05-22T02:13:07.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "十年大厂成长之路",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html",
      "summary": "推荐语：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。 原文地址： https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w</a></p>\n</blockquote>\n<p>最近这段时间，有好几个年轻的同学和我聊到自己的迷茫。其中有关于技术成长的、有关于晋升的、有关于择业的。我很高兴他们愿意听我这个“过来人”分享自己的经验。</p>\n<p>我自己毕业后进入大厂，在大厂工作 12 年，我说的内容都来自于我自己或者身边人的真实情况。尤其，我会把 <strong>【我自己走过的弯路】</strong> 和 <strong>【我看到过的优秀技术人的特质】</strong> 相结合来给出建议。</p>\n<p>这些内容我觉得具有普遍的指导意义，所以决定做个整理分享出来。我相信，无论你在大厂还是小厂，如果你相信这些建议，或早或晚他们会帮助到你。</p>\n<p>我自己工作 12 年，走了些弯路，所以我就来讲讲，“在一个技术人 10 年的发展过程中，应该注意些什么”。我们把内容分为两块：</p>\n<ol>\n<li><strong>十年技术路怎么走</strong></li>\n<li><strong>一些重要选择</strong></li>\n</ol>\n<h2> 01 十年技术路怎么走</h2>\n<h3> 【1-2 年】=&gt; 从“菜鸟”到“职业”</h3>\n<p>应届生刚进入到工作时，会有各种不适应。比如写好的代码会被反复打回、和团队老司机讨论技术问题会有一堆问号、不敢提问和质疑、碰到问题一个人使劲死磕等等。</p>\n<p><strong>简单来说就是，即使日以继夜地埋头苦干，最后也无法顺利的开展工作。</strong></p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【多看多模仿】</strong>：比如写代码的时候，不要就像在学校完成书本作业那样只关心功能是否正确，还要关心模块的设计、异常的处理、代码的可读性等等。在你还没有了解这些内容的精髓之前，也要照猫画虎地模仿起来，慢慢地你就会越来越明白真实世界的代码是怎么写的，以及为什么要这么写。</p>\n<p>做技术方案的时候也是同理，技术文档的要求你也许并不理解，但你可以先参考已有文档写起来。</p>\n<p><strong>【脸皮厚一点】</strong>：不懂就问，你是新人大家都是理解的。你做的各种方案也可以多找老司机们 review，不要怕被看笑话。</p>\n<p><strong>【关注工作方式】</strong>：比如发现需求在计划时间完不成就要尽快报风险、及时做好工作内容的汇报（例如周报）、开会后确定会议结论和 todo 项、承诺时间就要尽力完成、严格遵循公司的要求（例如发布规范、权限规范等）</p>\n<p>一般来说，工作 2 年后，你就应该成为一个职业人。老板可以相信任何工作交到你的手里，不会出现“意外”（例如一个重要需求明天要上线了，突然被告知上不了）。</p>\n<h3> 【3-4 年】=&gt; 从“职业”到“尖兵”</h3>\n<p>工作两年后，对业务以及现有系统的了解已经到达了一定的程度，技术同学会开始承担更有难度的技术挑战。</p>\n<p>例如需要将性能提升到某一个水位、例如需要对某一个重要模块进行重构、例如有个重要的项目需要协同 N 个团队一起完成。</p>\n<p>可见，上述的这些技术问题，难度都已经远远超过一个普通的需求。解决这些问题需要有一定的技术能力，同时也需要具备更高的协同能力。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【技术能力提升】</strong>：无论是公司内还是公司外的技术内容，都要多做主动的学习。基本上这个阶段的技术难题都集中在【性能】【稳定性】和【扩展性】上，而这些内容在业界都是有成型的方法论的。</p>\n<p><strong>【主人翁精神】</strong>：技术难题除了技术方案设计及落地外，背后还有一系列的其他工作。例如上线后对效果的观测、重点项目对于上下游改造和风险的了解程度、对于整个技改后续的计划（二期、三期的优化思路）等。</p>\n<p>在工作四年后，基本上你成为了团队的一、二号技术位。很多技术难题即使不是你来落地，也是由你来决定方案。你会做调研、会做方案对比、会考虑整个技改的生命周期。</p>\n<h3> 【5-7 年】=&gt; 从“尖兵”到“专家”</h3>\n<p>技术尖兵重点在于解决某一个具体的技术难题或者重点项目。而下一步的发展方向，就是能够承担起来一整个“业务板块”，也就是“领域技术专家”。</p>\n<p>想要承担一整个“业务板块”需要 <strong>【对业务领域有深刻的理解，同时基于这些理解来规划技术的发展方向】</strong> 。</p>\n<p>拿支付做个例子。简单的支付功能其实很容易完成，只要处理好和双联（网联和银联）的接口调用（成功、失败、异常）即可。但在很多背景下，支付没有那么简单。</p>\n<p>例如，支付是一个用户敏感型操作，非常强调用户体验，如何能兼顾体验和接口的不稳定？支付接口还需要承担费用，同步和异步的接口费用不同，如何能够降本？支付接口往往还有限额等。这一系列问题的背后涉及到很多技术的设计，包括异步化、补偿设计、资金流设计、最终一致性设计等等。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【深入理解行业及趋势】</strong>：密切关注行业的各种变化（新鲜的玩法、政策的变动、竞对的策略、科技等外在因素的影响等等），和业务同学加强沟通。</p>\n<p><strong>【深入了解行业解决方案】</strong>：充分对标已有的国内外技术方案，做深入学习和尝试，评估建设及运维成本，结合业务趋势制定计划。</p>\n<h3> 【8-10 年】=&gt; 从“专家”到“TL”</h3>\n<p>其实很多时候，如果能做到专家，基本也是一个 TL 的角色了，但这并不代表正在执行 TL 的职责。</p>\n<p>专家虽然已经可以做到“为业务发展而规划好技术发展”，但问题是要怎么落地呢？显然，靠一个人的力量是不可能完成建设的。所以，这里的 TL 更多强调的不是“领导”这个职位，而是 <strong>【通过聚合一个团队的力量来实施技术规划】</strong> 。</p>\n<p>所以，这里的 TL 需要具备【团队技术培养】【合理分配资源】【确认工作优先级】【激励与奖惩】等各种能力。</p>\n<p>这个阶段最重要的几个点：</p>\n<p><strong>【学习管理学】</strong>：这里的管理学当然不是指 PUA，而是指如何在每个同学都有各自诉求的现实背景下，让个人目标和团队目标相结合，产生向前发展的动力。</p>\n<p><strong>【始终扎根技术】</strong>：很多时候，工作重心偏向管理以后，就会荒废技术。但事实是，一个优秀的领导永远是一个优秀的技术人。参与一起讨论技术方案并给予指导、不断扩展自己的技术宽度、保持对技术的好奇心，这些是让一个技术领导持续拥有向心力的关键。</p>\n<h2> 02 一些重要选择</h2>\n<p>下面来聊聊在十年间我们可能会碰到的一些重要选择。这些都是真实的血与泪的教训。</p>\n<h3> 我该不该转岗？</h3>\n<p>大厂都有转岗的机制。转岗可以帮助员工寻找自己感兴趣的方向，也可以帮助新型团队招募有即战力的同学。</p>\n<p>转岗看似只是在公司内部变动，但你需要谨慎决定。</p>\n<p>本人转岗过多次。虽然还在同一家公司，但转岗等同于换工作。无论是领域沉淀、工作内容、信任关系、协作关系都是从零开始。</p>\n<p>针对转岗我的建议是：**如果你是想要拓宽自己的技术广度，也就是抱着提升技术能力的想法，我觉得可以转岗。但如果你想要晋升，不建议你转岗。**晋升需要在一个领域的持续积淀和在一个团队信任感的持续建立。</p>\n<p>当然，转岗可能还有其他原因，例如家庭原因、身体原因等，这个不展开讨论了。</p>\n<h3> 我该不该跳槽？</h3>\n<p>跳槽和转岗一样，往往有很多因素造成，不能一概而论，我仅以几个场景来说：</p>\n<p><strong>【晋升失败】</strong>：扪心自问，如果你觉得自己确实还不够格，那你就踏踏实实继续努力。如果你觉得评委有失偏颇，你可以尝试去外面面试一下，让市场来给你答案。</p>\n<p><strong>【成长局限】</strong>：觉得自己做的事情没有挑战，无法成长。你可以和老板聊一下，有可能是因为你没有看到其中的挑战，也有可能老板没有意识到你的“野心”。</p>\n<p><strong>【氛围不适】</strong>：一般来自于新入职或者领导更换，这种情况下不适是正常的。我的建议是，<strong>如果一个环境是“对事不对人”的，那就可以留下来</strong>，努力去适应，这种不适应只是做事方式不同导致的。但如果这个环境是“对人不对事”的话，走吧。</p>\n<h3> 跳槽该找怎样的工作？</h3>\n<p>我们跳槽的时候往往会同时面试好几家公司。行情好的时候，往往可以收到多家 offer，那么我们要如何选择呢？</p>\n<p>考虑一个 offer 往往有这几点：【公司品牌】【薪资待遇】【职级职称】【技术背景】。每个同学其实都有自己的诉求，所以无论做什么选择都没有对错之分。</p>\n<p>我的一个建议是：<strong>你要关注新岗位的空间，这个空间是有希望满足你的期待的</strong>。</p>\n<p>比如，你想成为架构师，那新岗位是否有足够的技术挑战来帮助你提升技术能力，而不仅仅是疲于奔命地应付需求？</p>\n<p>比如，你想往技术管理发展，那新岗位是否有带人的机会？是否有足够的问题需要搭建团队来解决？</p>\n<p>比如，你想扎根在某个领域持续发展（例如电商、游戏），那新岗位是不是延续这个领域，并且可以碰到更多这个领域的问题？</p>\n<p>当然，如果薪资实在高到无法拒绝，以上参考可以忽略!</p>\n<h2> 结语</h2>\n<p>以上就是我对互联网从业技术人员十年成长之路的心得，希望在你困惑和关键选择的时候可以帮助到你。如果我的只言片语能够在未来的某个时间帮助到你哪怕一点，那将是我莫大的荣幸。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-05-15T09:49:43.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [
        {
          "name": "CodingBetterLife"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "32条总结教你提升职场经验",
      "url": "https://javaguide.cn/high-quality-technical-articles/work/32-tips-improving-career.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/work/32-tips-improving-career.html",
      "summary": "推荐语：阿里开发者的一篇职场经验的分享。 原文地址： https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g 成长的捷径 入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线； 写一篇技术博客大概需要两周左右，但可能是最快的成长方式； 一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）； 多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你； 不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全； 不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤； 思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者； 好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：阿里开发者的一篇职场经验的分享。</p>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g</a></p>\n</blockquote>\n<h2> 成长的捷径</h2>\n<ul>\n<li>入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线；</li>\n<li>写一篇技术博客大概需要两周左右，但可能是最快的成长方式；</li>\n<li>一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）；</li>\n<li>多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你；</li>\n<li>不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全；</li>\n<li>不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤；</li>\n<li>思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者；</li>\n<li>好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。</li>\n</ul>\n<h2> 功夫在日常</h2>\n<ul>\n<li>每行代码要代表自己当下的最高水平，你觉得无所谓的小细节，有可能就是在晋升场上伤害你的暗箭；</li>\n<li>双周报不是工作日志流水账，不要被时间推着走，最起码要知道下次双周报里会有什么（小目标驱动）；</li>\n<li>觉得日常都是琐碎工作、不技术、给师兄打杂等，可以尝试对手头事情做一下分类，想象成每个分类都是个小格子，这些格子连起来的终点就是自己的目标，这样每天不再是机械的做需求，而是有规划的填格子、为目标努力，甚至会给自己加需求，因为自己看清楚了要去哪里；</li>\n<li>日常的言行举止是能力的显微镜，大部分人可能意识不到，自己的强大和虚弱是那么的明显，不要无谓的试图掩盖，更不存在蒙混过关。</li>\n</ul>\n<blockquote>\n<p>最后一条大概意思就是有时候我们会在意自己在聚光灯下（述职、晋升、周报、汇报等）的表现，以为大家会根据这个评价自己。实际上日常是怎么完成业务需求、帮助身边同学、创造价值的，才是大家评价自己的依据，而且每个人是什么样的特质，合作过三次的伙伴就可以精准评价，在聚光灯下的表演只能骗自己。</p>\n</blockquote>\n<h2> 学会被管理</h2>\n<blockquote>\n<p>上级、主管是泛指，开发对口的 PD 主管等也在范围内。</p>\n</blockquote>\n<ul>\n<li>\n<p>不要传播负面情绪，不要总是抱怨；</p>\n</li>\n<li>\n<p>对上级不卑不亢更容易获得尊重，但不要当众反驳对方观点，分歧私下沟通；</p>\n</li>\n<li>\n<p>好好做向上管理，尤其是对齐预期，沟通绩效出现 Surprise 双方其实都有责任，但倒霉的是自己；</p>\n</li>\n<li>\n<p>尽量站在主管角度想问题：</p>\n</li>\n<li>\n<ul>\n<li>这样能理解很多过去感觉匪夷所思的决策；</li>\n<li>不要在意谁执行、功劳是谁的等，为团队分忧赢得主管信任的重要性远远高于这些；</li>\n<li>不要把这个原则理解为唯上，这种最让人不齿。</li>\n</ul>\n</li>\n</ul>\n<h2> 思维转换</h2>\n<ul>\n<li>定义问题是个高阶能力，尽早形成 发现问题-&gt;定义问题-&gt;解决问题-&gt;消灭问题 的思维闭环；</li>\n<li>定事情价值导向，做事情结果导向，讲事情问题导向；</li>\n<li>讲不清楚，大概率不是因为自己是实干型，而是没想清楚，在晋升场更加明显；</li>\n<li>当一个人擅长解决某一场景的问题的时候，时间越久也许越离不开这个场景（被人贴上一个标签很难，撕掉一个标签更难）。</li>\n</ul>\n<h2> 要栓住情绪</h2>\n<ul>\n<li>学会控制情绪，没人会认真听一个愤怒的人在说什么；</li>\n<li>再委屈、再愤怒也要保持理智，不要让自己成为需要被哄着的那种人；</li>\n<li>足够自信的人才会坦率的承认自己的问题，很多时候我们被激怒了，只是因为对方指出了自己藏在深处的自卑；</li>\n<li>伤害我们最深的既不是别人的所作所为，也不是自己犯的错误，而是我们对错误的回应。</li>\n</ul>\n<h2> 成为 Leader</h2>\n<blockquote>\n<p>Manager 有下属，Leader 有追随者，管理者不需要很多，但人人都可以是 Leader。</p>\n</blockquote>\n<ul>\n<li>让你信服、愿意追随的人不是职务上的 Manager，而是在帮助自己的那个人，自己想服众的话道理一样；</li>\n<li>不要轻易对人做负面评价，片面认知下的评价可能不准确，不经意的传播更是会给对方带来极大的困扰；</li>\n<li>Leader 如果不认同公司的使命、愿景、价值观，会过的特别痛苦；</li>\n<li>困难时候不要否定自己的队友，多给及时、正向的反馈；</li>\n<li>船长最重要的事情不是造船，而是激发水手对大海的向往；</li>\n<li>Leader 的天然职责是让团队活下去，唯一的途径是实现上级、老板、公司经营者的目标，越是艰难的时候越明显；</li>\n<li>Leader 的重要职责是识别团队需要被做的事情，并坚定信念，使众人行，越是艰难的时候越要坚定；</li>\n<li>Leader 应该让自己遇到的每个人都感觉自己很重要、被需要。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-05-15T09:49:43.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "JVM线上问题排查和性能调优案例",
      "url": "https://javaguide.cn/java/jvm/jvm-in-action.html",
      "id": "https://javaguide.cn/java/jvm/jvm-in-action.html",
      "summary": "JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。 这篇文章，我会分享一些我看到的相关的案例。 下面是正文。 一次线上 OOM 问题分析 - 艾小仙 - 2023 现象：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。 分析：使用 JDK 自带的jvisualvm分析 dump 文件(MAT 也能分析)。 建议：对于 SQL 语句，如果监测到没有where条件的全表查询应该默认增加一个合适的limit作为限制，防止这种问题拖垮整个系统 资料：实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022。",
      "content_html": "<p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。</p>\n<p>这篇文章，我会分享一些我看到的相关的案例。</p>\n<p>下面是正文。</p>\n<p><a href=\"https://juejin.cn/post/7205141492264976445\" target=\"_blank\" rel=\"noopener noreferrer\">一次线上 OOM 问题分析 - 艾小仙 - 2023</a></p>\n<ul>\n<li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li>\n<li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li>\n<li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li>\n<li><strong>资料</strong>：<a href=\"https://heapdump.cn/article/3489050\" target=\"_blank\" rel=\"noopener noreferrer\">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</a>。</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/mylibs/p/production-accident-0002.html\" target=\"_blank\" rel=\"noopener noreferrer\">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023</a></p>\n<ul>\n<li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li>\n<li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li>\n<li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。</li>\n<li><strong>建议</strong>：正常情况下，<code>-Xmn</code>参数（控制 Young 区的大小）总是应当小于<code>-Xmx</code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li>\n<li><strong>资料</strong>：<a href=\"https://javaguide.cn/java/jvm/jvm-parameters-intro.html\" target=\"_blank\" rel=\"noopener noreferrer\">最重要的 JVM 参数总结 - JavaGuide - 2023</a></li>\n</ul>\n<p><a href=\"https://juejin.cn/post/7078624931826794503\" target=\"_blank\" rel=\"noopener noreferrer\">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></p>\n<ul>\n<li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li>\n<li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li>\n<li><strong>建议</strong>：远离 Hibernate。</li>\n<li><strong>资料</strong>：<a href=\"https://liam.page/2020/07/17/memory-stat-in-TOP/\" target=\"_blank\" rel=\"noopener noreferrer\">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</a></li>\n</ul>\n<p><a href=\"https://www.heapdump.cn/article/1661497\" target=\"_blank\" rel=\"noopener noreferrer\">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021</a></p>\n<ul>\n<li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li>\n<li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。</li>\n<li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li>\n</ul>\n<p><a href=\"https://shuyi.tech/archives/have-a-try-in-jvm-combat\" target=\"_blank\" rel=\"noopener noreferrer\">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></p>\n<p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ\" target=\"_blank\" rel=\"noopener noreferrer\">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></p>\n<ul>\n<li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li>\n<li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li>\n</ul>\n<p><a href=\"https://tech.meituan.com/2020/11/12/java-9-cms-gc.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020</a></p>\n<p>这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-05-10T08:36:34.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "分布式ID设计指南",
      "url": "https://javaguide.cn/distributed-system/distributed-id-design.html",
      "id": "https://javaguide.cn/distributed-system/distributed-id-design.html",
      "summary": "提示 看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：分布式 ID 生成服务的技术原理和项目实战 。 网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：<a href=\"https://mp.weixin.qq.com/s/bFDLb6U6EgI-DvCdLTq_QA\" target=\"_blank\" rel=\"noopener noreferrer\">分布式 ID 生成服务的技术原理和项目实战</a> 。</p>\n</div>\n<p>网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。</p>\n<p>本文结合一些使用场景，进一步探讨业务场景中对 ID 有哪些具体的要求。</p>\n<h2> 场景一：订单系统</h2>\n<p>我们在商场买东西一码付二维码，下单生成的订单号，使用到的优惠券码，联合商品兑换券码，这些是在网上购物经常使用到的单号，那么为什么有些单号那么长，有些只有几位数？有些单号一看就知道年月日的信息，有些却看不出任何意义？下面展开分析下订单系统中不同场景的 id 服务的具体实现。</p>\n<h3> 1、一码付</h3>\n<p>我们常见的一码付，指的是一个二维码可以使用支付宝或者微信进行扫码支付。</p>\n<p>二维码的本质是一个字符串。聚合码的本质就是一个链接地址。用户使用支付宝微信直接扫一个码付钱，不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码，这极大减少了用户扫码支付的时间。</p>\n<p>实现原理是当客户用 APP 扫码后，网站后台就会判断客户的扫码环境。（微信、支付宝、QQ 钱包、京东支付、云闪付等）。</p>\n<p>判断扫码环境的原理就是根据打开链接浏览器的 HTTP header。任何浏览器打开 http 链接时，请求的 header 都会有 User-Agent(UA、用户代理)信息。</p>\n<p>UA 是一个特殊字符串头，服务器依次可以识别出客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等很多信息。</p>\n<p>各渠道对应支付产品的名称不一样，一定要仔细看各支付产品的 API 介绍。</p>\n<ol>\n<li>微信支付：JSAPI 支付支付</li>\n<li>支付宝：手机网站支付</li>\n<li>QQ 钱包：公众号支付</li>\n</ol>\n<p>其本质均为在 APP 内置浏览器中实现 HTML5 支付。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png\" alt=\"文库会员支付示例\" tabindex=\"0\"><figcaption>文库会员支付示例</figcaption></figure>\n<p>文库的研发同学在这个思路上，做了优化迭代。动态生成一码付的二维码预先绑定用户所选的商品信息和价格，根据用户所选的商品动态更新。这样不仅支持一码多平台调起支付，而且不用用户选择商品输入金额，即可完成订单支付的功能，很丝滑。用户在真正扫码后，服务端才通过前端获取用户 UID，结合二维码绑定的商品信息，真正的生成订单，发送支付信息到第三方（qq、微信、支付宝），第三方生成支付订单推给用户设备，从而调起支付。</p>\n<p>区别于固定的一码付，在文库的应用中，使用到了动态二维码，二维码本质是一个短网址，ID 服务提供短网址的唯一标志参数。唯一的短网址映射的 ID 绑定了商品的订单信息，技术和业务的深度结合，缩短了支付流程，提升用户的支付体验。</p>\n<h3> 2、订单号</h3>\n<p>订单号在实际的业务过程中作为一个订单的唯一标识码存在，一般实现以下业务场景：</p>\n<ol>\n<li>用户订单遇到问题，需要找客服进行协助；</li>\n<li>对订单进行操作，如线下收款，订单核销；</li>\n<li>下单，改单，成单，退单，售后等系统内部的订单流程处理和跟进。</li>\n</ol>\n<p>很多时候搜索订单相关信息的时候都是以订单 ID 作为唯一标识符，这是由于订单号的生成规则的唯一性决定的。从技术角度看，除了 ID 服务必要的特性之外，在订单号的设计上需要体现几个特性：</p>\n<p><strong>（1）信息安全</strong></p>\n<p>编号不能透露公司的运营情况，比如日销、公司流水号等信息，以及商业信息和用户手机号，身份证等隐私信息。并且不能有明显的整体规律（可以有局部规律），任意修改一个字符就能查询到另一个订单信息，这也是不允许的。</p>\n<p>类比于我们高考时候的考生编号的生成规则，一定不能是连号的，否则只需要根据顺序往下查询就能搜索到别的考生的成绩，这是绝对不可允许。</p>\n<p><strong>（2）部分可读</strong></p>\n<p>位数要便于操作，因此要求订单号的位数适中，且局部有规律。这样可以方便在订单异常，或者退货时客服查询。</p>\n<p>过长的订单号或易读性差的订单号会导致客服输入困难且易错率较高，影响用户体验的售后体验。因此在实际的业务场景中，订单号的设计通常都会适当携带一些允许公开的对使用场景有帮助的信息，如时间，星期，类型等等，这个主要根据所涉及的编号对应的使用场景来。</p>\n<p>而且像时间、星期这些自增长的属于作为订单号的设计的一部分元素，有助于解决业务累积而导致的订单号重复的问题。</p>\n<p><strong>（3）查询效率</strong></p>\n<p>常见的电商平台订单号大多是纯数字组成，兼具可读性的同时，int 类型相对 varchar 类型的查询效率更高，对在线业务更加友好。</p>\n<h3> 3、优惠券和兑换券</h3>\n<p>优惠券、兑换券是运营推广最常用的促销工具之一，合理使用它们，可以让买家得到实惠，商家提升商品销量。常见场景有：</p>\n<ol>\n<li>在文库购买【文库 VIP+QQ 音乐年卡】联合商品，支付成功后会得到 QQ 音乐年卡的兑换码，可以去 QQ 音乐 App 兑换音乐会员年卡；</li>\n<li>疫情期间，部分地方政府发放的消费券；</li>\n<li>瓶装饮料经常会出现输入优惠编码兑换奖品。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-coupon.png\" alt=\"优惠编码兑换奖品\" tabindex=\"0\"><figcaption>优惠编码兑换奖品</figcaption></figure>\n<p>从技术角度看，有些场景适合 ID 即时生成，比如电商平台购物领取的优惠券，只需要在用户领取时分配优惠券信息即可。有些线上线下结合的场景，比如疫情优惠券，瓶盖开奖，京东卡，超市卡这种，则需要预先生成，预先生成的券码具备以下特性：</p>\n<p>1.预先生成，在活动正式开始前提供出来进行活动预热；</p>\n<p>2.优惠券体量大，以万为单位，通常在 10 万级别以上；</p>\n<p>3.不可破解、仿制券码；</p>\n<p>4.支持用后核销；</p>\n<p>5.优惠券、兑换券属于广撒网的策略，所以利用率低，也就不适合使用数据库进行存储 <strong>（占空间，有效的数据又少）</strong>。</p>\n<p>设计思路上，需要设计一种有效的兑换码生成策略，支持预先生成，支持校验，内容简洁，生成的兑换码都具有唯一性，那么这种策略就是一种特殊的编解码策略，按照约定的编解码规则支撑上述需求。</p>\n<p>既然是一种编解码规则，那么需要约定编码空间(也就是用户看到的组成兑换码的字符)，编码空间由字符 a-z,A-Z,数字 0-9 组成，为了增强兑换码的可识别度，剔除大写字母 O 以及 I,可用字符如下所示，共 60 个字符：</p>\n<p>abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXZY0123456789</p>\n<p>之前说过，兑换码要求近可能简洁，那么设计时就需要考虑兑换码的字符数，假设上限为 12 位，而字符空间有 60 位，那么可以表示的空间范围为 60^12=130606940160000000000000(也就是可以 12 位的兑换码可以生成天量,应该够运营同学挥霍了)，转换成 2 进制：</p>\n<p>1001000100000000101110011001101101110011000000000000000000000(61 位)</p>\n<p><strong>兑换码组成成分分析</strong></p>\n<p>兑换码可以预先生成，并且不需要额外的存储空间保存这些信息，每一个优惠方案都有独立的一组兑换码(指运营同学组织的每一场运营活动都有不同的兑换码,不能混合使用, 例如双 11 兑换码不能使用在双 12 活动上)，每个兑换码有自己的编号，防止重复，为了保证兑换码的有效性，对兑换码的数据需要进行校验，当前兑换码的数据组成如下所示：</p>\n<p>优惠方案 ID + 兑换码序列号 i + 校验码</p>\n<p><strong>编码方案</strong></p>\n<ol>\n<li>兑换码序列号 i，代表当前兑换码是当前活动中第 i 个兑换码，兑换码序列号的空间范围决定了优惠活动可以发行的兑换码数目，当前采用 30 位 bit 位表示，可表示范围：1073741824（10 亿个券码）。</li>\n<li>优惠方案 ID, 代表当前优惠方案的 ID 号，优惠方案的空间范围决定了可以组织的优惠活动次数，当前采用 15 位表示，可以表示范围：32768（考虑到运营活动的频率，以及 ID 的初始值 10000，15 位足够，365 天每天有运营活动，可以使用 54 年）。</li>\n<li>校验码，校验兑换码是否有效，主要为了快捷的校验兑换码信息的是否正确，其次可以起到填充数据的目的，增强数据的散列性，使用 13 位表示校验位，其中分为两部分，前 6 位和后 7 位。</li>\n</ol>\n<p>深耕业务还会有区分通用券和单独券的情况，分别具备以下特点，技术实现需要因地制宜地思考。</p>\n<ol>\n<li>通用券：多个玩家都可以输入兑换，然后有总量限制，期限限制。</li>\n<li>单独券：运营同学可以在后台设置兑换码的奖励物品、期限、个数，然后由后台生成兑换码的列表，兑换之后核销。</li>\n</ol>\n<h2> 场景二：Tracing</h2>\n<h3> 1、日志跟踪</h3>\n<p>在分布式服务架构下，一个 Web 请求从网关流入，有可能会调用多个服务对请求进行处理，拿到最终结果。这个过程中每个服务之间的通信又是单独的网络请求，无论请求经过的哪个服务出了故障或者处理过慢都会对前端造成影响。</p>\n<p>处理一个 Web 请求要调用的多个服务，为了能更方便的查询哪个环节的服务出现了问题，现在常用的解决方案是为整个系统引入分布式链路跟踪。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-tracing.png\" alt=\"在分布式链路跟踪\" tabindex=\"0\"><figcaption>在分布式链路跟踪</figcaption></figure>\n<p>在分布式链路跟踪中有两个重要的概念：跟踪（trace）和 跨度（ span)。trace 是请求在分布式系统中的整个链路视图，span 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。</p>\n<p>在整个请求的调用链中，请求会一直携带 traceid 往下游服务传递，每个服务内部也会生成自己的 spanid 用于生成自己的内部调用视图，并和 traceid 一起传递给下游服务。</p>\n<h3> 2、TraceId 生成规则</h3>\n<p>这种场景下，生成的 ID 除了要求唯一之外，还要求生成的效率高、吞吐量大。traceid 需要具备接入层的服务器实例自主生成的能力，如果每个 trace 中的 ID 都需要请求公共的 ID 服务生成，纯纯的浪费网络带宽资源。且会阻塞用户请求向下游传递，响应耗时上升，增加了没必要的风险。所以需要服务器实例最好可以自行计算 tracid，spanid，避免依赖外部服务。</p>\n<p>产生规则：服务器 IP + ID 产生的时间 + 自增序列 + 当前进程号 ，比如：</p>\n<p>0ad1348f1403169275002100356696</p>\n<p>前 8 位 0ad1348f 即产生 TraceId 的机器的 IP，这是一个十六进制的数字，每两位代表 IP 中的一段，我们把这个数字，按每两位转成 10 进制即可得到常见的 IP 地址表示方式 10.209.52.143，您也可以根据这个规律来查找到请求经过的第一个服务器。</p>\n<p>后面的 13 位 1403169275002 是产生 TraceId 的时间。之后的 4 位 1003 是一个自增的序列，从 1000 涨到 9000，到达 9000 后回到 1000 再开始往上涨。最后的 5 位 56696 是当前的进程 ID，为了防止单机多进程出现 TraceId 冲突的情况，所以在 TraceId 末尾添加了当前的进程 ID。</p>\n<h3> 3、SpanId 生成规则</h3>\n<p>span 是层的意思，比如在第一个实例算是第一层， 请求代理或者分流到下一个实例处理，就是第二层，以此类推。通过层，SpanId 代表本次调用在整个调用链路树中的位置。</p>\n<p>假设一个 服务器实例 A 接收了一次用户请求，代表是整个调用的根节点，那么 A 层处理这次请求产生的非服务调用日志记录 spanid 的值都是 0，A 层需要通过 RPC 依次调用 B、C、D 三个服务器实例，那么在 A 的日志中，SpanId 分别是 0.1，0.2 和 0.3，在 B、C、D 中，SpanId 也分别是 0.1，0.2 和 0.3；如果 C 系统在处理请求的时候又调用了 E，F 两个服务器实例，那么 C 系统中对应的 spanid 是 0.2.1 和 0.2.2，E、F 两个系统对应的日志也是 0.2.1 和 0.2.2。</p>\n<p>根据上面的描述可以知道，如果把一次调用中所有的 SpanId 收集起来，可以组成一棵完整的链路树。</p>\n<p><strong>spanid 的生成本质：在跨层传递透传的同时，控制大小版本号的自增来实现的。</strong></p>\n<h2> 场景三：短网址</h2>\n<p>短网址主要功能包括网址缩短与还原两大功能。相对于长网址，短网址可以更方便地在电子邮件，社交网络，微博和手机上传播，例如原来很长的网址通过短网址服务即可生成相应的短网址，避免折行或超出字符限制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-short-url.png\" alt=\"短网址作用\" tabindex=\"0\"><figcaption>短网址作用</figcaption></figure>\n<p>常用的 ID 生成服务比如：MySQL ID 自增、 Redis 键自增、号段模式，生成的 ID 都是一串数字。短网址服务把客户的长网址转换成短网址，</p>\n<p>实际是在 <a href=\"http://dwz.cn\" target=\"_blank\" rel=\"noopener noreferrer\">dwz.cn</a> 域名后面拼接新产生的数字类型 ID，直接用数字 ID，网址长度也有些长，服务可以通过数字 ID 转更高进制的方式压缩长度。这种算法在短网址的技术实现上越来越多了起来，它可以进一步压缩网址长度。转进制的压缩算法在生活中有广泛的应用场景，举例：</p>\n<ul>\n<li>客户的长网址：<a href=\"https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner\" target=\"_blank\" rel=\"noopener noreferrer\">https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner</a></li>\n<li>ID 映射的短网址：<a href=\"https://dwz.cn/2047601319t66\" target=\"_blank\" rel=\"noopener noreferrer\">https://dwz.cn/2047601319t66</a> (演示使用，可能无法正确打开)</li>\n<li>转进制后的短网址：<a href=\"https://dwz.cn/2ezwDJ0\" target=\"_blank\" rel=\"noopener noreferrer\">https://dwz.cn/2ezwDJ0</a> (演示使用，可能无法正确打开)</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png",
      "date_published": "2023-05-05T02:23:30.000Z",
      "date_modified": "2023-08-21T08:51:05.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Spring Cloud Gateway常见问题总结",
      "url": "https://javaguide.cn/distributed-system/spring-cloud-gateway-questions.html",
      "id": "https://javaguide.cn/distributed-system/spring-cloud-gateway-questions.html",
      "summary": "本文重构完善自6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构这篇文章。 什么是 Spring Cloud Gateway？ Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 Zuul。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。",
      "content_html": "<blockquote>\n<p>本文重构完善自<a href=\"https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw\" target=\"_blank\" rel=\"noopener noreferrer\">6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构</a>这篇文章。</p>\n</blockquote>\n<h2> 什么是 Spring Cloud Gateway？</h2>\n<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>\n<p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway- demo.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>\n<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>\n<ul>\n<li>GitHub 地址： <a href=\"https://github.com/spring-cloud/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/spring-cloud/spring-cloud-gateway</a></li>\n<li>官网： <a href=\"https://spring.io/projects/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/projects/spring-cloud-gateway</a></li>\n</ul>\n<h2> Spring Cloud Gateway 的工作流程？</h2>\n<p>Spring Cloud Gateway 的工作流程如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-workflow.png\" alt=\"Spring Cloud Gateway 的工作流程\" tabindex=\"0\"><figcaption>Spring Cloud Gateway 的工作流程</figcaption></figure>\n<p>这是 Spring 官方博客中的一张图，原文地址：<a href=\"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a>。</p>\n<p>具体的流程分析：</p>\n<ol>\n<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>\n<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。</li>\n<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>\n<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。</li>\n<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>\n</ol>\n<p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p>\n<h2> Spring Cloud Gateway 的断言是什么？</h2>\n<p>断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。</p>\n<p>在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。</p>\n<p>断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 <code>api/thirdparty</code>，就匹配到了第一个路由 <code>route_thirdparty</code>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-example.png\" alt=\"断言配置示例\" tabindex=\"0\"><figcaption>断言配置示例</figcaption></figure>\n<p>常见的路由断言规则如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png\" alt=\"Spring Cloud GateWay 路由断言规则\" tabindex=\"0\"><figcaption>Spring Cloud GateWay 路由断言规则</figcaption></figure>\n<h2> Spring Cloud Gateway 的路由和断言是什么关系？</h2>\n<p>Route 路由和 Predicate 断言的对应关系如下：：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-route.png\" alt=\"路由和断言的对应关系\" tabindex=\"0\"><figcaption>路由和断言的对应关系</figcaption></figure>\n<ul>\n<li><strong>一对多</strong>：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。</li>\n<li><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</li>\n<li><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。</li>\n</ul>\n<h2> Spring Cloud Gateway 如何实现动态路由？</h2>\n<p>在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。</p>\n<p>Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。</p>\n<p>实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 注册中心来做。 Spring Cloud Gateway 可以从注册中心获取服务的元数据（例如服务名称、路径等），然后根据这些信息自动生成路由规则。这样，当你添加、移除或更新服务实例时，网关会自动感知并相应地调整路由规则，无需手动维护路由配置。</p>\n<p>其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址：<a href=\"https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a> 。</p>\n<h2> Spring Cloud Gateway 的过滤器有哪些？</h2>\n<p>过滤器 Filter 按照请求和响应可以分为两种：</p>\n<ul>\n<li><strong>Pre 类型</strong>：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</li>\n<li><strong>Post 类型</strong>：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。</li>\n</ul>\n<p>另外一种分类是按照过滤器 Filter 作用的范围进行划分：</p>\n<ul>\n<li><strong>GatewayFilter</strong>：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</li>\n<li><strong>GlobalFilter</strong>：全局过滤器，应用在所有路由上的过滤器。</li>\n</ul>\n<h3> 局部过滤器</h3>\n<p>常见的局部过滤器如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然我们也可以自定义过滤器，本篇不做展开。</p>\n<h3> 全局过滤器</h3>\n<p>常见的全局过滤器如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>全局过滤器最常见的用法是进行负载均衡。配置如下所示：</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里有个关键字 <code>lb</code>，用到了全局过滤器 <code>LoadBalancerClientFilter</code>，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。</p>\n<h2> Spring Cloud Gateway 支持限流吗？</h2>\n<p>Spring Cloud Gateway 自带了限流过滤器，对应的接口是 <code>RateLimiter</code>，<code>RateLimiter</code> 接口只有一个实现类 <code>RedisRateLimiter</code> （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。</p>\n<p>从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。</p>\n<h2> Spring Cloud Gateway 如何自定义全局异常处理？</h2>\n<p>在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 <code>@RestControllerAdvice</code>和 <code>@ExceptionHandler</code>就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。</p>\n<p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现<code>ErrorWebExceptionHandler</code>并重写其中的<code>handle</code>方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>Spring Cloud Gateway 官方文档：<a href=\"https://cloud.spring.io/spring-cloud-gateway/reference/html/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.spring.io/spring-cloud-gateway/reference/html/</a></li>\n<li>Creating a custom Spring Cloud Gateway Filter：<a href=\"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a></li>\n<li>全局异常处理: <a href=\"https://zhuanlan.zhihu.com/p/347028665\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/347028665</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png",
      "date_published": "2023-05-04T10:53:24.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Disruptor常见问题总结",
      "url": "https://javaguide.cn/high-performance/message-queue/disruptor-questions.html",
      "id": "https://javaguide.cn/high-performance/message-queue/disruptor-questions.html",
      "summary": "Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。 一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！ 。",
      "content_html": "<p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。</p>\n<p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：<a href=\"https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A\" target=\"_blank\" rel=\"noopener noreferrer\">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。</p>\n<h2> Disruptor 是什么？</h2>\n<p>Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。</p>\n<p>根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 <a href=\"https://martinfowler.com/articles/lmax.html\" target=\"_blank\" rel=\"noopener noreferrer\">The LMAX Architecture</a> 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。</p>\n<p>LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke's Choice Awards(Duke 选择大奖)。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！</p>\n</blockquote>\n<p>我专门找到了 Oracle 官方当年颁布获得 Duke's Choice Awards 项目的那篇文章（文章地址：<a href=\"https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award%EF%BC%89\" target=\"_blank\" rel=\"noopener noreferrer\">https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award）</a> 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20211015152323898.png\" alt=\"2011 年的 Oracle 官方的 Duke's Choice Awards\" tabindex=\"0\"><figcaption>2011 年的 Oracle 官方的 Duke's Choice Awards</figcaption></figure>\n<p>Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。</p>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/LMAX-Exchange/disruptor\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/LMAX-Exchange/disruptor</a></li>\n<li>官方教程： <a href=\"https://lmax-exchange.github.io/disruptor/user-guide/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a></li>\n</ul>\n<p>关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章：<a href=\"https://mp.weixin.qq.com/s/0iG5brK3bYF0BgSjX4jRiA\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot + Disruptor 实战入门</a> 。</p>\n<h2> 为什么要用 Disruptor？</h2>\n<p>Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。</p>\n<p><strong>JDK 中常见的线程安全的队列如下</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>队列名字</th>\n<th>锁</th>\n<th>是否有界</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ArrayBlockingQueue</code></td>\n<td>加锁（<code>ReentrantLock</code>）</td>\n<td>有界</td>\n</tr>\n<tr>\n<td><code>LinkedBlockingQueue</code></td>\n<td>加锁（<code>ReentrantLock</code>）</td>\n<td>有界</td>\n</tr>\n<tr>\n<td><code>LinkedTransferQueue</code></td>\n<td>无锁（<code>CAS</code>）</td>\n<td>无界</td>\n</tr>\n<tr>\n<td><code>ConcurrentLinkedQueue</code></td>\n<td>无锁（<code>CAS</code>）</td>\n<td>无界</td>\n</tr>\n</tbody>\n</table>\n<p>从上表中可以看出：这些队列要不就是加锁有界，要不就是无锁无界。而加锁的的队列势必会影响性能，无界的队列又存在内存溢出的风险。</p>\n<p>因此，一般情况下，我们都是不建议使用 JDK 内置线程安全队列。</p>\n<p><strong>Disruptor 就不一样了！它在无锁的情况下还能保证队列有界，并且还是线程安全的。</strong></p>\n<p>下面这张图是 Disruptor 官网提供的 Disruptor 和 ArrayBlockingQueue 的延迟直方图对比。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-latency-histogram.png\" alt=\"disruptor-latency-histogram\" tabindex=\"0\"><figcaption>disruptor-latency-histogram</figcaption></figure>\n<p>Disruptor 真的很快，关于它为什么这么快这个问题，会在后文介绍到。</p>\n<p>此外，Disruptor 还提供了丰富的扩展功能比如支持批量操作、支持多种等待策略。</p>\n<h2> Kafka 和 Disruptor 什么区别？</h2>\n<ul>\n<li><strong>Kafka</strong>：分布式消息队列，一般用在系统或者服务之间的消息传递，还可以被用作流式处理平台。</li>\n<li><strong>Disruptor</strong>：内存级别的消息队列，一般用在系统内部中线程间的消息传递。</li>\n</ul>\n<h2> 哪些组件用到了 Disruptor？</h2>\n<p>用到 Disruptor 的开源项目还是挺多的，这里简单举几个例子：</p>\n<ul>\n<li><strong>Log4j2</strong>：Log4j2 是一款常用的日志框架，它基于 Disruptor 来实现异步日志。</li>\n<li><strong>SOFATracer</strong>：SOFATracer 是蚂蚁金服开源的分布式应用链路追踪工具，它基于 Disruptor 来实现异步日志。</li>\n<li><strong>Storm</strong> : Storm 是一个开源的分布式实时计算系统，它基于 Disruptor 来实现工作进程内发生的消息传递（同一 Storm 节点上的线程间，无需网络通信）。</li>\n<li><strong>HBase</strong>：HBase 是一个分布式列存储数据库系统，它基于 Disruptor 来提高写并发性能。</li>\n<li>……</li>\n</ul>\n<h2> Disruptor 核心概念有哪些？</h2>\n<ul>\n<li><strong>Event</strong>：你可以把 Event 理解为存放在队列中等待消费的消息对象。</li>\n<li><strong>EventFactory</strong>：事件工厂用于生产事件，我们在初始化 <code>Disruptor</code> 类的时候需要用到。</li>\n<li><strong>EventHandler</strong>：Event 在对应的 Handler 中被处理，你可以将其理解为生产消费者模型中的消费者。</li>\n<li><strong>EventProcessor</strong>：EventProcessor 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。</li>\n<li><strong>Disruptor</strong>：事件的生产和消费需要用到 <code>Disruptor</code> 对象。</li>\n<li><strong>RingBuffer</strong>：RingBuffer（环形数组）用于保存事件。</li>\n<li><strong>WaitStrategy</strong>：等待策略。决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。</li>\n<li><strong>Producer</strong>：生产者，只是泛指调用 <code>Disruptor</code> 对象发布事件的用户代码，Disruptor 没有定义特定接口或类型。</li>\n<li><strong>ProducerType</strong>：指定是单个事件发布者模式还是多个事件发布者模式（发布者和生产者的意思类似，我个人比较喜欢用发布者）。</li>\n<li><strong>Sequencer</strong>：Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 <code>SingleProducerSequencer</code>、<code>MultiProducerSequencer</code> ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。</li>\n</ul>\n<p>下面这张图摘自 Disruptor 官网，展示了 LMAX 系统使用 Disruptor 的示例。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-models.png\" alt=\"LMAX 系统使用 Disruptor 的示例\" tabindex=\"0\"><figcaption>LMAX 系统使用 Disruptor 的示例</figcaption></figure>\n<h2> Disruptor 等待策略有哪些？</h2>\n<p><strong>等待策略（WaitStrategy）</strong> 决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。</p>\n<p>常见的等待策略有下面这些：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/DisruptorWaitStrategy.png\" alt=\"Disruptor 等待策略\" tabindex=\"0\"><figcaption>Disruptor 等待策略</figcaption></figure>\n<ul>\n<li><code>BlockingWaitStrategy</code>：基于 <code>ReentrantLock</code>+<code>Condition</code> 来实现等待和唤醒操作，实现代码非常简单，是 Disruptor 默认的等待策略。虽然最慢，但也是 CPU 使用率最低和最稳定的选项生产环境推荐使用；</li>\n<li><code>BusySpinWaitStrategy</code>：性能很好，存在持续自旋的风险，使用不当会造成 CPU 负载 100%，慎用；</li>\n<li><code>LiteBlockingWaitStrategy</code>：基于 <code>BlockingWaitStrategy</code> 的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用;</li>\n<li><code>TimeoutBlockingWaitStrategy</code>：带超时的等待策略，超时后会执行业务指定的处理逻辑;</li>\n<li><code>LiteTimeoutBlockingWaitStrategy</code>：基于<code>TimeoutBlockingWaitStrategy</code>的策略，当没有锁竞争的时候会省去唤醒操作;</li>\n<li><code>SleepingWaitStrategy</code>：三段式策略，第一阶段自旋，第二阶段执行 Thread.yield 让出 CPU，第三阶段睡眠执行时间，反复的睡眠；</li>\n<li><code>YieldingWaitStrategy</code>：二段式策略，第一阶段自旋，第二阶段执行 Thread.yield 交出 CPU;</li>\n<li><code>PhasedBackoffWaitStrategy</code>：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行 <code>Thread.yield</code> 交出 CPU，第四阶段调用成员变量的<code>waitFor</code>方法，该成员变量可以被设置为<code>BlockingWaitStrategy</code>、<code>LiteBlockingWaitStrategy</code>、<code>SleepingWaitStrategy</code>三个中的一个。</li>\n</ul>\n<h2> Disruptor 为什么这么快？</h2>\n<ul>\n<li><strong>RingBuffer（环形数组）</strong> : Disruptor 内部的 RingBuffer 是通过数组实现的。由于这个数组中的所有元素在初始化时一次性全部创建，因此这些元素的内存地址一般来说是连续的。这样做的好处是，当生产者不断往 RingBuffer 中插入新的事件对象时，这些事件对象的内存地址就能够保持连续，从而利用 CPU 缓存的局部性原理，将相邻的事件对象一起加载到缓存中，提高程序的性能。这类似于 MySQL 的预读机制，将连续的几个页预读到内存里。除此之外，RingBuffer 基于数组还支持批量操作（一次处理多个元素）、还可以避免频繁的内存分配和垃圾回收（RingBuffer 是一个固定大小的数组，当向数组中添加新元素时，如果数组已满，则新元素将覆盖掉最旧的元素）。</li>\n<li><strong>避免了伪共享问题</strong>：CPU 缓存内部是按照 Cache Line（缓存行）管理的，一般的 Cache Line 大小在 64 字节左右。Disruptor 为了确保目标字段独占一个 Cache Line，会在目标字段前后增加了 64 个字节的填充（前 56 个字节和后 8 个字节），这样可以避免 Cache Line 的伪共享（False Sharing）问题。</li>\n<li><strong>无锁设计</strong>：Disruptor 采用无锁设计，避免了传统锁机制带来的竞争和延迟。Disruptor 的无锁实现起来比较复杂，主要是基于 CAS、内存屏障（Memory Barrier）、RingBuffer 等技术实现的。</li>\n</ul>\n<p>综上所述，Disruptor 之所以能够如此快，是基于一系列优化策略的综合作用，既充分利用了现代 CPU 缓存结构的特点，又避免了常见的并发问题和性能瓶颈。</p>\n<p>关于 Disruptor 高性能队列原理的详细介绍，可以查看这篇文章：<a href=\"https://qin.news/disruptor/\" target=\"_blank\" rel=\"noopener noreferrer\">Disruptor 高性能队列原理浅析</a> （参考了美团技术团队的<a href=\"https://tech.meituan.com/2016/11/18/disruptor.html\" target=\"_blank\" rel=\"noopener noreferrer\">高性能队列——Disruptor</a>这篇文章）。</p>\n<p>🌈 这里额外补充一点：<strong>数组中对象元素地址连续为什么可以提高性能？</strong></p>\n<p>CPU 缓存是通过将最近使用的数据存储在高速缓存中来实现更快的读取速度，并使用预取机制提前加载相邻内存的数据以利用局部性原理。</p>\n<p>在计算机系统中，CPU 主要访问高速缓存和内存。高速缓存是一种速度非常快、容量相对较小的内存，通常被分为多级缓存，其中 L1、L2、L3 分别表示一级缓存、二级缓存、三级缓存。越靠近 CPU 的缓存，速度越快，容量也越小。相比之下，内存容量相对较大，但速度较慢。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png\" alt=\"CPU 缓存模型示意图\" tabindex=\"0\"><figcaption>CPU 缓存模型示意图</figcaption></figure>\n<p>为了加速数据的读取过程，CPU 会先将数据从内存中加载到高速缓存中，如果下一次需要访问相同的数据，就可以直接从高速缓存中读取，而不需要再次访问内存。这就是所谓的 <strong>缓存命中</strong> 。另外，为了利用 <strong>局部性原理</strong> ，CPU 还会根据之前访问的内存地址预取相邻的内存数据，因为在程序中，连续的内存地址通常会被频繁访问到，这样做可以提高数据的缓存命中率，进而提高程序的性能。</p>\n<h2> 参考</h2>\n<ul>\n<li>Disruptor 高性能之道-等待策略：&lt;<a href=\"http://wuwenliang.net/2022/02/28/Disruptor\" target=\"_blank\" rel=\"noopener noreferrer\">http://wuwenliang.net/2022/02/28/Disruptor</a> 高性能之道-等待策略/&gt;</li>\n<li>《Java 并发编程实战》- 40 | 案例分析（三）：高性能队列 Disruptor：<a href=\"https://time.geekbang.org/column/article/98134\" target=\"_blank\" rel=\"noopener noreferrer\">https://time.geekbang.org/column/article/98134</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png",
      "date_published": "2023-05-04T10:53:24.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "NAT 协议详解（网络层）",
      "url": "https://javaguide.cn/cs-basics/network/nat.html",
      "id": "https://javaguide.cn/cs-basics/network/nat.html",
      "summary": "应用场景 NAT 协议（Network Address Translation） 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。 这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。",
      "content_html": "<h2> 应用场景</h2>\n<p><strong>NAT 协议（Network Address Translation）</strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p>\n<p>这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。</p>\n<p>SOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。</p>\n<h2> 细节</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo.png\" alt=\"NAT 协议\" tabindex=\"0\"><figcaption>NAT 协议</figcaption></figure>\n<p>假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为<code>10.0.0/24</code>。LAN 侧接口的 IP 地址为<code>10.0.0.4</code>，并且该子网内有至少三台主机，分别是<code>10.0.0.1</code>，<code>10.0.0.2</code>和<code>10.0.0.3</code>。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为<code>138.76.29.7</code>。</p>\n<p>首先，针对以上信息，我们有如下事实需要说明：</p>\n<ol>\n<li>路由器的右侧子网的网络号为<code>10.0.0/24</code>，主机号为<code>10.0.0/8</code>，三台主机地址，以及路由器的 LAN 侧接口地址，均由 DHCP 协议规定。而且，该 DHCP 运行在路由器内部（路由器自维护一个小 DHCP 服务器），从而为子网内提供 DHCP 服务。</li>\n<li>路由器的 WAN 侧接口地址同样由 DHCP 协议规定，但该地址是路由器从 ISP（网络服务提供商）处获得，也就是该 DHCP 通常运行在路由器所在区域的 DHCP 服务器上。</li>\n</ol>\n<p>现在，路由器内部还运行着 NAT 协议，从而为 LAN-WAN 间通信提供地址转换服务。为此，一个很重要的结构是 <strong>NAT 转换表</strong>。为了说明 NAT 的运行细节，假设有以下请求发生：</p>\n<ol>\n<li>主机<code>10.0.0.1</code>向 IP 地址为<code>128.119.40.186</code>的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机<code>10.0.0.1</code>将随机指派一个端口，如<code>3345</code>，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是<code>128.119.40.186</code>，但会先到达<code>10.0.0.4</code>）。</li>\n<li><code>10.0.0.4</code>即路由器的 LAN 接口收到<code>10.0.0.1</code>的请求。路由器将为该请求指派一个新的源端口号，如<code>5001</code>，并将请求报文发送给 WAN 接口<code>138.76.29.7</code>。同时，在 NAT 转换表中记录一条转换记录<strong>138.76.29.7:5001——10.0.0.1:3345</strong>。</li>\n<li>请求报文到达 WAN 接口，继续向目的主机<code>128.119.40.186</code>发送。</li>\n</ol>\n<p>之后，将会有如下响应发生：</p>\n<ol>\n<li>主机<code>128.119.40.186</code>收到请求，构造响应报文，并将其发送给目的地<code>138.76.29.7:5001</code>。</li>\n<li>响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现<code>138.76.29.7:5001</code>在转换表中有记录，从而将其目的地址和目的端口转换成为<code>10.0.0.1:3345</code>，再发送到<code>10.0.0.4</code>上。</li>\n<li>被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地<code>10.0.0.1</code>。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo2.png\" alt=\"LAN-WAN 间通信提供地址转换\" tabindex=\"0\"><figcaption>LAN-WAN 间通信提供地址转换</figcaption></figure>\n<p>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/2009\" target=\"_blank\" rel=\"noopener noreferrer\">issue#2009</a>）：上图第四步的 Dest 值应该为 <code>10.0.0.1:3345</code> 而不是~~<code>138.76.29.7:5001</code>~~，这里笔误了。</p>\n<h2> 划重点</h2>\n<p>针对以上过程，有以下几个重点需要强调：</p>\n<ol>\n<li>当请求报文到达路由器，并被指定了新端口号时，由于端口号有 16 位，因此，通常来说，一个路由器管理的 LAN 中的最大主机数 （ 的地址空间），但通常 SOHO 子网内不会有如此多的主机数量。</li>\n<li>对于目的服务器来说，从来不知道“到底是哪个主机给我发送的请求”，它只知道是来自<code>138.76.29.7:5001</code>的路由器转发的请求。因此，可以说，**路由器在 WAN 和 LAN 之间起到了屏蔽作用，**所有内部主机发送到外部的报文，都具有同一个 IP 地址（不同的端口号），所有外部发送到内部的报文，也都只有一个目的地（不同端口号），是经过了 NAT 转换后，外部报文才得以正确地送达内部主机。</li>\n<li>在报文穿过路由器，发生 NAT 转换时，如果 LAN 主机 IP 已经在 NAT 转换表中注册过了，则不需要路由器新指派端口，而是直接按照转换记录穿过路由器。同理，外部报文发送至内部时也如此。</li>\n</ol>\n<p>总结 NAT 协议的特点，有以下几点：</p>\n<ol>\n<li>NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。</li>\n<li>LAN 主机 IP 地址的变更，无需通告 WAN。</li>\n<li>WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。</li>\n<li>LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。</li>\n</ol>\n<p>然而，NAT 协议由于其独特性，存在着一些争议。比如，可能你已经注意到了，**NAT 协议在 LAN 以外，标识一个内部主机时，使用的是端口号，因为 IP 地址都是相同的。**这种将端口号作为主机寻址的行为，可能会引发一些误会。此外，路由器作为网络层的设备，修改了传输层的分组内容（修改了源 IP 地址和端口号），同样是不规范的行为。但是，尽管如此，NAT 协议作为 IPv4 时代的产物，极大地方便了一些本来棘手的问题，一直被沿用至今。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo.png",
      "date_published": "2023-04-30T08:44:12.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "程序员简历编写指南(重要)",
      "url": "https://javaguide.cn/interview-preparation/resume-guide.html",
      "id": "https://javaguide.cn/interview-preparation/resume-guide.html",
      "summary": "友情提示 本文节选自 《Java 面试指北》。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。 前言 一份好的简历可以在整个申请面试以及面试过程中起到非常重要的作用。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">友情提示</p>\n<p>本文节选自 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。</p>\n</div>\n<h2> 前言</h2>\n<p>一份好的简历可以在整个申请面试以及面试过程中起到非常重要的作用。</p>\n<p><strong>为什么说简历很重要呢？</strong> 我们可以从下面几点来说：</p>\n<p><strong>1、简历就像是我们的一个门面一样，它在很大程度上决定了是否能够获得面试机会。</strong></p>\n<ul>\n<li>假如你是网申，你的简历必然会经过 HR 的筛选，一张简历 HR 可能也就花费 10 秒钟左右看一下，然后决定你能否进入面试。</li>\n<li>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</li>\n</ul>\n<p>另外，就算你通过了第一轮的筛选获得面试机会，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>\n<p><strong>2、简历上的内容很大程度上决定了面试官提问的侧重点。</strong></p>\n<ul>\n<li>一般情况下你的简历上注明你会的东西才会被问到（Java 基础、集合、并发、MySQL、Redis 、Spring、Spring Boot 这些算是每个人必问的），比如写了你熟练使用 Redis,那面试官就很大概率会问你 Redis 的一些问题，再比如你写了你在项目中使用了消息队列，那面试官大概率问很多消息队列相关的问题。</li>\n<li>技能熟练度在很大程度上也决定了面试官提问的深度。</li>\n</ul>\n<p>在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。一般情况下，技术能力和学习能力比较厉害的，写出来的简历也比较棒！</p>\n<h2> 简历模板</h2>\n<p>简历的样式真的非常非常重要！！！如果你的简历样式丑到没朋友的话，面试官真的没有看下去的欲望。一天处理上百份的简历的痛苦，你不懂！</p>\n<p>我这里的话，推荐大家使用 Markdown 语法写简历，然后再将 Markdown 格式转换为 PDF 格式后进行简历投递。如果你对 Markdown 语法不太了解的话，可以花半个小时简单看一下 Markdown 语法说明: <a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.markdown.cn/</a>。</p>\n<p>下面是我收集的一些还不错的简历模板：</p>\n<ul>\n<li>适合中文的简历模板收集（推荐，开源免费）：<a href=\"https://github.com/dyweb/awesome-resume-for-chinese\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/dyweb/awesome-resume-for-chinese</a></li>\n<li>木及简历（推荐，部分免费） ： <a href=\"https://www.mujicv.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mujicv.com/</a></li>\n<li>简单简历（推荐，部分免费）：<a href=\"https://easycv.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://easycv.cn/</a></li>\n<li>极简简历（免费）： <a href=\"https://www.polebrief.com/index\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.polebrief.com/index</a></li>\n<li>Markdown 简历排版工具（开源免费）：<a href=\"https://resume.mdnice.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://resume.mdnice.com/</a></li>\n<li>站长简历（收费，支持 AI 生成）：<a href=\"https://jianli.chinaz.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://jianli.chinaz.com/</a></li>\n<li>typora+markdown+css 自定义简历模板 ：<a href=\"https://github.com/Snailclimb/typora-markdown-resume\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/typora-markdown-resume</a></li>\n<li>超级简历（部分收费） ： <a href=\"https://www.wondercv.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.wondercv.com/</a></li>\n</ul>\n<p>上面这些简历模板大多是只有 1 页内容，很难展现足够的信息量。如果你不是顶级大牛（比如 ACM 大赛获奖）的话，我建议还是尽可能多写一点可以突出你自己能力的内容（校招生 2 页之内，社招生 3 页之内，记得精炼语言，不要过多废话）。</p>\n<p>再总结几点 <strong>简历排版的注意事项</strong>：</p>\n<ul>\n<li>尽量简洁，不要太花里胡哨。</li>\n<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>\n<li>中文和数字英文之间加上空格的话看起来会舒服一点。</li>\n</ul>\n<p>另外，知识星球里还有真实的简历模板可供参考，地址：<a href=\"https://t.zsxq.com/12ypxGNzU\" target=\"_blank\" rel=\"noopener noreferrer\">https://t.zsxq.com/12ypxGNzU</a> （需加入<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>获取）。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/image-20230918073550606.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 简历内容</h2>\n<h3> 个人信息</h3>\n<ul>\n<li>最基本的 ：姓名（身份证上的那个）、年龄、电话、籍贯、联系方式、邮箱地址</li>\n<li>潜在加分项 ： Github 地址、博客地址（如果技术博客和 Github 上没有什么内容的话，就不要写了）</li>\n</ul>\n<p>示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/20210428212337599.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>简历要不要放照片呢？</strong> 很多人写简历的时候都有这个问题。</p>\n<p>其实放不放都行，影响不大，完全不用在意这个问题。除非，你投递的岗位明确要求要放照片。 不过，如果要放的话，不要放生活照，还是应该放正规一些的照片比如证件照。</p>\n<h3> 求职意向</h3>\n<p>你想要应聘什么岗位，希望在什么城市。另外，你也可以将求职意向放到个人信息这块写。</p>\n<p>示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/20210428212410288.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 教育经历</h3>\n<p>教育经历也不可或缺。通过教育经历的介绍，你要确保能让面试官就可以知道你的学历、专业、毕业学校以及毕业的日期。</p>\n<p>示例：</p>\n<blockquote>\n<p>北京理工大学 硕士，软件工程 2019.09 - 2022.01<br>\n湖南大学 学士，应用化学 2015.09 ~ 2019.06</p>\n</blockquote>\n<h3> 专业技能</h3>\n<p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般 HR 可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。</p>\n<p>下面是一份最新的 Java 后端开发技能清单，你可以根据自身情况以及岗位招聘要求做动态调整，核心思想就是尽可能满足岗位招聘的所有技能要求。</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/jinengmuban.png\" alt=\"Java 后端技能模板\" tabindex=\"0\"><figcaption>Java 后端技能模板</figcaption></figure>\n<p>我这里再单独放一个我看过的某位同学的技能介绍，我们来找找问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/up-a58d644340f8ce5cd32f9963f003abe4233.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上图中的技能介绍存在的问题：</p>\n<ul>\n<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>\n<li>技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！</li>\n<li>对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。</li>\n</ul>\n<h3> 实习经历/工作经历（重要）</h3>\n<p>工作经历针对社招，实习经历针对校招。</p>\n<p>工作经历建议采用时间倒序的方式来介绍。实习经历和工作经历都需要简单突出介绍自己在职期间主要做了什么。</p>\n<p>示例：</p>\n<blockquote>\n<p><strong>XXX 公司 （201X 年 X 月 ~ 201X 年 X 月 ）</strong></p>\n<ul>\n<li><strong>职位</strong>：Java 后端开发工程师</li>\n<li><strong>工作内容</strong>：主要负责 XXX</li>\n</ul>\n</blockquote>\n<h3> 项目经历（重要）</h3>\n<p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。</p>\n<p>很多求职者的项目经历介绍都会面临过于啰嗦、过于简单、没突出亮点等问题。</p>\n<p>项目经历介绍模板如下：</p>\n<blockquote>\n<p>项目名称（字号要大一些）</p>\n<p>2017-05~2018-06 淘宝 Java 后端开发工程师</p>\n<ul>\n<li><strong>项目描述</strong> : 简单描述项目是做什么的。</li>\n<li><strong>技术栈</strong> ：用了什么技术（如 Spring Boot + MySQL + Redis + Mybatis-plus + Spring Security + Oauth2）</li>\n<li><strong>工作内容/个人职责</strong> : 简单描述自己做了什么，解决了什么问题，带来了什么实质性的改善。突出自己的能力，不要过于平淡的叙述。</li>\n<li><strong>个人收获（可选）</strong> : 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用。通常是可以不用写个人收获的，因为你在个人职责介绍中写的东西已经表明了自己的主要收获。</li>\n<li><strong>项目成果（可选）</strong> :简单描述这个项目取得了什么成绩。</li>\n</ul>\n</blockquote>\n<p><strong>1、项目经历应该突出自己做了什么，简单概括项目基本情况。</strong></p>\n<p>项目介绍尽量压缩在两行之内，不需要介绍太多，但也不要随便几个字就介绍完了。</p>\n<p>另外，个人收获和项目成果都是可选的，如果选择写的话，也不要花费太多篇幅，记住你的重点是介绍工作内容/个人职责。</p>\n<p><strong>2、技术架构直接写技术名词就行，不要再介绍技术是干嘛的了，没意义，属于无效介绍。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/interview-preparation/46c92fbc5160e65dd85c451143177144.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>3、尽量减少纯业务的个人职责介绍，对于面试不太友好。尽量再多挖掘一些亮点（6~8 条个人职责介绍差不多了，做好筛选），最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目优化了某个模块的性能。</strong></p>\n<p>即使不是你做的功能模块或者解决的问题，你只要搞懂吃透了就能拿来自己用，适当润色即可！</p>\n<p>像性能优化方向上的亮点面试之前也比较容易准备，但也不要都是性能优化相关的，这种也算是一个极端。</p>\n<p>另外，技术优化取得的成果尽量要量化一下：</p>\n<ul>\n<li>使用 xxx 技术解决了 xxx 问题，系统 QPS 从 xxx 提高到了 xxx。</li>\n<li>使用 xxx 技术了优化了 xxx 接口，系统 QPS 从 xxx 提高到了 xxx。</li>\n<li>使用 xxx 技术解决了 xxx 问题，查询速度优化了 xxx，系统 QPS 达到 10w+。</li>\n<li>使用 xxx 技术优化了 xxx 模块，响应时间从 2s 降低到 0.2s。</li>\n<li>……</li>\n</ul>\n<p>个人职责介绍示例 ：</p>\n<ul>\n<li>基于 Spring Cloud Gateway + Spring Security OAuth2 + JWT 实现微服务统一认证授权和鉴权，使用 RBAC 权限模型实现动态权限控制。</li>\n<li>参与项目订单模块的开发，负责订单创建、删除、查询等功能。</li>\n<li>整合 Canal + RocketMQ 将 MySQL 增量数据（如商品、订单数据）同步到 ES。</li>\n<li>排查并解决扣费模块由于扣费父任务和反作弊子任务使用同一个线程池导致的死锁问题。</li>\n<li>负责用户统计模块的开发，使用 CompletableFuture 并行加载后台用户统计模块的数据信息，平均相应时间从 3.5s 降低到 1s。</li>\n<li>使用 Sharding-JDBC 以用户 ID 后 4 位作为 Shard Key 对订单表进行分库分表，共 3 个库，每个库 2 个订单表，单表数据量保持在 500w 以下。自定义雪花算法生成订单 ID 的规则，把分片键同时作为的订单 ID 一部分，避免了额外存储订单 ID 与路由键的关系。</li>\n<li>热门数据（如首页、热门博客）使用 Redis+Caffeine 两级缓存，解决了缓存击穿和穿透问题，查询速度毫秒级，QPS 30w+。</li>\n<li>使用 CompletableFuture 优化购物车查询模块，对获取用户信息、商品详情、优惠券信息等异步 RPC 调用进行编排，响应时间从 2s 降低为 0.2s。</li>\n<li>搭建 EasyMock 服务，用于模拟第三方平台接口，方便了在网络隔离情况下的接口对接工作。</li>\n</ul>\n<p><strong>4、如果你觉得你的项目技术比较落后的话，可以自己私下进行改进。重要的是让项目比较有亮点，通过什么方式就无所谓了。</strong></p>\n<p>项目经历这部分对于简历来说非常重要，<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>的面试准备篇有好几篇关于优化项目经历的文章，建议你仔细阅读一下，应该会对你有帮助。</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/4e11dbc842054e53ad6c5f0445023eb5~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>5、避免个人职责介绍都是围绕一个技术点来写，非常不可取。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/image-20230424222513028.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>6、避免模糊性描述，介绍要具体（技术+场景+效果），也要注意精简语言（避免堆砌技术词，省略不必要的描述）。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/interview-preparation/project-experience-avoiding-ambiguity-descriptio.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 荣誉奖项（可选）</h3>\n<p>如果你有含金量比较高的竞赛（比如 ACM、阿里的天池大赛）的获奖经历的话，荣誉奖项这块内容一定要写一下！并且，你还可以将荣誉奖项这块内容适当往前放，放在一个更加显眼的位置。</p>\n<h3> 校园经历（可选）</h3>\n<p>如果有比较亮眼的校园经历的话就简单写一下，没有就不写！</p>\n<h3> 个人评价</h3>\n<p><strong>个人评价就是对自己的解读，一定要用简洁的语言突出自己的特点和优势，避免废话！</strong> 像勤奋、吃苦这些比较虚的东西就不要扯了，面试官看着这种个人评价就烦。</p>\n<p>我们可以从下面几个角度来写个人评价：</p>\n<ul>\n<li>文档编写能力、学习能力、沟通能力、团队协作能力</li>\n<li>对待工作的态度以及个人的责任心</li>\n<li>能承受的工作压力以及对待困难的态度</li>\n<li>对技术的追求、对代码质量的追求</li>\n<li>分布式、高并发系统开发或维护经验</li>\n</ul>\n<p>列举 3 个实际的例子：</p>\n<ul>\n<li>学习能力较强，大三参加国家软件设计大赛的时候快速上手 Python 写了一个可配置化的爬虫系统。</li>\n<li>具有团队协作精神，大三参加国家软件设计大赛的时候协调项目组内 5 名开发同学，并对编码遇到困难的同学提供帮助，最终顺利在 1 个月的时间完成项目的核心功能。</li>\n<li>项目经验丰富，在校期间主导过多个企业级项目的开发。</li>\n</ul>\n<h2> STAR 法则和 FAB 法则</h2>\n<h3> STAR 法则（Situation Task Action Result）</h3>\n<p>相信大家一定听说过 STAR 法则。对于面试，你可以将这个法则用在自己的简历以及和面试官沟通交流的过程中。</p>\n<p>STAR 法则由下面 4 个单词组成（STAR 法则的名字就是由它们的首字母组成）：</p>\n<ul>\n<li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？</li>\n<li><strong>Task：</strong> 任务。你的任务是什么？</li>\n<li><strong>Action：</strong> 行动。你做了什么？</li>\n<li><strong>Result：</strong> 结果。最终的结果怎样？</li>\n</ul>\n<h3> FAB 法则（Feature Advantage Benefit）</h3>\n<p>除了 STAR 法则，你还需要了解在销售行业经常用到的一个叫做 FAB 的法则。</p>\n<p>FAB 法则由下面 3 个单词组成（FAB 法则的名字就是由它们的首字母组成）：</p>\n<ul>\n<li><strong>Feature：</strong> 你的特征/优势是什么？</li>\n<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>\n<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>\n</ul>\n<p>简单来说，<strong>FAB 法则主要是让你的面试官知道你的优势和你能为公司带来的价值。</strong></p>\n<h2> 建议</h2>\n<h3> 避免页数过多</h3>\n<p>精简表述，突出亮点。校招简历建议不要超过 2 页，社招简历建议不要超过 3 页。如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</p>\n<p>看了几千份简历，有少部分同学的简历页数都接近 10 页了，让我头皮发麻。</p>\n<figure><img src=\"https://oss.javaguide.cn/zhishixingqiu/image-20230508223646164.png\" alt=\"简历页数过多\" tabindex=\"0\"><figcaption>简历页数过多</figcaption></figure>\n<h3> 避免语义模糊</h3>\n<p>尽量避免主观表述，少一点语义模糊的形容词。表述要简洁明了，简历结构要清晰。</p>\n<p>举例：</p>\n<ul>\n<li>不好的表述：我在团队中扮演了很重要的角色。</li>\n<li>好的表述：我作为后端技术负责人，领导团队完成后端项目的设计与开发。</li>\n</ul>\n<h3> 注意简历样式</h3>\n<p>简历样式同样很重要，一定要注意！不必追求花里胡哨，但要尽量保证结构清晰且易于阅读。</p>\n<h3> 其他</h3>\n<ul>\n<li>一定要使用 PDF 格式投递，不要使用 Word 或者其他格式投递。这是最基本的！</li>\n<li>不会的东西就不要写在简历上了。注意简历真实性，适当润色没有问题。</li>\n<li>工作经历建议采用时间倒序的方式来介绍，实习经历建议将最有价值的放在最前面。</li>\n<li>将自己的项目经历完美的展示出来非常重要，重点是突出自己做了什么（挖掘亮点），而不是介绍项目是做什么的。</li>\n<li>项目经历建议以时间倒序排序，另外项目经历不在于多（精选 2~3 即可），而在于有亮点。</li>\n<li>准备面试的过程中应该将你写在简历上的东西作为重点，尤其是项目经历上和技能介绍上的。</li>\n<li>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</li>\n</ul>\n<h2> 简历修改</h2>\n<p>到目前为止，我至少帮助 <strong>6000+</strong> 位球友提供了免费的简历修改服务。由于个人精力有限，修改简历仅限加入星球的读者，需要帮看简历的话，可以加入 <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html#%E7%AE%80%E5%8E%86%E4%BF%AE%E6%94%B9\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>JavaGuide 官方知识星球</strong></a>（点击链接查看详细介绍）。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/简历修改2.jpg\" alt=\"img\" tabindex=\"0\"><figcaption>img</figcaption></figure>\n<p>虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p>这里再提供一份限时专属优惠卷：</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/image-20230918073550606.png",
      "date_published": "2023-04-28T13:38:12.000Z",
      "date_modified": "2023-10-10T03:03:34.000Z",
      "authors": [],
      "tags": [
        "面试准备"
      ]
    },
    {
      "title": "降级&熔断详解(付费)",
      "url": "https://javaguide.cn/high-availability/fallback-and-circuit-breaker.html",
      "id": "https://javaguide.cn/high-availability/fallback-and-circuit-breaker.html",
      "summary": "降级&amp;熔断 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>降级&amp;熔断</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220304102536445.png\" alt=\"《Java 面试指北》内容概览\" tabindex=\"0\"><figcaption>《Java 面试指北》内容概览</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T12:32:33.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "HTTP vs HTTPS（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/http-vs-https.html",
      "id": "https://javaguide.cn/cs-basics/network/http-vs-https.html",
      "summary": "HTTP 协议 HTTP 协议介绍 HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。 并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。",
      "content_html": "<h2> HTTP 协议</h2>\n<h3> HTTP 协议介绍</h3>\n<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>\n<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>\n<h3> HTTP 协议通信过程</h3>\n<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>\n<ol>\n<li>服务器在 80 端口等待客户的请求。</li>\n<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>\n<li>服务器接收来自浏览器的 TCP 连接。</li>\n<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>\n<li>关闭 TCP 连接。</li>\n</ol>\n<h3> HTTP 协议优点</h3>\n<p>扩展性强、速度快、跨平台支持性好。</p>\n<h2> HTTPS 协议</h2>\n<h3> HTTPS 协议介绍</h3>\n<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>\n<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>\n<h3> HTTPS 协议优点</h3>\n<p>保密性好、信任度高。</p>\n<h2> HTTPS 的核心—SSL/TLS 协议</h2>\n<p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>\n<h3> SSL 和 TLS 的区别？</h3>\n<p><strong>SSL 和 TLS 没有太大的区别。</strong></p>\n<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p>\n<h3> SSL/TLS 的工作原理</h3>\n<h4> 非对称加密</h4>\n<p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>\n<blockquote>\n<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>\n<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>\n<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>\n<blockquote>\n<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>\n<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>\n</blockquote>\n<figure><figcaption>单向函数</figcaption></figure>\n<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>\n<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>\n<h4> 对称加密</h4>\n<p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>\n<blockquote>\n<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>\n<h4> 公钥传输的信赖性</h4>\n<p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>\n<blockquote>\n<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>\n<ol>\n<li>任何人都可以捕获通信包</li>\n<li>通信包的保密性由发送者设计</li>\n<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>\n</ol>\n<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>\n<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>\n<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>\n<h4> 数字签名</h4>\n<p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>\n<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>\n<blockquote>\n<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>\n<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>\n<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<p>总结来说，带有证书的公钥传输机制如下：</p>\n<ol>\n<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>\n<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>\n<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>\n<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>\n<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>\n</ol>\n<figure><figcaption></figcaption></figure>\n<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href=\"https://www.bilibili.com/video/BV18N411X7ty/\" target=\"_blank\" rel=\"noopener noreferrer\">数字签名及数字证书原理</a>这个视频，这是我看过最清晰的讲解。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/image-20220321121814946.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 总结</h2>\n<ul>\n<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>\n<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>\n<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "HTTP 1.0 vs HTTP 1.1（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html",
      "id": "https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html",
      "summary": "这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1： 响应状态码 缓存处理 连接方式 Host 头处理 带宽优化 响应状态码 HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。",
      "content_html": "<p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p>\n<ul>\n<li>响应状态码</li>\n<li>缓存处理</li>\n<li>连接方式</li>\n<li>Host 头处理</li>\n<li>带宽优化</li>\n</ul>\n<h2> 响应状态码</h2>\n<p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>\n<h2> 缓存处理</h2>\n<p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p>\n<h3> HTTP/1.0</h3>\n<p>HTTP/1.0 提供的缓存机制非常简单。服务器端使用<code>Expires</code>标签来标志（时间）一个响应体，在<code>Expires</code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个<code>Last-Modified</code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用<code>If-Modified-Since</code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的<code>If-Modified-Since</code>的值即为上一次获得该资源时，响应体中的<code>Last-Modified</code>的值。</p>\n<p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p>\n<p>如果服务器判断<code>If-Modified-Since</code>时间后，资源被修改过，则返回给客户端一个<code>200 OK</code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p>\n<figure><figcaption>HTTP1.0cache1</figcaption></figure>\n<figure><figcaption>HTTP1.0cache2</figcaption></figure>\n<h3> HTTP/1.1</h3>\n<p>HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code>，详见 MDN Web 文档 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener noreferrer\">Cache-Control</a>.</p>\n<h2> 连接方式</h2>\n<p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p>\n<p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该 TCP 连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>\n<p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p>\n<p>有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p>\n<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>\n<p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p>\n<h2> Host 头处理</h2>\n<p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是<a href=\"http://example1.org/home.html%EF%BC%8CHTTP/1.0\" target=\"_blank\" rel=\"noopener noreferrer\">http://example1.org/home.html，HTTP/1.0</a> 的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>\n<p>因此，HTTP/1.1 在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>\n<h2> 带宽优化</h2>\n<h3> 范围请求</h3>\n<p>HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入<code>Range</code>头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略<code>Range</code>头部，也可以返回若干<code>Range</code>响应。</p>\n<p>如果一个响应包含部分数据的话，那么将带有<code>206 (Partial Content)</code>状态码。该状态码的意义在于避免了 HTTP/1.0 代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。</p>\n<p>在范围响应中，<code>Content-Range</code>头部标志指示出了该数据块的偏移量和数据块的长度。</p>\n<h3> 状态码 100</h3>\n<p>HTTP/1.1 中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p>\n<figure><figcaption>HTTP1.1continue1</figcaption></figure>\n<figure><figcaption>HTTP1.1continue2</figcaption></figure>\n<p>然而在 HTTP/1.0 中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值。</p>\n<h3> 压缩</h3>\n<p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p>\n<p>HTTP/1.1 则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。</p>\n<p>HTTP/1.0 包含了<code>Content-Encoding</code>头部，对消息进行端到端编码。HTTP/1.1 加入了<code>Transfer-Encoding</code>头部，可以对消息进行逐跳传输编码。HTTP/1.1 还加入了<code>Accept-Encoding</code>头部，是客户端用来指示他能处理什么样的内容编码。</p>\n<h2> 总结</h2>\n<ol>\n<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>\n<li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>\n<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>\n<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n<li><strong>Host 头处理</strong> : HTTP/1.1 在请求头中加入了<code>Host</code>字段。</li>\n</ol>\n<h2> 参考资料</h2>\n<p><a href=\"http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Key differences between HTTP/1.0 and HTTP/1.1</a></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "OSI 和 TCP/IP 网络分层模型详解（基础）",
      "url": "https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html",
      "id": "https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html",
      "summary": "OSI 七层模型 OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示： OSI 七层模型 每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。",
      "content_html": "<h2> OSI 七层模型</h2>\n<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png\" alt=\"OSI 七层模型\" tabindex=\"0\"><figcaption>OSI 七层模型</figcaption></figure>\n<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>\n<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>\n<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/osi七层模型2.png\" alt=\"osi七层模型2\" tabindex=\"0\"><figcaption>osi七层模型2</figcaption></figure>\n<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>\n<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>\n<ol>\n<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>\n<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>\n<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>\n<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>\n</ol>\n<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>\n<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> TCP/IP 四层模型</h2>\n<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png\" alt=\"TCP/IP 四层模型\" tabindex=\"0\"><figcaption>TCP/IP 四层模型</figcaption></figure>\n<h3> 应用层（Application layer）</h3>\n<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-five-layer-sample-diagram.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>\n<p><strong>应用层常见协议</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png\" alt=\"应用层常见协议\" tabindex=\"0\"><figcaption>应用层常见协议</figcaption></figure>\n<ul>\n<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>\n<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>\n<li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>\n<li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>\n<li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>\n<li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li>\n<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>\n<li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li>\n</ul>\n<p>关于这些协议的详细介绍请看 <a href=\"/cs-basics/network/application-layer-protocol.html\" target=\"blank\">应用层常见协议总结（应用层）</a> 这篇文章。</p>\n<h3> 传输层（Transport layer）</h3>\n<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>\n<p><strong>传输层常见协议</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png\" alt=\"传输层常见协议\" tabindex=\"0\"><figcaption>传输层常见协议</figcaption></figure>\n<ul>\n<li><strong>TCP（Transmisson Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li>\n<li><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li>\n</ul>\n<h3> 网络层（Network layer）</h3>\n<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>\n<p>⚠️ 注意：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>\n<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>\n<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>\n<p><strong>网络层常见协议</strong>：</p>\n<figure><figcaption>网络层常见协议</figcaption></figure>\n<ul>\n<li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>\n<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>\n<li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li>\n<li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li>\n<li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>\n<li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>\n<li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li>\n</ul>\n<h3> 网络接口层（Network interface layer）</h3>\n<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>\n<ol>\n<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>\n<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>\n</ol>\n<p>网络接口层重要功能和协议如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-interface-layer-protocol.png\" alt=\"网络接口层重要功能和协议\" tabindex=\"0\"><figcaption>网络接口层重要功能和协议</figcaption></figure>\n<h3> 总结</h3>\n<p>简单总结一下每一层包含的协议和核心技术:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-protocol-overview.png\" alt=\"TCP/IP 各层协议概览\" tabindex=\"0\"><figcaption>TCP/IP 各层协议概览</figcaption></figure>\n<p><strong>应用层协议</strong> :</p>\n<ul>\n<li>HTTP（Hypertext Transfer Protocol，超文本传输协议）</li>\n<li>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</li>\n<li>POP3/IMAP（邮件接收协议）</li>\n<li>FTP（File Transfer Protocol，文件传输协议）</li>\n<li>Telnet（远程登陆协议）</li>\n<li>SSH（Secure Shell Protocol，安全的网络传输协议）</li>\n<li>RTP（Real-time Transport Protocol，实时传输协议）</li>\n<li>DNS（Domain Name System，域名管理系统）</li>\n<li>……</li>\n</ul>\n<p><strong>传输层协议</strong> :</p>\n<ul>\n<li>TCP 协议\n<ul>\n<li>报文段结构</li>\n<li>可靠数据传输</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ul>\n</li>\n<li>UDP 协议\n<ul>\n<li>报文段结构</li>\n<li>RDT（可靠数据传输协议）</li>\n</ul>\n</li>\n</ul>\n<p><strong>网络层协议</strong> :</p>\n<ul>\n<li>IP（Internet Protocol，网际协议）</li>\n<li>ARP（Address Resolution Protocol，地址解析协议）</li>\n<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>\n<li>NAT（Network Address Translation，网络地址转换协议）</li>\n<li>OSPF（Open Shortest Path First，开放式最短路径优先）</li>\n<li>RIP(Routing Information Protocol，路由信息协议）</li>\n<li>BGP（Border Gateway Protocol，边界网关协议）</li>\n<li>……</li>\n</ul>\n<p><strong>网络接口层</strong> :</p>\n<ul>\n<li>差错检测技术</li>\n<li>多路访问协议（信道复用技术）</li>\n<li>CSMA/CD 协议</li>\n<li>MAC 协议</li>\n<li>以太网技术</li>\n<li>……</li>\n</ul>\n<h2> 网络分层的原因</h2>\n<p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p>\n<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>\n<ol>\n<li>Repository（数据库操作）</li>\n<li>Service（业务操作）</li>\n<li>Controller（前后端数据交互）</li>\n</ol>\n<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>\n<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>\n<ol>\n<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>\n<li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>\n<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>\n</ol>\n<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>\n<blockquote>\n<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>\n</blockquote>\n<h2> 参考</h2>\n<ul>\n<li>TCP/IP model vs OSI model：<a href=\"https://fiberbit.com.tw/tcpip-model-vs-osi-model/\" target=\"_blank\" rel=\"noopener noreferrer\">https://fiberbit.com.tw/tcpip-model-vs-osi-model/</a></li>\n<li>Data Encapsulation and the TCP/IP Protocol Stack：<a href=\"https://docs.oracle.com/cd/E19683-01/806-4075/ipov-32/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.oracle.com/cd/E19683-01/806-4075/ipov-32/index.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "CAP & BASE理论详解",
      "url": "https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html",
      "id": "https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html",
      "summary": "经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！ 我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。 我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。 CAP 理论 CAP 理论/定理起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 布鲁尔定理（Brewer’s theorem）",
      "content_html": "<p>经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！</p>\n<p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。</p>\n<p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。</p>\n<h2> CAP 理论</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"noopener noreferrer\">CAP 理论/定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>\n<p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。</p>\n<h3> 简介</h3>\n<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/cap.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>\n<p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p>\n<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>\n<ul>\n<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>\n<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>\n<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>\n</ul>\n<p><strong>什么是网络分区？</strong></p>\n<p>分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/partition-tolerance.png\" alt=\"partition-tolerance\" tabindex=\"0\"><figcaption>partition-tolerance</figcaption></figure>\n<h3> 不是所谓的“3 选 2”</h3>\n<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>\n<blockquote>\n<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>\n<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>\n</blockquote>\n<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>\n<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>\n<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>\n<p>另外，需要补充说明的一点是：<strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>\n<h3> CAP 实际应用案例</h3>\n<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>\n<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>\n<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p>\n<figure><img src=\"https://oss.javaguide.cn/2020-11/dubbo-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>\n<ol>\n<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>\n<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>\n<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>\n</ol>\n<p><strong>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1906\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1906</a>）</strong>：</p>\n<p>ZooKeeper 通过可线性化（Linearizable）写入、全局 FIFO 顺序访问等机制来保障数据一致性。多节点部署的情况下， ZooKeeper 集群处于 Quorum 模式。Quorum 模式下的 ZooKeeper 集群， 是一组 ZooKeeper 服务器节点组成的集合，其中大多数节点必须同意任何变更才能被视为有效。</p>\n<p>由于 Quorum 模式下的读请求不会触发各个 ZooKeeper 节点之间的数据同步，因此在某些情况下还是可能会存在读取到旧数据的情况，导致不同的客户端视图上看到的结果不同，这可能是由于网络延迟、丢包、重传等原因造成的。ZooKeeper 为了解决这个问题，提供了 Watcher 机制和版本号机制来帮助客户端检测数据的变化和版本号的变更，以保证数据的一致性。</p>\n<h3> 总结</h3>\n<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等</p>\n<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”</p>\n<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>\n<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>\n<h3> 推荐阅读</h3>\n<ol>\n<li><a href=\"https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4\" target=\"_blank\" rel=\"noopener noreferrer\">CAP 定理简化</a> （英文，有趣的案例）</li>\n<li><a href=\"https://juejin.im/post/6844903936718012430\" target=\"_blank\" rel=\"noopener noreferrer\">神一样的 CAP 理论被应用在何方</a> （中文，列举了很多实际的例子）</li>\n<li><a href=\"https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"noopener noreferrer\">请停止呼叫数据库 CP 或 AP</a> （英文，带给你不一样的思考）</li>\n</ol>\n<h2> BASE 理论</h2>\n<p><a href=\"https://dl.acm.org/doi/10.1145/1394127.1394128\" target=\"_blank\" rel=\"noopener noreferrer\">BASE 理论</a>起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p>\n<h3> 简介</h3>\n<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>\n<h3> BASE 理论的核心思想</h3>\n<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>\n<blockquote>\n<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>\n</blockquote>\n<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>\n<p><strong>为什么这样说呢？</strong></p>\n<p>CAP 理论这节我们也说过了：</p>\n<blockquote>\n<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>\n</blockquote>\n<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>\n<h3> BASE 理论三要素</h3>\n<figure><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY?x-oss-process=image/format,png\" alt=\"BASE理论三要素\" tabindex=\"0\"><figcaption>BASE理论三要素</figcaption></figure>\n<h4> 基本可用</h4>\n<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>\n<p><strong>什么叫允许损失部分可用性呢？</strong></p>\n<ul>\n<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>\n<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>\n</ul>\n<h4> 软状态</h4>\n<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>\n<h4> 最终一致性</h4>\n<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>\n<blockquote>\n<p>分布式一致性的 3 种级别：</p>\n<ol>\n<li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>\n<li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>\n<li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>\n</ol>\n<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>\n</blockquote>\n<p>那实现最终一致性的具体方式是什么呢? <a href=\"http://gk.link/a/10rZM\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式协议与算法实战》</a> 中是这样介绍：</p>\n<blockquote>\n<ul>\n<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>\n<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>\n<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>\n</ul>\n</blockquote>\n<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>\n<h3> 总结</h3>\n<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/2020-11/cap.png",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Gossip 协议详解",
      "url": "https://javaguide.cn/distributed-system/protocol/gossip-protocl.html",
      "id": "https://javaguide.cn/distributed-system/protocol/gossip-protocl.html",
      "summary": "背景 在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。 一种比较简单粗暴的方法就是 集中式发散消息，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。 于是，分散式发散消息 的 Gossip 协议 就诞生了。 Gossip 协议介绍 Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。",
      "content_html": "<h2> 背景</h2>\n<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>\n<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>\n<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>\n<h2> Gossip 协议介绍</h2>\n<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>\n<figure><figcaption></figcaption></figure>\n<p><strong>Gossip 协议</strong> 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>\n<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <a href=\"https://dl.acm.org/doi/10.1145/41840.41841\" target=\"_blank\" rel=\"noopener noreferrer\">《Epidemic Algorithms for Replicated Database Maintenance》</a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。</p>\n<p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p>\n<p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p>\n<p>下面我们来对 Gossip 协议的定义做一个总结：<strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p>\n<h2> Gossip 协议应用</h2>\n<p>NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>\n<p>我们这里以 Redis Cluster 为例说明 Gossip 协议的实际应用。</p>\n<p>我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-fcacc1eefca6e51354a5f1fc9f2919f51ec.png\" alt=\"Redis 的官方集群解决方案\" tabindex=\"0\"><figcaption>Redis 的官方集群解决方案</figcaption></figure>\n<p>Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，Redis Cluster 中的各个节点基于 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。</p>\n<p>Redis Cluster 的节点之间会相互发送多种 Gossip 消息：</p>\n<ul>\n<li><strong>MEET</strong>：在 Redis Cluster 中的某个 Redis 节点上执行 <code>CLUSTER MEET ip port</code> 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。</li>\n<li><strong>PING/PONG</strong>：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</li>\n<li><strong>FAIL</strong>：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。</li>\n<li>……</li>\n</ul>\n<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>\n<figure><figcaption></figcaption></figure>\n<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。</p>\n<p>关于 Redis Cluster 的详细介绍，可以查看这篇文章 <a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解(付费)</a> 。</p>\n<h2> Gossip 协议消息传播模式</h2>\n<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>\n<h3> 反熵(Anti-entropy)</h3>\n<p>根据维基百科：</p>\n<blockquote>\n<p>熵的概念最早起源于<a href=\"https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6\" target=\"_blank\" rel=\"noopener noreferrer\">物理学</a>，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</p>\n</blockquote>\n<p>在这里，你可以把反熵中的熵理解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。</p>\n<p>具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>\n<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>\n<ul>\n<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>\n<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li>\n<li>推拉就是同时修复自己副本和对方副本中的熵。</li>\n</ul>\n<p>伪代码如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-df16e98bf71e872a7e1f01ca31cee93d77b.png\" alt=\"反熵伪代码\" tabindex=\"0\"><figcaption>反熵伪代码</figcaption></figure>\n<p>在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p>\n<figure><figcaption></figcaption></figure>\n<ol>\n<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>\n<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>\n<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>\n<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>\n</ol>\n<p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 <strong>谣言传播(Rumor mongering)</strong> 。</p>\n<h3> 谣言传播(Rumor mongering)</h3>\n<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>\n<p>如下图所示（下图来自于<a href=\"https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/\" target=\"_blank\" rel=\"noopener noreferrer\">INTRODUCTION TO GOSSIP</a> 这篇文章）：</p>\n<p>![Gossip 传播示意图](./images/gossip/gossip-rumor- mongering.gif)</p>\n<p>伪代码如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/20210605170707933.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p>\n<h3> 总结</h3>\n<ul>\n<li>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</li>\n<li>我们一般会给反熵设计一个闭环。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2> Gossip 协议优势和缺陷</h2>\n<p><strong>优势：</strong></p>\n<p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p>\n<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>\n<p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>\n<p><strong>缺陷</strong> :</p>\n<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>\n<p>2、由于拜占庭将军问题，不允许存在恶意节点。</p>\n<p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>\n<h2> 总结</h2>\n<ul>\n<li>Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</li>\n<li>Gossip 协议被 Redis、Apache Cassandra、Consul 等项目应用。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>一万字详解 Redis Cluster Gossip 协议：<a href=\"https://segmentfault.com/a/1190000038373546\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000038373546</a></li>\n<li>《分布式协议与算法实战》</li>\n<li>《Redis 设计与实现》</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-11-24T02:55:08.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Paxos 算法详解",
      "url": "https://javaguide.cn/distributed-system/protocol/paxos-algorithm.html",
      "id": "https://javaguide.cn/distributed-system/protocol/paxos-algorithm.html",
      "summary": "背景 Paxos 算法是 Leslie Lamport（莱斯利·兰伯特）在 1990 年提出了一种分布式系统 共识 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。",
      "content_html": "<h2> 背景</h2>\n<p>Paxos 算法是 Leslie Lamport（<a href=\"https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9\" target=\"_blank\" rel=\"noopener noreferrer\">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>\n<p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p>\n<p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p>\n<p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p>\n<p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href=\"http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《The Part-Time Parliament》</a>。</p>\n<p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href=\"http://lamport.azurewebsites.net/pubs/paxos-simple.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《Paxos Made Simple》</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p>\n<p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p>\n<figure><figcaption></figcaption></figure>\n<blockquote>\n<p>The Paxos algorithm, when presented in plain English, is very simple.</p>\n</blockquote>\n<p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p>\n<p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p>\n<h2> 介绍</h2>\n<p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>\n<p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p>\n<ul>\n<li><strong>Basic Paxos 算法</strong>：描述的是多节点之间如何就某个值(提案 Value)达成共识。</li>\n<li><strong>Multi-Paxos 思想</strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。</li>\n</ul>\n<p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—<a href=\"https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html\" target=\"_blank\" rel=\"noopener noreferrer\">Raft 算法</a> 。更具体点来说，Raft 是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p>\n<p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong>、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。</p>\n<p>针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong>、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p>\n<p>区块链系统使用的共识算法需要解决的核心问题是 <strong>拜占庭将军问题</strong> ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p>\n<p>下面我们来对 Paxos 算法的定义做一个总结：</p>\n<ul>\n<li>Paxos 算法是兰伯特在 <strong>1990</strong> 年提出了一种分布式系统共识算法。</li>\n<li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。</li>\n<li>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。</li>\n</ul>\n<h2> Basic Paxos 算法</h2>\n<p>Basic Paxos 中存在 3 个重要的角色：</p>\n<ol>\n<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>\n<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>\n<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-890fa3212e8bf72886a595a34654918486c.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p>\n<h2> Multi Paxos 思想</h2>\n<p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Basic Paxos 思想。</p>\n<p>⚠️<strong>注意</strong>：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。</p>\n<p>由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解和实现上比较困难。</p>\n<p>不过，也不需要担心，我们并不需要自己实现基于 Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法。</p>\n<h2> 参考</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Paxos\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/Paxos</a></li>\n<li>分布式系统中的一致性与共识算法：<a href=\"http://www.xuyasong.com/?p=1970\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.xuyasong.com/?p=1970</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Raft 算法详解",
      "url": "https://javaguide.cn/distributed-system/protocol/raft-algorithm.html",
      "id": "https://javaguide.cn/distributed-system/protocol/raft-algorithm.html",
      "summary": "本文由 SnailClimb 和 Xieqijun 共同完成。 1 背景 当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。",
      "content_html": "<blockquote>\n<p>本文由 <a href=\"https://github.com/Snailclimb\" target=\"_blank\" rel=\"noopener noreferrer\">SnailClimb</a> 和 <a href=\"https://github.com/jun0315\" target=\"_blank\" rel=\"noopener noreferrer\">Xieqijun</a> 共同完成。</p>\n</blockquote>\n<h2> 1 背景</h2>\n<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>\n<p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p>\n<p>幸运的是，分布式共识可以帮助应对这些挑战。</p>\n<h3> 1.1 拜占庭将军</h3>\n<p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p>\n<blockquote>\n<p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p>\n</blockquote>\n<p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p>\n<p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p>\n<h3> 1.2 共识算法</h3>\n<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>\n<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png\" alt=\"rsm-architecture.png\" tabindex=\"0\"><figcaption>rsm-architecture.png</figcaption></figure>\n<p><code>图-1 复制状态机架构</code></p>\n<p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p>\n<p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p>\n<p>适用于实际系统的共识算法通常具有以下特性：</p>\n<ul>\n<li>\n<p>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</p>\n</li>\n<li>\n<p>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</p>\n</li>\n<li>\n<p>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</p>\n</li>\n<li>\n<p>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</p>\n</li>\n</ul>\n<h2> 2 基础</h2>\n<h3> 2.1 节点类型</h3>\n<p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p>\n<ul>\n<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>\n<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>\n<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>\n</ul>\n<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-server-state.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>图-2：服务器的状态</code></p>\n<h3> 2.2 任期</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/paxos-term.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>图-3：任期</code></p>\n<p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p>\n<p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p>\n<h3> 2.3 日志</h3>\n<ul>\n<li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li>\n<li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li>\n</ul>\n<h2> 3 领导人选举</h2>\n<p>raft 使用心跳机制来触发 Leader 的选举。</p>\n<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>\n<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>\n<p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>\n<ul>\n<li>赢得选举</li>\n<li>其他节点赢得选举</li>\n<li>一轮选举结束，无人胜出</li>\n</ul>\n<p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p>\n<p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p>\n<ul>\n<li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li>\n<li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li>\n</ul>\n<p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>\n<p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p>\n<h2> 4 日志复制</h2>\n<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p>\n<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>\n<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>\n<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p>\n<p>raft 保证以下两个性质：</p>\n<ul>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>\n<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>\n</ul>\n<p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p>\n<p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p>\n<p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p>\n<p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p>\n<h2> 5 安全性</h2>\n<h3> 5.1 选举限制</h3>\n<p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p>\n<p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p>\n<p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p>\n<h3> 5.2 节点崩溃</h3>\n<p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p>\n<p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p>\n<h3> 5.3 时间与可用性</h3>\n<p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p>\n<p><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p>\n<ul>\n<li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li>\n<li><code>electionTimeout</code>：选举超时时间；</li>\n<li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li>\n</ul>\n<p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p>\n<p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p>\n<p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p>\n<p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>\n<h2> 6 参考</h2>\n<ul>\n<li><a href=\"https://tanxinyu.work/raft/\" target=\"_blank\" rel=\"noopener noreferrer\">https://tanxinyu.work/raft/</a></li>\n<li><a href=\"https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md</a></li>\n<li><a href=\"https://github.com/ongardie/dissertation/blob/master/stanford.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/ongardie/dissertation/blob/master/stanford.pdf</a></li>\n<li><a href=\"https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-11-24T02:26:52.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "滴滴和头条两年后端工作经验分享",
      "url": "https://javaguide.cn/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html",
      "summary": "推荐语：很实用的工作经验分享，看完之后十分受用！ 内容概览： 要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。 积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？ 在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。 脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。 想舔就舔，不想舔也没必要酸别人，Respect Greatness。 时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。 平时积极总结沉淀，多跟别人交流，形成方法论。 …… 原文地址：https://www.nowcoder.com/discuss/351805",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：很实用的工作经验分享，看完之后十分受用！</p>\n<p><strong>内容概览</strong>：</p>\n<ul>\n<li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</li>\n<li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</li>\n<li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</li>\n<li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</li>\n<li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</li>\n<li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</li>\n<li>平时积极总结沉淀，多跟别人交流，形成方法论。</li>\n<li>……</li>\n</ul>\n<p><strong>原文地址</strong>：<a href=\"https://www.nowcoder.com/discuss/351805\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.nowcoder.com/discuss/351805</a></p>\n</blockquote>\n<p>先简单交代一下背景吧，某不知名 985 的本硕，17 年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。</p>\n<h2> 学会深入思考，总结沉淀</h2>\n<p><strong>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</strong></p>\n<p><strong>先来说深入思考。</strong> 在程序员这个圈子里，常能听到一些言论：<em>“我这个工作一点技术含量都没有，每天就 CRUD，再写写 if-else，这 TM 能让我学到什么东西？”</em></p>\n<p>抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高 level 的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。<strong>任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。</strong></p>\n<p>举一个例子。某次有个同学跟我说，这周有个服务 OOM 了，查了一周发现有个地方 defer 写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查 bug 这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有 linux 的 OOM，k8s 的 OOM，go 的内存管理，defer 机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个 WHY 没问题吧...</p>\n<p><strong>再来说下总结沉淀。</strong> 这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p>\n<p>还是举一个例子。做后台服务，今天优化了 1G 内存，明天优化了 50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大 key 拆分、延迟处理、编码压缩、gc 调优还有各种语言相关的高性能实践...等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p>\n<p>还有的同学说了，我就每天跟 PM 撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟 PM 讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让 Martin Fowler 整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄...</p>\n<p>所以说：<strong>学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</strong></p>\n<h2> 积极学习，保持技术热情</h2>\n<p>最近两年在互联网圈里广泛传播的一种焦虑论叫做 35 岁程序员现象，大意是说程序员这个行业干到 35 岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是，这个问题里 35 岁程序员并不是绝对生理意义上的 35 岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35 岁和 25 岁差不多，而且没有了 25 岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p>\n<p><strong>如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</strong> 但是，<strong>学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。</strong> 在滴滴时有一句话大概是，<strong>主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</strong></p>\n<p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p>\n<p><strong><em>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</em></strong></p>\n<h2> 主动承担，及时交流反馈</h2>\n<p>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。</p>\n<p><strong>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</strong></p>\n<p>我当初刚入职的时候，基本就是 leader 给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是 leader 只需要同步一下最近要做什么方向，下面的一系列事情基本不需要 leader 操心了 ，这样的同学我是 leader 我也喜欢啊。入职后经常会听到的一个词叫 owner 意识，大概就是这个意思吧。</p>\n<p>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟 leader 同步，技术方案拿捏不准可以跟 leader 探讨，一些资源协调不了可以找 leader 帮忙，不要有太多顾忌，认为这些会太麻烦，leader 其实就是干这个事的。。如果项目进展比较顺利，确实也不需要 leader 介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问 leader 对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用 leader 的各种资源，另一方面也可以让 leader 了解到自己的工作量，对项目整体有所把控，毕竟 leader 也有 leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟 leader 同步过，想着憋个大招之类的，那基本凉凉。</p>\n<p><strong>一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时 one-one。</strong></p>\n<p>除了以上几点，还有一些小点我觉得也是比较重要的，列在下面：</p>\n<h2> 第一件事建立信任</h2>\n<p>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了 leader 和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的 leader 还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p>\n<p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。<strong>最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</strong></p>\n<p><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></p>\n<h2> 超出预期</h2>\n<p>超出预期这个词的外延范围很广，比如 leader 让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如 leader 让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了 leader 没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p>\n<p><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></p>\n<h2> 体系化思考，系统化建设</h2>\n<p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到 XXX 的收益。这个工作还有后续的 roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做...给人的感觉就是这个人思考非常全面，办事有体系有规划。</p>\n<p><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></p>\n<h2> 提升自己的软素质能力</h2>\n<p>这里的软素质能力其实想说的就是 PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为 PPT 做的好了一点...可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候 PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学 PPT 内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。</p>\n<p><strong><em>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</em></strong></p>\n<p>以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。</p>\n<h2> 拍马屁是真的香</h2>\n<p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了...入职前几天，部门群里大 leader 发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门 leader 发消息，几个二级部门 leader 跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p>\n<p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给 leader 安排上。而是我发现我的直属 leader 也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了 leader 的喜好...</p>\n<p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力...</p>\n<p><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></p>\n<h2> 永不缺席的撕逼甩锅实战</h2>\n<p>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的...这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p>\n<p><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong></p>\n<h2> 不要被画饼蒙蔽了双眼</h2>\n<p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102 年都快过完了，这一套***治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强 push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对 leader 的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p>\n<ol>\n<li>leader 并没有注意到你薪资较低这一事实</li>\n<li>leader 知道这个事实，但是不知道你有多强烈的涨薪需求</li>\n<li>leader 知道你有涨薪的需求，但他觉得你能力还不够</li>\n<li>leader 知道你有涨薪的需求，能力也够，但是他不想给你涨</li>\n<li>leader 想给你涨，也向上反馈和争取了，但是没有资源</li>\n</ol>\n<p>这时候我们需要做的是向上反馈，跟 leader 沟通确认。如果是 1 和 2，那么通过沟通可以消除信息误差。如果是 3，需要分情况讨论。如果是 4 和 5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p>\n<p><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></p>\n<h2> 学会包装</h2>\n<p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让 leader 描述一下，这就成了，打造了 XXX 的工具抓手，改进了 XXX 的完整生态，形成了 XXX 的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner 意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p>\n<p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p>\n<ol>\n<li>我们背后是一个四五百亿美金的市场...</li>\n<li>我负责过每天千亿级别访问量的系统...</li>\n<li>工作两年能达到这个程度挺不错的...</li>\n<li>贵司技术氛围挺好的，业务发展前景也很广阔...</li>\n<li>啊，彼此彼此...</li>\n<li>嗯，久仰久仰...</li>\n</ol>\n<p>人生如戏，全靠演技</p>\n<p><strong>可以多看 leader 的 PPT，多听老板的向上汇报和宣讲会。</strong></p>\n<h2> 选择和努力哪个更重要？</h2>\n<p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了...但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好 leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p>\n<h2> 后记</h2>\n<p>本来还想分享一些生活方面的故事，发现已经这么长了，那就先这样叭。上面写的一些总结和建议我自己做的也不是很好，还需要继续加油，和大家共勉。另外，其中某些观点，由于个人视角的局限性也不保证是普适和正确的，可能再工作几年这些观点也会发生改变，欢迎大家跟我交流~（甩锅成功）</p>\n<p>最后祝大家都能找到心仪的工作，快乐工作，幸福生活，广阔天地，大有作为。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "JWT 身份认证优缺点分析",
      "url": "https://javaguide.cn/system-design/security/advantages-and-disadvantages-of-jwt.html",
      "id": "https://javaguide.cn/system-design/security/advantages-and-disadvantages-of-jwt.html",
      "summary": "在 JWT 基本概念详解这篇文章中，我介绍了： 什么是 JWT? JWT 由哪些部分组成？ 如何基于 JWT 进行身份验证？ JWT 如何防止 Token 被篡改？ 如何加强 JWT 的安全性？ 这篇文章，我们一起探讨一下 JWT 身份认证的优缺点以及常见问题的解决办法。",
      "content_html": "<p>在 <a href=\"https://javaguide.cn/system-design/security/jwt-intro.html\" target=\"_blank\" rel=\"noopener noreferrer\">JWT 基本概念详解</a>这篇文章中，我介绍了：</p>\n<ul>\n<li>什么是 JWT?</li>\n<li>JWT 由哪些部分组成？</li>\n<li>如何基于 JWT 进行身份验证？</li>\n<li>JWT 如何防止 Token 被篡改？</li>\n<li>如何加强 JWT 的安全性？</li>\n</ul>\n<p>这篇文章，我们一起探讨一下 JWT 身份认证的优缺点以及常见问题的解决办法。</p>\n<h2> JWT 的优势</h2>\n<p>相比于 Session 认证的方式来说，使用 JWT 进行身份认证主要有下面 4 个优势。</p>\n<h3> 无状态</h3>\n<p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p>\n<p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：<strong>不可控！</strong></p>\n<p>就比如说，我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。再比如说，当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。具体的解决办法，我们会在后面的内容中详细介绍到，这里只是简单提一下。</p>\n<h3> 有效避免了 CSRF 攻击</h3>\n<p><strong>CSRF（Cross Site Request Forgery）</strong> 一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等安全攻击方式，CSRF 的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。就连业内技术标杆 Google 的产品 Gmail 也曾在 2007 年的时候爆出过 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p>\n<p><strong>那么究竟什么是跨站请求伪造呢？</strong> 简单来说就是用你的身份去做一些不好的事情（发送一些对你不友好的请求比如恶意转账）。</p>\n<p>举个简单的例子：小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求，也就是通过你的 Cookie 向银行发出请求。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 <code>SessionID</code> 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 <code>SessionID</code>，只要让你误点攻击链接，就可以达到攻击效果。</p>\n<p>另外，并不是必须点击链接才可以达到攻击效果，很多时候，只要你打开了某个页面，CSRF 攻击就会发生。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>那为什么 JWT 不会存在这种问题呢？</strong></p>\n<p>一般情况下我们使用 JWT 的话，在我们登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。因此，即使你点击了非法链接发送了请求到服务端，这个非法请求也是不会携带 JWT 的，所以这个请求将是非法的。</p>\n<p>总结来说就一句话：<strong>使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击。</strong></p>\n<p>不过，这样也会存在 XSS 攻击的风险。为了避免 XSS 攻击，你可以选择将 JWT 存储在标记为<code>httpOnly</code> 的 Cookie 中。但是，这样又导致了你必须自己提供 CSRF 保护，因此，实际项目中我们通常也不会这么做。</p>\n<p>常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串。</p>\n<p>在 Spring 项目中，我们一般是通过创建 XSS 过滤器来实现的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 适合移动端应用</h3>\n<p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 <code>SessionId</code>），所以不适合移动端。</p>\n<p>但是，使用 JWT 进行身份认证就不会存在这种问题，因为只要 JWT 可以被客户端存储就能够使用，而且 JWT 还可以跨语言使用。</p>\n<h3> 单点登录友好</h3>\n<p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。</p>\n<h2> JWT 身份认证常见问题及解决办法</h2>\n<h3> 注销登录等场景下 JWT 还有效</h3>\n<p>与之类似的具体相关场景有：</p>\n<ul>\n<li>退出登录;</li>\n<li>修改密码;</li>\n<li>服务端修改了某个用户具有的权限或者角色；</li>\n<li>用户的帐户被封禁/删除；</li>\n<li>用户被服务端强制注销；</li>\n<li>用户被踢下线；</li>\n<li>……</li>\n</ul>\n<p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 JWT 认证的方式就不好解决了。我们也说过了，JWT 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p>\n<p>那我们如何解决这个问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p>\n<p><strong>1、将 JWT 存入内存数据库</strong></p>\n<p>将 JWT 存入 DB 中，Redis 内存数据库在这里是不错的选择。如果需要让某个 JWT 失效就直接从 Redis 中删除这个 JWT 即可。但是，这样会导致每次使用 JWT 发送请求都要先从 DB 中查询 JWT 是否存在的步骤，而且违背了 JWT 的无状态原则。</p>\n<p><strong>2、黑名单机制</strong></p>\n<p>和上面的方式类似，使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p>\n<p>前两种方案的核心在于将有效的 JWT 存储起来或者将指定的 JWT 拉入黑名单。</p>\n<p>虽然这两种方案都违背了 JWT 的无状态原则，但是一般实际项目中我们通常还是会使用这两种方案。</p>\n<p><strong>3、修改密钥 (Secret)</strong> :</p>\n<p>我们为每个用户都创建一个专属密钥，如果我们想让某个 JWT 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大：</p>\n<ul>\n<li>如果服务是分布式的，则每次发出新的 JWT 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</li>\n<li>如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li>\n</ul>\n<p><strong>4、保持令牌的有效期限短并经常轮换</strong></p>\n<p>很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p>\n<p>另外，对于修改密码后 JWT 还有效问题的解决还是比较容易的。说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 JWT 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p>\n<h3> JWT 的续签问题</h3>\n<p>JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？</p>\n<p>我们先来看看在 Session 认证中一般的做法：<strong>假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。</strong></p>\n<p>JWT 认证的话，我们应该如何解决续签问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p>\n<p><strong>1、类似于 Session 认证中的做法</strong></p>\n<p>这种方案满足于大部分场景。假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ,对客户端不是很友好。</p>\n<p><strong>2、每次请求都返回新 JWT</strong></p>\n<p>这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</p>\n<p><strong>3、JWT 有效期设置到半夜</strong></p>\n<p>这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p>\n<p><strong>4、用户登录返回两个 JWT</strong></p>\n<p>第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p>\n<p>这种方案的不足是：</p>\n<ul>\n<li>需要客户端来配合；</li>\n<li>用户注销的时候需要同时保证两个 JWT 都无效；</li>\n<li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li>\n<li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。</li>\n</ul>\n<h2> 总结</h2>\n<p>JWT 其中一个很重要的优势是无状态，但实际上，我们想要在实际项目中合理使用 JWT 的话，也还是需要保存 JWT 信息。</p>\n<p>JWT 也不是银弹，也有很多缺陷，具体是选择 JWT 还是 Session 方案还是要看项目的具体需求。万万不可尬吹 JWT，而看不起其他身份认证方案。</p>\n<p>另外，不用 JWT 直接使用普通的 Token(随机生成，不包含具体的信息) 结合 Redis 来做身份认证也是可以的。我在 <a href=\"https://javaguide.cn/open-source-project/\" target=\"_blank\" rel=\"noopener noreferrer\">「优质开源项目推荐」</a>的第 8 期推荐过的 <a href=\"https://github.com/dromara/sa-token\" target=\"_blank\" rel=\"noopener noreferrer\">Sa-Token</a> 这个项目是一个比较完善的 基于 JWT 的身份认证解决方案，支持自动续签、踢人下线、账号封禁、同端互斥登录等功能，感兴趣的朋友可以看看。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/system-design/jwt/image-20220609170714725.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 参考</h2>\n<ul>\n<li>JWT 超详细分析：<a href=\"https://learnku.com/articles/17883\" target=\"_blank\" rel=\"noopener noreferrer\">https://learnku.com/articles/17883</a></li>\n<li>How to log out when using JWT：<a href=\"https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6\" target=\"_blank\" rel=\"noopener noreferrer\">https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6</a></li>\n<li>CSRF protection with JSON Web JWTs：<a href=\"https://medium.com/@agungsantoso/csrf-protection-with-json-web-JWTs-83e0f2fcbcc\" target=\"_blank\" rel=\"noopener noreferrer\">https://medium.com/@agungsantoso/csrf-protection-with-json-web-JWTs-83e0f2fcbcc</a></li>\n<li>Invalidating JSON Web JWTs：<a href=\"https://stackoverflow.com/questions/21978658/invalidating-json-web-JWTs\" target=\"_blank\" rel=\"noopener noreferrer\">https://stackoverflow.com/questions/21978658/invalidating-json-web-JWTs</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javaguide/system-design/jwt/image-20220609170714725.png",
      "date_published": "2023-04-28T09:15:47.000Z",
      "date_modified": "2023-12-17T07:37:37.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Java面试重点总结(重要)",
      "url": "https://javaguide.cn/interview-preparation/key-points-of-interview.html",
      "id": "https://javaguide.cn/interview-preparation/key-points-of-interview.html",
      "summary": "友情提示 本文节选自 《Java 面试指北》。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。 Java 后端面试哪些知识点是重点？ 准备面试的时候，具体哪些知识点是重点呢？",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">友情提示</p>\n<p>本文节选自 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。</p>\n</div>\n<h2> Java 后端面试哪些知识点是重点？</h2>\n<p><strong>准备面试的时候，具体哪些知识点是重点呢？</strong></p>\n<p>给你几点靠谱的建议：</p>\n<ol>\n<li>Java 基础、集合、并发、MySQL、Redis、Spring、Spring Boot 这些 Java 后端开发必备的知识点。大厂以及中小厂的面试问的比较多的就是这些知识点（不信的话，你可以去多找一些面经看看）。我这里没有提到计算机基础相关的内容，这个会在下面提到。</li>\n<li>你的项目经历涉及到的知识点，有水平的面试官都是会根据你的项目经历来问的。举个例子，你的项目经历使用了 Redis 来做限流，那 Redis 相关的八股文（比如 Redis 常见数据结构）以及限流相关的八股文（比如常见的限流算法）你就应该多花更多心思来搞懂！吃透！你把项目经历上的知识点吃透之后，再把你简历上哪些写熟练掌握的技术给吃透。最后，再去花时间准备其他知识点。</li>\n<li>针对自身找工作的需求，你又可以适当地调整复习的重点。像中小厂一般问计算机基础比较少一些，有些大厂比如字节比较重视计算机基础尤其是算法。这样的话，如果你的目标是中小厂的话，计算机基础就准备面试来说不是那么重要了。如果复习时间不够的话，可以暂时先放放。</li>\n<li>一般校招的面试不会强制要求你会分布式/微服务、高并发的知识（不排除个别岗位有这方面的硬性要求），所以到底要不要掌握还是要看你个人当前的实际情况。如果你会这方面的知识的话，对面试相对来说还是会更有利一些（想要让项目经历有亮点，还是得会一些性能优化的知识。性能优化的知识这也算是高并发知识的一个小分支了）。如果你的技能介绍或者项目经历涉及到分布式/微服务、高并发的知识，那建议你尽量也要抽时间去认真准备一下，面试中很可能会被问到，尤其是项目经历用到的时候。不过，也还是主要准备写在简历上的那些知识点就好。</li>\n<li>JVM 相关的知识点，一般是大厂才会问到，面试中小厂就没必要准备了。JVM 面试中比较常问的是 <a href=\"https://javaguide.cn/java/jvm/memory-area.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 内存区域</a>、<a href=\"https://javaguide.cn/java/jvm/jvm-garbage-collection.html\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 垃圾回收</a>、<a href=\"https://javaguide.cn/java/jvm/classloader.html\" target=\"_blank\" rel=\"noopener noreferrer\">类加载器和双亲委派模型</a> 以及 JVM 调优和问题排查（我之前分享过一些<a href=\"https://t.zsxq.com/0bsAac47U\" target=\"_blank\" rel=\"noopener noreferrer\">常见的线上问题案例</a>，里面就有 JVM 相关的）。</li>\n<li>不同的大厂面试侧重点也会不同。比如说你要去阿里这种公司的话，项目和八股文就是重点，阿里笔试一般会有代码题，进入面试后就很少问代码题了，但是对原理性的问题问的比较深，经常会问一些你对技术的思考。再比如说你要面试字节这种公司，那计算机基础，尤其是算法是重点，字节的面试十分注重代码功底，有时候开始面试就会直接甩给你一道代码题，写出来再谈别的。也会问面试八股文，以及项目，不过，相对来说要少很多。建议你看一下这篇文章 <a href=\"https://mp.weixin.qq.com/s/pBsGQNxvRupZeWt4qZReIA\" target=\"_blank\" rel=\"noopener noreferrer\">为了解开互联网大厂秋招内幕，我把他们全面了一遍</a>，了解一下常见大厂的面试题侧重点。</li>\n</ol>\n<p>看似 Java 后端八股文很多，实际把复习范围一缩小，重要的东西就是那些。考虑到时间问题，你不可能连一些比较冷门的知识点也给准备了。这没必要，主要精力先放在那些重要的知识点即可。</p>\n<h2> 如何更高效地准备八股文？</h2>\n<p>对于技术八股文来说，尽量不要死记硬背，这种方式非常枯燥且对自身能力提升有限！但是！想要一点不背是不太现实的，只是说要结合实际应用场景和实战来理解记忆。</p>\n<p>我一直觉得面试八股文最好是和实际应用场景和实战相结合。很多同学现在的方向都错了，上来就是直接背八股文，硬生生学成了文科，那当然无趣了。</p>\n<p>举个例子：你的项目中需要用到 Redis 来做缓存，你对照着官网简单了解并实践了简单使用 Redis 之后，你去看了 Redis 对应的八股文。你发现 Redis 可以用来做限流、分布式锁，于是你去在项目中实践了一下并掌握了对应的八股文。紧接着，你又发现 Redis 内存不够用的情况下，还能使用 Redis Cluster 来解决，于是你就又去实践了一下并掌握了对应的八股文。</p>\n<p><strong>一定要记住你的主要目标是理解和记关键词，而不是像背课文一样一字一句地记下来！</strong></p>\n<p>另外，记录博客或者用自己的理解把对应的知识点讲给别人听也是一个不错的选择。</p>\n<p>最后，准备技术面试的同学一定要定期复习（自测的方式非常好），不然确实会遗忘的。</p>\n",
      "date_published": "2023-04-22T02:34:42.000Z",
      "date_modified": "2023-10-10T03:03:34.000Z",
      "authors": [],
      "tags": [
        "面试准备"
      ]
    },
    {
      "title": "计算机网络常见面试题总结(下)",
      "url": "https://javaguide.cn/cs-basics/network/other-network-questions2.html",
      "id": "https://javaguide.cn/cs-basics/network/other-network-questions2.html",
      "summary": "下篇主要是传输层和网络层相关的内容。 TCP 与 UDP TCP 与 UDP 的区别（重要） 是否面向连接：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。 是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。 是否有状态：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。 传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。 传输形式：TCP 是面向字节流的，UDP 是面向报文的。 首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。 是否提供广播或多播服务：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多； ……",
      "content_html": "<p>下篇主要是传输层和网络层相关的内容。</p>\n<h2> TCP 与 UDP</h2>\n<h3> TCP 与 UDP 的区别（重要）</h3>\n<ol>\n<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>\n<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>\n<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>\n<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>\n<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>\n<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>\n<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>\n<li>……</li>\n</ol>\n<p>我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否面向连接</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否有状态</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>较慢</td>\n<td>较快</td>\n</tr>\n<tr>\n<td>传输形式</td>\n<td>字节流</td>\n<td>数据报文段</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>20 ～ 60 bytes</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>是否提供广播或多播服务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<h3> 什么时候选择 TCP，什么时候选 UDP?</h3>\n<ul>\n<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>\n<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>\n</ul>\n<h3> HTTP 基于 TCP 还是 UDP？</h3>\n<p><s><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</s></p>\n<p>🐛 修正（参见 <a href=\"https://github.com/Snailclimb/JavaGuide/issues/1915\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1915</a>）：</p>\n<p>HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p>\n<p>此变化解决了 HTTP/2 中存在的队头阻塞问题。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>\n<p>除了解决队头阻塞问题，HTTP/3.0 还可以减少握手过程的延迟。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：</p>\n<ol>\n<li>TCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。</li>\n<li>TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。</li>\n</ol>\n<p>所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>\n<p>相关证明可以参考下面这两个链接：</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh/HTTP/3\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/zh/HTTP/3</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/rfc9114/\" target=\"_blank\" rel=\"noopener noreferrer\">https://datatracker.ietf.org/doc/rfc9114/</a></li>\n</ul>\n<h3> 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3>\n<p><strong>运行于 TCP 协议之上的协议</strong>：</p>\n<ol>\n<li><strong>HTTP 协议</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>\n<li><strong>HTTPS 协议</strong>：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>\n<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>\n<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>\n<li><strong>POP3/IMAP 协议</strong>：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>\n<li><strong>Telnet 协议</strong>：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>\n<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>\n<li>……</li>\n</ol>\n<p><strong>运行于 UDP 协议之上的协议</strong>：</p>\n<ol>\n<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>\n<li><strong>DNS</strong>：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener noreferrer\">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上，DNS 同时支持 UDP 和 TCP 协议。</li>\n<li>……</li>\n</ol>\n<h3> TCP 三次握手和四次挥手（非常重要）</h3>\n<p><strong>相关面试题</strong>：</p>\n<ul>\n<li>为什么要三次握手?</li>\n<li>第 2 次握手传回了 ACK，为什么还要传回 SYN？</li>\n<li>为什么要四次挥手？</li>\n<li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li>\n<li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li>\n<li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li>\n</ul>\n<p><strong>参考答案</strong>：<a href=\"/cs-basics/network/tcp-connection-and-disconnection.html\" target=\"blank\">TCP 三次握手和四次挥手（传输层）</a> 。</p>\n<h3> TCP 如何保证传输的可靠性？（重要）</h3>\n<p><a href=\"/cs-basics/network/tcp-reliability-guarantee.html\" target=\"blank\">TCP 传输可靠性保障（传输层）</a></p>\n<h2> IP</h2>\n<h3> IP 协议的作用是什么？</h3>\n<p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>\n<p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p>\n<h3> 什么是 IP 地址？IP 寻址如何工作？</h3>\n<p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址（Internet Protocol address）</strong>，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。</p>\n<p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p>\n<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>\n<p>这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png\" alt=\"IP 地址使数据包到达其目的地\" tabindex=\"0\"><figcaption>IP 地址使数据包到达其目的地</figcaption></figure>\n<h3> 什么是 IP 地址过滤？</h3>\n<p><strong>IP 地址过滤（IP Address Filtering）</strong> 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。</p>\n<p>IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p>\n<h3> IPv4 和 IPv6 有什么区别？</h3>\n<p><strong>IPv4（Internet Protocol version 4）</strong> 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-1-IPv4Addressformatwithdotteddecimalnotation-29c824f6a451d48d8c27759799f0c995.png\" alt=\"IPv4\" tabindex=\"0\"><figcaption>IPv4</figcaption></figure>\n<p>这么少当然不够用啦！为了解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议 - <strong>IPv6（Internet Protocol version 6）</strong>。IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-2-IPv6Addressformatwithhexadecimalnotation-7da3a419bd81627a9b2cef3b0efb4940.png\" alt=\"IPv6\" tabindex=\"0\"><figcaption>IPv6</figcaption></figure>\n<p>除了更大的地址空间之外，IPv6 的优势还包括：</p>\n<ul>\n<li><strong>无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）</strong>：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。</li>\n<li><strong>NAT（Network Address Translation，网络地址转换） 成为可选项</strong>：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。</li>\n<li><strong>对标头结构进行了改进</strong>：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。</li>\n<li><strong>可选的扩展头</strong>：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。</li>\n<li><strong>ICMPv6（Internet Control Message Protocol for IPv6）</strong>：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。</li>\n<li>……</li>\n</ul>\n<h3> NAT 的作用是什么？</h3>\n<p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>\n<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-address-translation.png\" alt=\"NAT 实现 IP地址转换\" tabindex=\"0\"><figcaption>NAT 实现 IP地址转换</figcaption></figure>\n<p>相关阅读：<a href=\"/cs-basics/network/nat.html\" target=\"blank\">NAT 协议详解（网络层）</a>。</p>\n<h2> ARP</h2>\n<h3> 什么是 Mac 地址？</h3>\n<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>\n<figure><figcaption>路由器的背面就会注明 MAC 位址</figcaption></figure>\n<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>\n<blockquote>\n<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>\n</blockquote>\n<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>\n<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>\n<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>\n<h3> ARP 协议解决了什么问题地位如何？</h3>\n<p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>\n<h3> ARP 协议的工作原理？</h3>\n<p><a href=\"/cs-basics/network/arp.html\" target=\"blank\">ARP 协议详解(网络层)</a></p>\n<h2> 复习建议</h2>\n<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>\n<h2> 参考</h2>\n<ul>\n<li>《图解 HTTP》</li>\n<li>《计算机网络自顶向下方法》（第七版）</li>\n<li>什么是 Internet 协议（IP）？：<a href=\"https://www.cloudflare.com/zh-cn/learning/network-layer/internet-protocol/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/network-layer/internet-protocol/</a></li>\n<li>What Is NAT and What Are the Benefits of NAT Firewalls?：<a href=\"https://community.fs.com/blog/what-is-nat-and-what-are-the-benefits-of-nat-firewalls.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://community.fs.com/blog/what-is-nat-and-what-are-the-benefits-of-nat-firewalls.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png",
      "date_published": "2023-04-13T11:00:22.000Z",
      "date_modified": "2023-12-12T04:58:28.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "DNS 域名系统详解（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/dns.html",
      "id": "https://javaguide.cn/cs-basics/network/dns.html",
      "summary": "DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。 DNS:域名系统 在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个hosts列表，一般来说浏览器要先查看要访问的域名是否在hosts列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地hosts列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。",
      "content_html": "<p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png\" alt=\"DNS:域名系统\" tabindex=\"0\"><figcaption>DNS:域名系统</figcaption></figure>\n<p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地<code>hosts</code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。</p>\n<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-protocol-overview.png\" alt=\"TCP/IP 各层协议概览\" tabindex=\"0\"><figcaption>TCP/IP 各层协议概览</figcaption></figure>\n<p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p>\n<ul>\n<li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li>\n<li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li>\n<li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li>\n<li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li>\n</ul>\n<h2> DNS 工作流程</h2>\n<p>以下图为例，介绍 DNS 的查询解析过程。DNS 的查询解析过程分为两种模式：</p>\n<ul>\n<li><strong>迭代</strong></li>\n<li><strong>递归</strong></li>\n</ul>\n<p>下图是实践中常采用的方式，从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>现在，主机<code>cis.poly.edu</code>想知道<code>gaia.cs.umass.edu</code>的 IP 地址。假设主机<code>cis.poly.edu</code>的本地 DNS 服务器为<code>dns.poly.edu</code>，并且<code>gaia.cs.umass.edu</code>的权威 DNS 服务器为<code>dns.cs.umass.edu</code>。</p>\n<ol>\n<li>首先，主机<code>cis.poly.edu</code>向本地 DNS 服务器<code>dns.poly.edu</code>发送一个 DNS 请求，该查询报文包含被转换的域名<code>gaia.cs.umass.edu</code>。</li>\n<li>本地 DNS 服务器<code>dns.poly.edu</code>检查本机缓存，发现并无记录，也不知道<code>gaia.cs.umass.edu</code>的 IP 地址该在何处，不得不向根服务器发送请求。</li>\n<li>根服务器注意到请求报文中含有<code>edu</code>顶级域，因此告诉本地 DNS，你可以向<code>edu</code>的 TLD DNS 发送请求，因为目标域名的 IP 地址很可能在那里。</li>\n<li>本地 DNS 获取到了<code>edu</code>的 TLD DNS 服务器地址，向其发送请求，询问<code>gaia.cs.umass.edu</code>的 IP 地址。</li>\n<li><code>edu</code>的 TLD DNS 服务器仍不清楚请求域名的 IP 地址，但是它注意到该域名有<code>umass.edu</code>前缀，因此返回告知本地 DNS，<code>umass.edu</code>的权威服务器可能记录了目标域名的 IP 地址。</li>\n<li>这一次，本地 DNS 将请求发送给权威 DNS 服务器<code>dns.cs.umass.edu</code>。</li>\n<li>终于，由于<code>gaia.cs.umass.edu</code>向权威 DNS 服务器备案过，在这里有它的 IP 地址记录，权威 DNS 成功地将 IP 地址返回给本地 DNS。</li>\n<li>最后，本地 DNS 获取到了目标域名的 IP 地址，将其返回给请求主机。</li>\n</ol>\n<p>除了迭代式查询，还有一种递归式查询如下图，具体过程和上述类似，只是顺序有所不同。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process2.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>另外，DNS 的缓存位于本地 DNS 服务器。由于全世界的根服务器甚少，只有 400 多台，分为 13 组，且顶级域的数量也在一个可数的范围内，因此本地 DNS 通常已经缓存了很多 TLD DNS 服务器，所以在实际查找过程中，无需访问根服务器。根服务器通常是被跳过的，不请求的。</p>\n<h2> DNS 报文格式</h2>\n<p>DNS 的报文格式如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-packet.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>DNS 报文分为查询和回答报文，两种形式的报文结构相同。</p>\n<ul>\n<li>标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li>\n<li>标志。1 比特的”查询/回答“标识位，<code>0</code>表示查询报文，<code>1</code>表示回答报文；1 比特的”权威的“标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用”权威的“标志）；1 比特的”希望递归“标志位，显式地要求执行递归查询；1 比特的”递归可用“标志位，用于回答报文中，表示 DNS 服务器支持递归查询。</li>\n<li>问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。</li>\n<li>问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。</li>\n<li>回答区域。包含了对最初请求的名字的资源记录。<strong>在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</strong></li>\n<li>权威区域。包含了其他权威服务器的记录。</li>\n<li>附加区域。包含了其他有帮助的记录。</li>\n</ul>\n<h2> DNS 记录</h2>\n<p>DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为<strong>资源记录(Resource Record，RR)</strong>。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了<code>Name</code>, <code>Value</code>, <code>Type</code>, <code>TTL</code>四个字段的四元组。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/20210506174303797.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>TTL</code>是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。</p>\n<p><code>Name</code>和<code>Value</code>字段的取值取决于<code>Type</code>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/20210506170307897.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li>如果<code>Type=A</code>，则<code>Name</code>是主机名信息，<code>Value</code> 是该主机名对应的 IP 地址。这样的 RR 记录了一条主机名到 IP 地址的映射。</li>\n<li>如果 <code>Type=AAAA</code> （与 <code>A</code> 记录非常相似），唯一的区别是 A 记录使用的是 IPv4，而 <code>AAAA</code> 记录使用的是 IPv6。</li>\n<li>如果<code>Type=CNAME</code> (Canonical Name Record,真实名称记录) ，则<code>Value</code>是别名为<code>Name</code>的主机对应的规范主机名。<code>Value</code>值才是规范主机名。<code>CNAME</code> 记录将一个主机名映射到另一个主机名。<code>CNAME</code> 记录用于为现有的 <code>A</code> 记录创建别名。下文有示例。</li>\n<li>如果<code>Type=NS</code>，则<code>Name</code>是个域，而<code>Value</code>是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。通常这样的 RR 是由 TLD 服务器发布的。</li>\n<li>如果<code>Type=MX</code> ，则<code>Value</code>是个别名为<code>Name</code>的邮件服务器的规范主机名。既然有了 <code>MX</code> 记录，那么邮件服务器可以和其他服务器使用相同的别名。为了获得邮件服务器的规范主机名，需要请求 <code>MX</code> 记录；为了获得其他服务器的规范主机名，需要请求 <code>CNAME</code> 记录。</li>\n</ul>\n<p><code>CNAME</code>记录总是指向另一则域名，而非 IP 地址。假设有下述 DNS zone：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当用户查询 <code>bar.example.com</code> 的时候，DNS Server 实际返回的是 <code>foo.example.com</code> 的 IP 地址。</p>\n<h2> 参考</h2>\n<ul>\n<li>DNS 服务器类型：<a href=\"https://www.cloudflare.com/zh-cn/learning/dns/dns-server-types/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/dns/dns-server-types/</a></li>\n<li>DNS Message Resource Record Field Formats：<a href=\"http://www.tcpipguide.com/free/t_DNSMessageResourceRecordFieldFormats-2.htm\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.tcpipguide.com/free/t_DNSMessageResourceRecordFieldFormats-2.htm</a></li>\n<li>Understanding Different Types of Record in DNS Server：<a href=\"https://www.mustbegeek.com/understanding-different-types-of-record-in-dns-server/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mustbegeek.com/understanding-different-types-of-record-in-dns-server/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png",
      "date_published": "2023-04-11T08:54:54.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "坚持写技术博客六年了!",
      "url": "https://javaguide.cn/about-the-author/writing-technology-blog-six-years.html",
      "id": "https://javaguide.cn/about-the-author/writing-technology-blog-six-years.html",
      "summary": "坚持写技术博客已经有六年了，也算是一个小小的里程碑了。 一开始，我写技术博客就是简单地总结自己课堂上学习的课程比如网络、操作系统。渐渐地，我开始撰写一些更为系统化的知识点详解和面试常见问题总结。 JavaGuide 首页 许多人都想写技术博客，但却不清楚这对他们有何好处。有些人开始写技术博客，却不知道如何坚持下去，也不知道该写些什么。这篇文章我会认真聊聊我对记录技术博客的一些看法和心得，或许可以帮助你解决这些问题。",
      "content_html": "<p>坚持写技术博客已经有六年了，也算是一个小小的里程碑了。</p>\n<p>一开始，我写技术博客就是简单地总结自己课堂上学习的课程比如网络、操作系统。渐渐地，我开始撰写一些更为系统化的知识点详解和面试常见问题总结。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230408131717766.png\" alt=\"JavaGuide 首页\" tabindex=\"0\"><figcaption>JavaGuide 首页</figcaption></figure>\n<p>许多人都想写技术博客，但却不清楚这对他们有何好处。有些人开始写技术博客，却不知道如何坚持下去，也不知道该写些什么。这篇文章我会认真聊聊我对记录技术博客的一些看法和心得，或许可以帮助你解决这些问题。</p>\n<h2> 写技术博客有哪些好处？</h2>\n<h3> 学习效果更好，加深知识点的认识</h3>\n<p><strong>费曼学习法</strong> 大家应该已经比较清楚了，这是一个经过实践证明非常有效的学习方式。费曼学习法的命名源自 Richard Feynman，这位物理学家曾获得过诺贝尔物理学奖，也曾参与过曼哈顿计划。</p>\n<p>所谓费曼学习法，就是当你学习了一个新知识之后，想象自己是一个老师：用最简单、最浅显直白的话复述、表达复杂深奥的知识，最好不要使用行业术语，让非行业内的人也能听懂。为了达到这种效果，最好想象你是在给一个 80 多岁或 8 岁的小孩子上课，甚至他们都能听懂。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/v2-19373c2e61873c5083ee4b1d1523f8f5_720w.png\" alt=\"教授别人学习效果最好\" tabindex=\"0\"><figcaption>教授别人学习效果最好</figcaption></figure>\n<p>看书、看视频这类都属于是被动学习，学习效果比较差。费曼学习方法属于主动学习，学习效果非常好。</p>\n<p><strong>写技术博客实际就是教别人的一种方式。</strong> 不过，记录技术博客的时候是可以有专业术语（除非你的文章群体是非技术人员），只是你需要用自己的话表述出来，尽量让别人一看就懂。<strong>切忌照搬书籍或者直接复制粘贴其他人的总结！</strong></p>\n<p>如果我们被动的学习某个知识点，可能大部分时候都是仅仅满足自己能够会用的层面，你并不会深究其原理，甚至很多关键概念都没搞懂。</p>\n<p>如果你是要将你所学到的知识总结成一篇博客的话，一定会加深你对这个知识点的思考。很多时候，你为了将一个知识点讲清楚，你回去查阅很多资料，甚至需要查看很多源码，这些细小的积累在潜移默化中加深了你对这个知识点的认识。</p>\n<p>甚至，我还经常会遇到这种情况：<strong>写博客的过程中，自己突然意识到自己对于某个知识点的理解存在错误。</strong></p>\n<p><strong>写博客本身就是一个对自己学习到的知识进行总结、回顾、思考的过程。记录博客也是对于自己学习历程的一种记录。随着时间的流逝、年龄的增长，这又何尝不是一笔宝贵的精神财富呢？</strong></p>\n<p>知识星球的一位球友还提到写技术博客有助于完善自己的知识体系：</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230408121336432.png\" alt=\"写技术博客有助于完善自己的知识体系\" tabindex=\"0\"><figcaption>写技术博客有助于完善自己的知识体系</figcaption></figure>\n<h3> 帮助别人的同时获得成就感</h3>\n<p>就像我们程序员希望自己的产品能够得到大家的认可和喜欢一样。我们写技术博客在某一方面当然也是为了能够得到别人的认可。</p>\n<p><strong>当你写的东西对别人产生帮助的时候，你会产生成就感和幸福感。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230404181906257.png\" alt=\"读者的认可\" tabindex=\"0\"><figcaption>读者的认可</figcaption></figure>\n<p>这种成就感和幸福感会作为 <strong>正向反馈</strong> ，继续激励你写博客。</p>\n<p>但是，即使受到很多读者的赞赏，也要保持谦虚学习的太多。人外有人，比你技术更厉害的读者多了去，一定要虚心学习！</p>\n<p>当然，你可以可能会受到很多非议。可能会有很多人说你写的文章没有深度，还可能会有很多人说你闲的蛋疼，你写的东西网上/书上都有。</p>\n<p><strong>坦然对待这些非议，做好自己，走好自己的路就好！用行动自证！</strong></p>\n<h3> 可能会有额外的收入</h3>\n<p>写博客可能还会为你带来经济收入。输出价值的同时，还能够有合理的经济收入，这是最好的状态！</p>\n<p>为什么说是可能呢？ <strong>因为就目前来看，大部分人还是很难短期通过写博客有收入。我也不建议大家一开始写博客就奔着赚钱的目的，这样功利性太强了，效果可能反而不好。就比如说你坚持了写了半年发现赚不到钱，那你可能就会坚持不下去了。</strong></p>\n<p>我自己从大二开始写博客，大三下学期开始将自己的文章发布到公众号上，一直到大四下学期，才通过写博客赚到属于自己的第一笔钱。</p>\n<p>第一笔钱是通过微信公众号接某培训机构的推广获得的。没记错的话，当时通过这个推广为自己带来了大约 <strong>500</strong> 元的收入。虽然这不是很多，但对于还在上大学的我来说，这笔钱非常宝贵。那时我才知道，原来写作真的可以赚钱，这也让我更有动力去分享自己的写作。可惜的是，在接了两次这家培训机构的广告之后，它就倒闭了。</p>\n<p>之后，很长一段时间我都没有接到过广告。直到网易的课程合作找上门，一篇文章 1000 元，每个月接近一篇，发了接近两年，这也算是我在大学期间比较稳定的一份收入来源了。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230408115720135.png\" alt=\"网易的课程合作\" tabindex=\"0\"><figcaption>网易的课程合作</figcaption></figure>\n<p>老粉应该大部分都是通过 JavaGuide 这个项目认识我的，这是我在大三开始准备秋招面试时创建的一个项目。没想到这个项目竟然火了一把，一度霸占了 GitHub 榜单。可能当时国内这类开源文档教程类项目太少了，所以这个项目受欢迎程度非常高。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230408131849198.png\" alt=\"JavaGuide Star 趋势\" tabindex=\"0\"><figcaption>JavaGuide Star 趋势</figcaption></figure>\n<p>项目火了之后，有一个国内比较大的云服务公司找到我，说是要赞助 JavaGuide 这个项目。我既惊又喜，担心别人是骗子，反复确认合同之后，最终确定以每月 1000 元的费用在我的项目首页加上对方公司的 banner。</p>\n<p>随着时间的推移，以及自己后来写了一些比较受欢迎、比较受众的文章，我的博客知名度也有所提升，通过写博客的收入也增加了不少。</p>\n<h3> 增加个人影响力</h3>\n<p>写技术博客是一种展示自己技术水平和经验的方式，能够让更多的人了解你的专业领域知识和技能。持续分享优质的技术文章，一定能够在技术领域增加个人影响力，这一点是毋庸置疑的。</p>\n<p>有了个人影响力之后，不论是对你后面找工作，还是搞付费知识分享或者出书，都非常有帮助。</p>\n<p>拿我自己来说，已经很多知名出版社的编辑找过我，协商出一本的书的事情。这种机会应该也是很多人梦寐以求的。不过，我都一一拒绝了，因为觉得自己远远没有达到能够写书的水平。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230408121132211.png\" alt=\"电子工业出版社编辑邀约出书\" tabindex=\"0\"><figcaption>电子工业出版社编辑邀约出书</figcaption></figure>\n<p>其实不出书最主要的原因还是自己嫌麻烦，整个流程的事情太多了。我自己又是比较佛系随性的人，平时也不想把时间都留给工作。</p>\n<h2> 怎样才能坚持写技术博客？</h2>\n<p><strong>不可否认，人都是有懒性的，这是人的本性。我们需要一个目标/动力来 Push 一下自己。</strong></p>\n<p>就技术写作而言，你的目标可以以技术文章的数量为标准，比如：</p>\n<ul>\n<li>一年写多少篇技术文章。我个人觉得一年的范围还是太长了，不太容易定一个比较合适的目标。</li>\n<li>每月输出一篇高质量的技术文章。这个相对容易实现一些，每月一篇，一年也有十二篇了，也很不错了。</li>\n</ul>\n<p>不过，以技术文章的数量为目标有点功利化，文章的质量同样很重要。一篇高质量的技术文可能需要花费一周甚至半个月的业余时间才能写完。一定要避免自己刻意追求数量，而忽略质量，迷失技术写作的本心。</p>\n<p>我个人给自己定的目标是：<strong>每个月至少写一篇原创技术文章或者认真修改完善过去写的三篇技术文章</strong> （像开源项目推荐、开源项目学习、个人经验分享、面经分享等等类型的文章不会被记入）。</p>\n<p>我的目标对我来说比较容易完成，因此不会出现为了完成目标而应付任务的情况。在我状态比较好，工作也不是很忙的时候，还会经常超额完成任务。下图是我今年 3 月份完成的任务（任务管理工具：Microsoft To-Do）。除了 gossip 协议是去年写的之外，其他都是 3 月份完成的。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230404181033089.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果觉得以文章数量为标准过于功利的话，也可以比较随性地按照自己的节奏来写作。不过，一般这种情况下，你很可能过段时间就忘了还有这件事，开始慢慢抵触写博客。</p>\n<p>写完一篇技术文章之后，我们不光要同步到自己的博客，还要分发到国内一些常见的技术社区比如博客园、掘金。<strong>分发到其他平台的原因是获得关注进而收获正向反馈（动力来源之一）与建议，这是技术写作能坚持下去的非常重要的一步，一定要重视！！！</strong></p>\n<p>说实话，当你写完一篇自认为还不错的文章的幸福感和成就感还是有的。<strong>但是，让自己去做这件事情还是比较痛苦的。</strong> 就好比你让自己出去玩很简单，为了达到这个目的，你可以有各种借口。但是，想要自己老老实实学习，还是需要某个外力来督促自己的。</p>\n<h2> 写哪些方向的博客比较好？</h2>\n<p>通常来说，写下面这些方向的博客会比较好：</p>\n<ol>\n<li><strong>详细讲解某个知识点</strong>：一定要有自己的思考而不是东拼西凑。不仅要介绍知识点的基本概念和原理，还需要适当结合实际案例和应用场景进行举例说明。</li>\n<li><strong>问题排查/性能优化经历</strong>：需要详细描述清楚具体的场景以及解决办法。一定要有足够的细节描述，包括出现问题的具体场景、问题的根本原因、解决问题的思路和具体步骤等等。同时，要注重实践性和可操作性，帮助读者更好地学习理解。</li>\n<li><strong>源码阅读记录</strong>：从一个功能点出发描述其底层源码实现，谈谈你从源码中学到了什么。</li>\n</ol>\n<p>最重要的是一定要重视 Markdown 规范，不然内容再好也会显得不专业。</p>\n<p>详见 <a href=\"/javaguide/contribution-guideline.html\" target=\"blank\">Markdown 规范</a> （很重要，尽量按照规范来，对你工作中写文档会非常有帮助）</p>\n<h2> 有没有什么写作技巧分享？</h2>\n<h3> 句子不要过长</h3>\n<p>句子不要过长，尽量使用短句（但也不要太短），这样读者更容易阅读和理解。</p>\n<h3> 尽量让文章更加生动有趣</h3>\n<p>尽量让文章更加生动有趣，比如你可以适当举一些形象的例子、用一些有趣的段子、歇后语或者网络热词。</p>\n<p>不过，这个也主要看你的文章风格。</p>\n<h3> 使用简单明了的语言</h3>\n<p>避免使用阅读者可能无法理解的行话或复杂语言。</p>\n<p>注重清晰度和说服力，保持简单。简单的写作是有说服力的，一个五句话的好论点会比一百句话的精彩论点更能打动人。为什么格言、箴言这类文字容易让人接受，与简洁、直白也有些关系。</p>\n<h3> 使用视觉效果</h3>\n<p>图表、图像等视觉效果可以让朴素的文本内容更容易理解。记得在适当的地方使用视觉效果来增强你的文章的表现力。</p>\n<figure><img src=\"https://oss.javaguide.cn/about-the-author/college-life/image-20230404192458759.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 技术文章配图色彩要鲜明</h3>\n<p>下面是同样内容的两张图，都是通过 drawio 画的，小伙伴们更喜欢哪一张呢？</p>\n<p>我相信大部分小伙伴都会选择后面一个色彩更鲜明的！</p>\n<p>色彩的调整不过花费了我不到 30s 的时间，带来的阅读体验的上升却是非常之大！</p>\n<figure><img src=\"https://oss.javaguide.cn/2021-1/image-20210104182517226.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 确定你的读者</h3>\n<p>写作之前，思考一下你的文章的主要受众全体是谁。受众群体确定之后，你可以根据受众的需求和理解水平调整你的写作风格和内容难易程度。</p>\n<h3> 审查和修改</h3>\n<p>在发表之前一定要审查和修改你的文章。这将帮助你发现错误、澄清任何令人困惑的信息并提高文档的整体质量。</p>\n<p><strong>好文是改出来的，切记！！！</strong></p>\n<h2> 总结</h2>\n<p>总的来说，写技术博客是一件利己利彼的事情。你可能会从中收获到很多东西，你写的东西也可能对别人也有很大的帮助。但是，写技术博客还是比较耗费自己时间的，你需要和工作以及生活做好权衡。</p>\n",
      "image": "https://oss.javaguide.cn/about-the-author/college-life/image-20230408131717766.png",
      "date_published": "2023-04-09T12:42:14.000Z",
      "date_modified": "2023-05-05T04:49:01.000Z",
      "authors": [],
      "tags": [
        "走近作者"
      ]
    },
    {
      "title": "操作系统常见面试题总结(下)",
      "url": "https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html",
      "id": "https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html",
      "summary": "内存管理 内存管理主要做了什么？ 内存管理主要做的事情 操作系统的内存管理非常重要，主要负责下面这些事情： 内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。 地址转换：将程序中的虚拟地址转换成内存中的物理地址。 内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。 内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。 内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。 内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。 ……",
      "content_html": "<h2> 内存管理</h2>\n<h3> 内存管理主要做了什么？</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png\" alt=\"内存管理主要做的事情\" tabindex=\"0\"><figcaption>内存管理主要做的事情</figcaption></figure>\n<p>操作系统的内存管理非常重要，主要负责下面这些事情：</p>\n<ul>\n<li><strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li>\n<li><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</li>\n<li><strong>内存扩充</strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li>\n<li><strong>内存映射</strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li>\n<li><strong>内存优化</strong>：通过调整内存分配策略和回收算法来优化内存使用效率。</li>\n<li><strong>内存安全</strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li>\n<li>……</li>\n</ul>\n<h3> 什么是内存碎片？</h3>\n<p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：</p>\n<ul>\n<li><strong>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)</strong>：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。</li>\n<li><strong>外部内存碎片(External Memory Fragmentation，简称为外部碎片)</strong>：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png\" alt=\"内存碎片\" tabindex=\"0\"><figcaption>内存碎片</figcaption></figure>\n<p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。</p>\n<h3> 常见的内存管理方式有哪些？</h3>\n<p>内存管理方式可以简单分为下面两种：</p>\n<ul>\n<li><strong>连续内存管理</strong>：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。</li>\n<li><strong>非连续内存管理</strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</li>\n</ul>\n<h4> 连续内存管理</h4>\n<p><strong>块式管理</strong> 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。</p>\n<p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：<strong>必须是相邻的才是伙伴</strong>）。</p>\n<p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。</p>\n<p>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png\" alt=\"伙伴系统（Buddy System）内存管理\" tabindex=\"0\"><figcaption>伙伴系统（Buddy System）内存管理</figcaption></figure>\n<p>虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 2^n 的内存块，因此当需要分配的内存大小不是 2^n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7=128 大小的内存块。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/buddy-system-memory-waste.png\" alt=\"伙伴系统内存浪费问题\" tabindex=\"0\"><figcaption>伙伴系统内存浪费问题</figcaption></figure>\n<p>对于内部内存碎片的问题，Linux 采用 <strong>SLAB</strong> 进行解决。由于这部分内容不是本篇文章的重点，这里就不详细介绍了。</p>\n<h4> 非连续内存管理</h4>\n<p>非连续内存管理存在下面 3 种方式：</p>\n<ul>\n<li><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</li>\n<li><strong>页式管理</strong>：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间也被划分为连续等长的虚拟页，是现代操作系统广泛使用的一种内存管理方式。</li>\n<li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</li>\n</ul>\n<h3> 虚拟内存</h3>\n<h4> 什么是虚拟内存?有什么用？</h4>\n<p><strong>虚拟内存(Virtual Memory)</strong> 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/virtual-memory.png\" alt=\"虚拟内存作为进程访问主存的桥梁\" tabindex=\"0\"><figcaption>虚拟内存作为进程访问主存的桥梁</figcaption></figure>\n<p>总结来说，虚拟内存主要提供了下面这些能力：</p>\n<ul>\n<li><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n<li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li>\n<li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li>\n<li><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li>\n<li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>\n<li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n</ul>\n<h4> 没有虚拟内存有什么问题？</h4>\n<p>如果没有虚拟内存的话，程序直接访问和操作的都是物理内存，看似少了一层中介，但多了很多问题。</p>\n<p><strong>具体有什么问题呢？</strong> 这里举几个例子说明(参考虚拟内存提供的能力回答这个问题)：</p>\n<ol>\n<li>用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。</li>\n<li>同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。</li>\n<li>程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。</li>\n<li>……</li>\n</ol>\n<h4> 什么是虚拟地址和物理地址？</h4>\n<p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p>\n<p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p>\n<p>操作系统一般通过 CPU 芯片中的一个重要组件 <strong>MMU(Memory Management Unit，内存管理单元)</strong> 将虚拟地址转换为物理地址，这个过程被称为 <strong>地址翻译/地址转换（Address Translation）</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png\" alt=\"地址翻译过程\" tabindex=\"0\"><figcaption>地址翻译过程</figcaption></figure>\n<p>通过 MMU 将虚拟地址转换为物理地址后，再通过总线传到物理内存设备，进而完成相应的物理内存读写请求。</p>\n<p>MMU 将虚拟地址翻译为物理地址的主要机制有两种: <strong>分段机制</strong> 和 <strong>分页机制</strong> 。</p>\n<h4> 什么是虚拟地址空间和物理地址空间？</h4>\n<ul>\n<li>虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。</li>\n<li>物理地址空间是物理地址的集合，是物理内存的范围。</li>\n</ul>\n<h4> 虚拟地址与物理内存地址是如何映射的？</h4>\n<p>MMU 将虚拟地址翻译为物理地址的主要机制有 3 种:</p>\n<ol>\n<li>分段机制</li>\n<li>分页机制</li>\n<li>段页机制</li>\n</ol>\n<p>其中，现代操作系统广泛采用分页机制，需要重点关注！</p>\n<h3> 分段机制</h3>\n<p><strong>分段机制（Segmentation）</strong> 以段(—段 <strong>连续</strong> 的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</p>\n<h4> 段表有什么用？地址翻译过程是怎样的？</h4>\n<p>分段管理通过 <strong>段表（Segment Table）</strong> 映射虚拟地址和物理地址。</p>\n<p>分段机制下的虚拟地址由两部分组成：</p>\n<ul>\n<li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li>\n<li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li>\n</ul>\n<p>具体的地址翻译过程如下：</p>\n<ol>\n<li>MMU 首先解析得到虚拟地址中的段号；</li>\n<li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li>\n<li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png\" alt=\"分段机制下的地址翻译过程\" tabindex=\"0\"><figcaption>分段机制下的地址翻译过程</figcaption></figure>\n<p>段表中还存有诸如段长(可用于检查虚拟地址是否超出合法范围)、段类型（该段的类型，例如代码段、数据段等）等信息。</p>\n<p><strong>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</strong></p>\n<p>不一定。段表项可能并不存在：</p>\n<ul>\n<li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li>\n<li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li>\n</ul>\n<h4> 分段机制为什么会导致内存外部碎片？</h4>\n<p>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。从而造成物理内存资源利用率的降低。</p>\n<p>举个例子：假设可用物理内存为 5G 的系统使用分段机制分配内存。现在有 4 个进程，每个进程的内存占用情况如下：</p>\n<ul>\n<li>进程 1：0~1G（第 1 段）</li>\n<li>进程 2：1~3G（第 2 段）</li>\n<li>进程 3：3~4.5G（第 3 段）</li>\n<li>进程 4：4.5~5G（第 4 段）</li>\n</ul>\n<p>此时，我们关闭了进程 1 和进程 4，则第 1 段和第 4 段的内存会被释放，空闲物理内存还有 1.5G。由于这 1.5G 物理内存并不是连续的，导致没办法将空闲的物理内存分配给一个需要 1.5G 物理内存的进程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-external-memory-fragmentation.png\" alt=\"分段机制导致外部内存碎片\" tabindex=\"0\"><figcaption>分段机制导致外部内存碎片</figcaption></figure>\n<h3> 分页机制</h3>\n<p><strong>分页机制（Paging）</strong> 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p>\n<p><strong>注意：这里的页是连续等长的，不同于分段机制下不同长度的段。</strong></p>\n<p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p>\n<h4> 页表有什么用？地址翻译过程是怎样的？</h4>\n<p>分页管理通过 <strong>页表（Page Table）</strong> 映射虚拟地址和物理地址。我这里画了一张基于单级页表进行地址翻译的示意图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png\" alt=\"单级页表\" tabindex=\"0\"><figcaption>单级页表</figcaption></figure>\n<p>在分页机制下，每个应用程序都会有一个对应的页表。</p>\n<p>分页机制下的虚拟地址由两部分组成：</p>\n<ul>\n<li><strong>页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li>\n<li><strong>页内偏移量</strong>：物理页起始地址+页内偏移量=物理内存地址。</li>\n</ul>\n<p>具体的地址翻译过程如下：</p>\n<ol>\n<li>MMU 首先解析得到虚拟地址中的虚拟页号；</li>\n<li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；</li>\n<li>用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png\" alt=\"分页机制下的地址翻译过程\" tabindex=\"0\"><figcaption>分页机制下的地址翻译过程</figcaption></figure>\n<p>页表中还存有诸如访问标志（标识该页面有没有被访问过）、脏数据标识位等信息。</p>\n<p><strong>通过虚拟页号一定要找到对应的物理页号吗？找到了物理页号得到最终的物理地址后对应的物理页一定存在吗？</strong></p>\n<p>不一定！可能会存在 <strong>页缺失</strong> 。也就是说，物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）。关于页缺失的内容，后面会详细介绍到。</p>\n<h4> 单级页表有什么问题？为什么需要多级页表？</h4>\n<p>以 32 位的环境为例，虚拟地址空间范围共有 2^32（4G）。假设 一个页的大小是 2^12（4KB），那页表项共有 4G / 4K = 2^20 个。每个页表项为一个地址，占用 4 字节，2^20 * 2^2/1024*1024= 4MB。也就是说一个程序啥都不干，页表大小就得占用 4M。</p>\n<p>系统运行的应用程序多起来的话，页表的开销还是非常大的。而且，绝大部分应用程序可能只能用到页表中的几项，其他的白白浪费了。</p>\n<p>为了解决这个问题，操作系统引入了 <strong>多级页表</strong> ，多级页表对应多个页表，每个页表也前一个页表相关联。32 位系统一般为二级页表，64 位系统一般为四级页表。</p>\n<p>这里以二级页表为例进行介绍：二级列表分为一级页表和二级页表。一级页表共有 1024 个页表项，一级页表又关联二级页表，二级页表同样共有 1024 个页表项。二级页表中的一级页表项是一对多的关系，二级页表按需加载（只会用到很少一部分二级页表），进而节省空间占用。</p>\n<p>假设只需要 2 个二级页表，那两级页表的内存占用情况为: 4KB（一级页表占用） + 4KB * 2（二级页表占用） = 12 KB。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/multilevel-page-table.png\" alt=\"多级页表\" tabindex=\"0\"><figcaption>多级页表</figcaption></figure>\n<p>多级页表属于时间换空间的典型场景，利用增加页表查询的次数减少页表占用的空间。</p>\n<h4> TLB 有什么用？使用 TLB 之后的地址翻译流程是怎样的？</h4>\n<p>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>转址旁路缓存(Translation Lookaside Buffer，TLB，也被称为快表)</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation-mmu.png\" alt=\"加入 TLB 之后的地址翻译\" tabindex=\"0\"><figcaption>加入 TLB 之后的地址翻译</figcaption></figure>\n<p>在主流的 AArch64 和 x86-64 体系结构下，TLB 属于 (Memory Management Unit，内存管理单元) 内部的单元，本质上就是一块高速缓存（Cache），缓存了虚拟页号到物理页号的映射关系，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表。</p>\n<p>使用 TLB 之后的地址翻译流程是这样的：</p>\n<ol>\n<li>用虚拟地址中的虚拟页号作为 key 去 TLB 中查询；</li>\n<li>如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。</li>\n<li>如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。</li>\n<li>当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table-tlb.png\" alt=\"使用 TLB 之后的地址翻译流程\" tabindex=\"0\"><figcaption>使用 TLB 之后的地址翻译流程</figcaption></figure>\n<p>由于页表也在主存中，因此在没有 TLB 之前，每次读写内存数据时 CPU 要访问两次主存。有了 TLB 之后，对于存在于 TLB 中的页表数据只需要访问一次主存即可。</p>\n<p>TLB 的设计思想非常简单，但命中率往往非常高，效果很好。这就是因为被频繁访问的页就是其中的很小一部分。</p>\n<p>看完了之后你会发现快表和我们平时经常在开发系统中使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>\n<h4> 换页机制有什么用？</h4>\n<p>换页机制的思想是当物理内存不够用的时候，操作系统选择将一些物理页的内容放到磁盘上去，等要用到的时候再将它们读取到物理内存中。也就是说，换页机制利用磁盘这种较低廉的存储设备扩展的物理内存。</p>\n<p>这也就解释了一个日常使用电脑常见的问题：为什么操作系统中所有进程运行所需的物理内存即使比真实的物理内存要大一些，这些进程也是可以正常运行的，只是运行速度会变慢。</p>\n<p>这同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的物理内存空间来支持程序的运行。</p>\n<h4> 什么是页缺失？</h4>\n<p>根据维基百科:</p>\n<blockquote>\n<p>页缺失（Page Fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断。</p>\n</blockquote>\n<p>常见的页缺失有下面这两种：</p>\n<ul>\n<li><strong>硬性页缺失（Hard Page Fault）</strong>：物理内存中没有对应的物理页。于是，Page Fault Handler 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。</li>\n<li><strong>软性页缺失（Soft Page Fault）</strong>：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Handler 会指示 MMU 建立相应的虚拟页和物理页的映射关系。</li>\n</ul>\n<p>发生上面这两种缺页错误的时候，应用程序访问的是有效的物理内存，只是出现了物理页缺失或者虚拟页和物理页的映射关系未建立的问题。如果应用程序访问的是无效的物理内存的话，还会出现 <strong>无效缺页错误（Invalid Page Fault）</strong> 。</p>\n<h4> 常见的页面置换算法有哪些?</h4>\n<p>当发生硬性页缺失时，如果物理内存中没有空闲的物理页面可用的话。操作系统就必须将物理内存中的一个物理页淘汰出去，这样就可以腾出空间来加载新的页面了。</p>\n<p>用来选择淘汰哪一个物理页的规则叫做 <strong>页面置换算法</strong> ，我们可以把页面置换算法看成是淘汰物物理页的规则。</p>\n<p>页缺失太频繁的发生会非常影响性能，一个好的页面置换算法应该是可以减少页缺失出现的次数。</p>\n<p>常见的页面置换算法有下面这 5 种（其他还有很多页面置换算法都是基于这些算法改进得来的）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/image-20230409113009139.png\" alt=\"常见的页面置换算法\" tabindex=\"0\"><figcaption>常见的页面置换算法</figcaption></figure>\n<ol>\n<li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li>\n<li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li>\n<li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li>\n<li><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</li>\n<li><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</li>\n</ol>\n<p><strong>FIFO 页面置换算法性能为何不好？</strong></p>\n<p>主要原因主要有二：</p>\n<ol>\n<li><strong>经常访问或者需要长期存在的页面会被频繁调入调出</strong>：较早调入的页往往是经常被访问或者需要长期存在的页，这些页会被反复调入和调出。</li>\n<li><strong>存在 Belady 现象</strong>：被置换的页面并不是进程不会访问的，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。出现该异常的原因是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面访问的频率和紧迫性。</li>\n</ol>\n<p><strong>哪一种页面置换算法实际用的比较多？</strong></p>\n<p>LRU 算法是实际使用中应用的比较多，也被认为是最接近 OPT 的页面置换算法。</p>\n<p>不过，需要注意的是，实际应用中这些算法会被做一些改进，就比如 InnoDB Buffer Pool（ InnoDB 缓冲池，MySQL 数据库中用于管理缓存页面的机制）就改进了传统的 LRU 算法，使用了一种称为\"Adaptive LRU\"的算法（同时结合了 LRU 和 LFU 算法的思想）。</p>\n<h3> 分页机制和分段机制有哪些共同点和区别？</h3>\n<p><strong>共同点</strong>：</p>\n<ul>\n<li>都是非连续内存管理的方式。</li>\n<li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li>\n</ul>\n<p><strong>区别</strong>：</p>\n<ul>\n<li>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</li>\n<li>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</li>\n<li>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</li>\n<li>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</li>\n</ul>\n<h3> 段页机制</h3>\n<p>结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</p>\n<p>在段页式机制下，地址翻译的过程分为两个步骤：</p>\n<ol>\n<li>段式地址映射。</li>\n<li>页式地址映射。</li>\n</ol>\n<h3> 局部性原理</h3>\n<p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 <strong>局部性原理（Locality Principle）</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>\n<p>局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>\n<p>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：</p>\n<ul>\n<li><strong>时间局部性</strong>：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。</li>\n<li><strong>空间局部性</strong>：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。</li>\n</ul>\n<p>总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p>\n<h2> 文件系统</h2>\n<h3> 文件系统主要做了什么？</h3>\n<p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：</p>\n<ol>\n<li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</li>\n<li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li>\n<li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li>\n<li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。</li>\n</ol>\n<h3> 硬链接和软链接有什么区别？</h3>\n<p>在 Linux/类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：</p>\n<p><strong>1、硬链接（Hard Link）</strong></p>\n<ul>\n<li>在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li>\n<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>\n<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>\n<li><code>ln</code> 命令用于创建硬链接。</li>\n</ul>\n<p><strong>2、软链接（Symbolic Link 或 Symlink）</strong></p>\n<ul>\n<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li>\n<li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li>\n<li>软连接类似于 Windows 系统中的快捷方式。</li>\n<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>\n<li><code>ln -s</code> 命令用于创建软链接。</li>\n</ul>\n<h3> 硬链接为什么不能跨文件系统？</h3>\n<p>我们之前提到过，硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</p>\n<p>然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</p>\n<h3> 提高文件系统性能的方式有哪些？</h3>\n<ul>\n<li><strong>优化硬件</strong>：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li>\n<li><strong>选择合适的文件系统选型</strong>：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li>\n<li><strong>运用缓存</strong>：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li>\n<li><strong>避免磁盘过度使用</strong>：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li>\n<li><strong>对磁盘进行合理的分区</strong>：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li>\n</ul>\n<h3> 常见的磁盘调度算法有哪些？</h3>\n<p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p>\n<p>一次磁盘读写操作的时间由磁盘寻道/寻找时间、延迟时间和传输时间决定。磁盘调度算法可以通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间。</p>\n<p>常见的磁盘调度算法有下面这 6 种（其他还有很多磁盘调度算法都是基于这些算法改进得来的）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/disk-scheduling-algorithms.png\" alt=\"常见的磁盘调度算法\" tabindex=\"0\"><figcaption>常见的磁盘调度算法</figcaption></figure>\n<ol>\n<li><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li>\n<li><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li>\n<li><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li>\n<li><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</li>\n<li><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</li>\n<li><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</li>\n</ol>\n<h2> 参考</h2>\n<ul>\n<li>《计算机操作系统—汤小丹》第四版</li>\n<li>《深入理解计算机系统》</li>\n<li>《重学操作系统》</li>\n<li>《现代操作系统原理与实现》</li>\n<li>王道考研操作系统知识点整理：<a href=\"https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</a></li>\n<li>内存管理之伙伴系统与 SLAB：<a href=\"https://blog.csdn.net/qq_44272681/article/details/124199068\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_44272681/article/details/124199068</a></li>\n<li>为什么 Linux 需要虚拟内存：<a href=\"https://draveness.me/whys-the-design-os-virtual-memory/\" target=\"_blank\" rel=\"noopener noreferrer\">https://draveness.me/whys-the-design-os-virtual-memory/</a></li>\n<li>程序员的自我修养（七）：内存缺页错误：<a href=\"https://liam.page/2017/09/01/page-fault/\" target=\"_blank\" rel=\"noopener noreferrer\">https://liam.page/2017/09/01/page-fault/</a></li>\n<li>虚拟内存的那点事儿：<a href=\"https://juejin.cn/post/6844903507594575886\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903507594575886</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png",
      "date_published": "2023-04-09T12:09:19.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "Java 20 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java20.html",
      "id": "https://javaguide.cn/java/new-features/java20.html",
      "summary": "JDK 20 于 2023 年 3 月 21 日发布，非长期支持版本。 根据开发计划，下一个 LTS 版本就是将于 2023 年 9 月发布的 JDK 21。 JDK 20 只有 7 个新特性： JEP 429：Scoped Values（作用域值）（第一次孵化） JEP 432：Record Patterns（记录模式）（第二次预览） JEP 433：switch 模式匹配（第四次预览） JEP 434: Foreign Function &amp; Memory API（外部函数和内存 API）（第二次预览） JEP 436: Virtual Threads（虚拟线程）（第二次预览） JEP 437:Structured Concurrency（结构化并发）(第二次孵化) JEP 432:向量 API（第五次孵化）",
      "content_html": "<p>JDK 20 于 2023 年 3 月 21 日发布，非长期支持版本。</p>\n<p>根据开发计划，下一个 LTS 版本就是将于 2023 年 9 月发布的 JDK 21。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/new-features/640.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>JDK 20 只有 7 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.org/jeps/429\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 429：Scoped Values（作用域值）</a>（第一次孵化）</li>\n<li><a href=\"https://openjdk.org/jeps/432\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 432：Record Patterns（记录模式）</a>（第二次预览）</li>\n<li><a href=\"https://openjdk.org/jeps/433\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 433：switch 模式匹配</a>（第四次预览）</li>\n<li><a href=\"https://openjdk.org/jeps/434\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 434: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次预览）</li>\n<li><a href=\"https://openjdk.org/jeps/436\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 436: Virtual Threads（虚拟线程）</a>（第二次预览）</li>\n<li><a href=\"https://openjdk.org/jeps/437\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 437:Structured Concurrency（结构化并发）</a>(第二次孵化)</li>\n<li><a href=\"https://openjdk.org/jeps/438\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 432:向量 API（</a>第五次孵化）</li>\n</ul>\n<h2> JEP 429：作用域值（第一次孵化）</h2>\n<p>作用域值（Scoped Values）它可以在线程内和线程间共享不可变的数据，优于线程局部变量，尤其是在使用大量虚拟线程时。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>作用域值允许在大型程序中的组件之间安全有效地共享数据，而无需求助于方法参数。</p>\n<p>关于作用域值的详细介绍，推荐阅读<a href=\"https://www.happycoders.eu/java/scoped-values/\" target=\"_blank\" rel=\"noopener noreferrer\">作用域值常见问题解答</a>这篇文章。</p>\n<h2> JEP 432：记录模式（第二次预览）</h2>\n<p>记录模式（Record Patterns） 可对 record 的值进行解构，也就是更方便地从记录类（Record Class）中提取数据。并且，还可以嵌套记录模式和类型模式结合使用，以实现强大的、声明性的和可组合的数据导航和处理形式。</p>\n<p>记录模式不能单独使用，而是要与 instanceof 或 switch 模式匹配一同使用。</p>\n<p>先以 instanceof 为例简单演示一下。</p>\n<p>简单定义一个记录类：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>没有记录模式之前：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有了记录模式之后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再看看记录模式与 switch 的配合使用。</p>\n<p>定义一些类：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没有记录模式之前：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有了记录模式之后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>记录模式可以避免不必要的转换，使得代码更建简洁易读。而且，用了记录模式后不必再担心 <code>null</code> 或者 <code>NullPointerException</code>，代码更安全可靠。</p>\n<p>记录模式在 Java 19 进行了第一次预览， 由 <a href=\"https://openjdk.org/jeps/405\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href=\"https://openjdk.org/jeps/432\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 432</a> 提出。这次的改进包括：</p>\n<ul>\n<li>添加对通用记录模式类型参数推断的支持，</li>\n<li>添加对记录模式的支持以出现在增强语句的标题中<code>for</code></li>\n<li>删除对命名记录模式的支持。</li>\n</ul>\n<p><strong>注意</strong>：不要把记录模式和 <a href=\"/java/new-features/java16.html\" target=\"blank\">JDK16</a> 正式引入的记录类搞混了。</p>\n<h2> JEP 433：switch 模式匹配（第四次预览）</h2>\n<p>正如 <code>instanceof</code> 一样， <code>switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>\n<p><code>instanceof</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>switch</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>switch</code> 模式匹配分别在 Java17、Java18、Java19 中进行了预览，Java20 是第四次预览了。每一次的预览基本都会有一些小改进，这里就不细提了。</p>\n<h2> JEP 434: 外部函数和内存 API（第二次预览）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出。</p>\n<p>JDK 20 中是第二次预览，由 <a href=\"https://openjdk.org/jeps/434\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 434</a> 提出，这次的改进包括：</p>\n<ul>\n<li><code>MemorySegment</code> 和 <code>MemoryAddress</code> 抽象的统一</li>\n<li>增强的 <code>MemoryLayout</code> 层次结构</li>\n<li><code>MemorySession</code>拆分为<code>Arena</code>和<code>SegmentScope</code>，以促进跨维护边界的段共享。</li>\n</ul>\n<p>在 <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 436: 虚拟线程（第二次预览）</h2>\n<p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程，也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：<a href=\"https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7\" target=\"_blank\" rel=\"noopener noreferrer\">How to Use Java 19 Virtual Threads</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png\" alt=\"虚拟线程、平台线程和系统内核线程的关系\" tabindex=\"0\"><figcaption>虚拟线程、平台线程和系统内核线程的关系</figcaption></figure>\n<p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: <a href=\"https://www.zhihu.com/question/23096638/answer/29617153\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 中的线程模型是用户级的么？</a>。</p>\n<p>相比较于平台线程来说，虚拟线程是廉价且轻量级的，使用完后立即被销毁，因此它们不需要被重用或池化，每个任务可以有自己专属的虚拟线程来运行。虚拟线程暂停和恢复来实现线程之间的切换，避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>\n<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>\n<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：<a href=\"https://www.zhihu.com/question/536743167\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/536743167</a> 。</p>\n<p>Java 虚拟线程的详细解读和原理可以看下面这几篇文章：</p>\n<ul>\n<li><a href=\"https://javaguide.cn/java/concurrent/virtual-thread.html\" target=\"_blank\" rel=\"noopener noreferrer\">虚拟线程极简入门</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q\" target=\"_blank\" rel=\"noopener noreferrer\">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>\n<li><a href=\"https://www.cnblogs.com/throwable/p/16758997.html\" target=\"_blank\" rel=\"noopener noreferrer\">虚拟线程 - VirtualThread 源码透视</a></li>\n</ul>\n<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href=\"https://openjdk.org/jeps/425\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 425</a>提出。JDK 20 中是第二次预览，做了一些细微变化，这里就不细提了。</p>\n<p>最后，我们来看一下四种创建虚拟线程的方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上述列举的 4 种创建虚拟线程的方式可以看出，官方为了降低虚拟线程的门槛，尽力复用原有的 <code>Thread</code> 线程类，这样可以平滑的过渡到虚拟线程的使用。</p>\n<h2> JEP 437: 结构化并发(第二次孵化)</h2>\n<p>Java 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>\n<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>\n<p>结构化并发的基本 API 是<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>StructuredTaskScope</code></a>。<code>StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>\n<p><code>StructuredTaskScope</code> 的基本用法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>\n<p>JDK 20 中对结构化并发唯一变化是更新为支持在任务范围内创建的线程<code>StructuredTaskScope</code>继承范围值 这简化了跨线程共享不可变数据，详见<a href=\"https://openjdk.org/jeps/429\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 429</a>。</p>\n<h2> JEP 432：向量 API（第五次孵化）</h2>\n<p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>\n<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>Java20 的这次孵化基本没有改变向量 API ，只是进行了一些错误修复和性能增强，详见 <a href=\"https://openjdk.org/jeps/438\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 438</a>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/new-features/640.png",
      "date_published": "2023-03-27T07:25:00.000Z",
      "date_modified": "2023-10-30T05:32:52.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "从校招入职腾讯的四年工作总结",
      "url": "https://javaguide.cn/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary.html",
      "summary": "程序员是一个流动性很大的职业，经常会有新面孔的到来，也经常会有老面孔的离开，有主动离开的，也有被动离职的。 再加上这几年卷得厉害，做的事更多了，拿到的却更少了，互联网好像也没有那么香了。 人来人往，变动无常的状态，其实也早已习惯。 打工人的唯一出路，无外乎精进自己的专业技能，提升自己的核心竞争力，这样无论有什么变动，走到哪里，都能有口饭吃。 今天分享一位博主，校招入职腾讯，工作四年后，离开的故事。 至于为什么离开，我也不清楚，可能是有其他更好的选择，或者是觉得当前的工作对自己的提升有限。 下文中的“我”，指这位作者本人。",
      "content_html": "<p>程序员是一个流动性很大的职业，经常会有新面孔的到来，也经常会有老面孔的离开，有主动离开的，也有被动离职的。</p>\n<p>再加上这几年卷得厉害，做的事更多了，拿到的却更少了，互联网好像也没有那么香了。</p>\n<p>人来人往，变动无常的状态，其实也早已习惯。</p>\n<p>打工人的唯一出路，无外乎精进自己的专业技能，提升自己的核心竞争力，这样无论有什么变动，走到哪里，都能有口饭吃。</p>\n<p>今天分享一位博主，校招入职腾讯，工作四年后，离开的故事。</p>\n<p>至于为什么离开，我也不清楚，可能是有其他更好的选择，或者是觉得当前的工作对自己的提升有限。</p>\n<p><strong>下文中的“我”，指这位作者本人。</strong></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/602517682\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/602517682</a></p>\n</blockquote>\n<p>研究生毕业后， 一直在腾讯工作，不知不觉就过了四年。个人本身没有刻意总结的习惯，以前只顾着往前奔跑了，忘了停下来思考总结。记得看过一个职业规划文档，说的三年一个阶段，五年一个阶段的说法，现在恰巧是四年，同时又从腾讯离开，该做一个总结了。</p>\n<p>先对自己这四年做一个简单的评价吧：个人认为，没有完全的浪费和辜负这四年的光阴。为何要这么说了？因为我发现和别人对比，好像意义不大，比我混的好的人很多；比我混的差的人也不少。说到底，我只是一个普普通通的人，才不惊人，技不压众，接受自己的平凡，然后看自己做的，是否让自己满意就好。</p>\n<p>下面具体谈几点吧，我主要想聊下工作，绩效，EPC，嫡系看法，最后再谈下收获。</p>\n<h2> 工作情况</h2>\n<p>我在腾讯内部没有转过岗，但是做过的项目也还是比较丰富的，包括：BUGLY、分布式调用链（Huskie)、众包系统（SOHO)，EPC 度量系统。其中一些是对外的，一些是内部系统，可能有些大家不知道。还是比较感谢这些项目经历，既有纯业务的系统，也有偏框架的系统，让我学到了不少知识。</p>\n<p>接下来，简单介绍一下每个项目吧，毕竟每一个项目都付出了很多心血的：</p>\n<p>BUGLY，这是一个终端 Crash 联网上报的系统，很多 APP 都接入了。Huskie，这是一个基于 zipkin 搭建的分布式调用链跟踪项目。SOHO，这是一个众包系统，主要是将数据标准和语音采集任务众包出去，让人家做。EPC 度量系统，这是研发效能度量系统，主要是度量研发效能情况的。这里我谈一下对于业务开发的理解和认识，很多人可能都跟我最开始一样，有一个疑惑，整天做业务开发如何成长？换句话说，就是说整天做 CRUD，如何成长？我开始也有这样的疑惑，后来我转变了观念。</p>\n<p>我觉得对于系统的复杂度，可以粗略的分为技术复杂度和业务复杂度，对于业务系统，就是业务复杂度高一些，对于框架系统就是技术复杂度偏高一些。解决这两种复杂度，都具有很大的挑战。</p>\n<p>此前做过的众包系统，就是各种业务逻辑，搞过去，搞过来，其实这就是业务复杂度高。为了解决这个问题，我们开始探索和实践领域驱动（DDD），确实带来了一些帮助，不至于系统那么混乱了。同时，我觉得这个过程中，自己对于 DDD 的感悟，对于我后来的项目系统划分和设计以及开发都带来了帮助。</p>\n<p>当然 DDD 不是银弹，我也不是吹嘘它有多好，只是了解了它后，有时候设计和开发时，能换一种思路。</p>\n<p>可以发现，其实平时咱们做业务，想做好，其实也没那么容易，如果可以多探索多实践，将一些好的方法或思想或架构引入进来，与个人和业务都会有有帮助。</p>\n<h2> 绩效情况</h2>\n<p>我在腾讯工作四年，腾讯半年考核一次，一共考核八次，回想了下，四年来的绩效情况为:三星，三星，五星，三星，五星，四星，四星，三星。统计一下， 四五星占比刚好一半。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/640.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>PS：还好以前有奖杯，不然一点念想都没了。(现在腾讯似乎不发了）</p>\n<p>印象比较深的是两次五星获得经历。第一次五星是工作的第二年，那一年是在做众包项目，因为项目本身难度不大，因此我把一些精力投入到了团队的基础建设中，帮团队搭建了 java 以及 golang 的项目脚手架，又做了几次中心技术分享，最终 Leader 觉得我表现比较突出，因此给了我五星。看来，主动一些，与个人与团队都是有好处的，最终也能获得一些回报。</p>\n<p>第二次五星，就是与 EPC 有关了。说一个搞笑的事，我也是后来才知道的，项目初期，总监去汇报时，给老板演示系统，加载了很久指标才刷出来，总监很不好意思的说正在优化；过了一段时间，又去汇报演示，结果又很尴尬的刷了很久才出来，总监无赖表示还是在优化。没想到，自己曾经让总监这么丢脸，哈哈。好吧，说一下结果，最终，我自己写了一个查询引擎替换了 Mondrian，之后再也没有出现那种尴尬的情况了。随之而来，也给了好绩效鼓励。做 EPC 度量项目，我觉得自己成长很大，比如抗压能力，当你从零到一搭建一个系统时，会有一个先扛住再优化的过程，此外如果你的项目很重要，尤其是数据相关，那么任何一点问题，都可能让你神经紧绷，得想尽办法降低风险和故障。此外，另一个不同的感受就是，以前得项目，我大多是开发者，而这个系统，我是 Owner 负责人，当你 Owner 一个系统时，你得时刻负责，同时还需要思考系统的规划和方向，此外还需要分配好需求和把控进度，角色体验跟以前完全不一样。</p>\n<h2> 谈谈 EPC</h2>\n<p>很多人都骂 EPC，或者笑 EPC，作为度量平台核心开发者之一，我来谈谈客观的看法。</p>\n<p>其实 EPC 初衷是好的，希望通过全方位多维度的研效指标，来度量研发效能各环节的质量，进而反推业务，提升研发效能。然而，最终在实践的过程中，才发现，客观条件并不支持（工具还没建设好）；此外，一味的追求指标数据，使得下面的人想方设法让指标好看，最终违背了初衷。</p>\n<p>为什么，说 EPC 好了，其实如果你仔细了解下 EPC，你就会发现，他是一套相当完善且比较先进的指标度量体系。覆盖了需求，代码，缺陷，测试，持续集成，运营部署各个环节。</p>\n<p>此外，这个过程中，虽然一些人和一些业务做弊，但绝大多数业务还是做出了改变的，比如微视那边的人反馈是，以前的代码写的跟屎一样，当有了 EPC 后，代码质量好了很多。虽然最后微视还是亡了，但是大厦将倾，EPC 是救不了的，亡了也更不能怪 EPC。</p>\n<h2> 谈谈嫡系</h2>\n<p>大家都说腾讯，嫡系文化盛行。但其实我觉得在那个公司都一样吧。这也符合事物的基本规律，人们只相信自己信任并熟悉的人。作为领导，你难道会把把重要的事情交给自己不熟悉的人吗？</p>\n<p>其实我也不知道我算不算嫡系，脉脉上有人问过”怎么知道自己算不算嫡系”，下面有一个回答，我觉得很妙：如果你不知道你是不是嫡系，那你就不是。哈哈，这么说来，我可能不是。</p>\n<p>但另一方面，后来我负责了团队内很重要的事情，应该是中心内都算很重要的事，我独自负责一个方向，直接向总监汇报，似乎又有点像。</p>\n<p>网上也有其他说法，一针见血，是不是嫡系，就看钱到不到位，这么说也有道理。我在 7 级时，就发了股票，自我感觉，还是不错的。我当时以为不出意外的话，我以后的钱途和发展是不是就会一帆风顺。不出意外就出了意外，第二年，EPC 不达预期，部门总经理和总监都被换了，中心来了一个新的的总监。</p>\n<p>好吧，又要重新建立信任了。再到后来，是不是嫡系已经不重要了，因为大环境不好，又加上裁员，大家主动的被动的差不多都走了。</p>\n<p>总结一下，嫡系的存在，其实情有可原。怎么样成为嫡系了？其实我也不知道。不过，我觉得，与其思考怎么成为嫡系，不如思考怎么展现自己的价值和能力，当别人发现你的价值和能力了，那自然更多的机会就会给予你，有了机会，只要把握住了，那就有更多的福利了。</p>\n<h2> 再谈收获</h2>\n<p>收获，什么叫做收获了？个人觉得无论是外在的物质，技能，职级；还是内在的感悟，认识，都算收获。</p>\n<p>先说一些可量化的吧，我觉得有:</p>\n<ul>\n<li>级别上，升上了九级，高级工程师。虽然大家都在说腾讯职级缩水，但是有没有高工的能力自己其实是知道的，我个人感觉，通过我这几年的努力，我算是达到了我当时认为的我需要在高工时达到的状态；</li>\n<li>绩效上，自我评价，个人不是一个特别卷的人，或者说不会为了卷而卷。但是，如果我认定我应该把它做好得，我的 Owner 意识，以及负责态度，我觉得还是可以的。最终在腾讯四年的绩效也还算过的去。再谈一些其他软技能方面:</li>\n</ul>\n<p><strong>1、文档能力</strong></p>\n<p>作为程序员，文档能力其实是一项很重要的能力。其实我也没觉得自己文档能力有多好，但是前后两任总监，都说我的文档不错，那看来，我可能在平均水准之上。</p>\n<p><strong>2、明确方向</strong></p>\n<p>最后，说一个更虚的，但是我觉得最有价值的收获: 我逐渐明确了，或者确定了以后的方向和路，那就是走数据开发。</p>\n<p>其实，找到并确定一个目标很难，身边有清晰目标和方向的人很少，大多数是迷茫的。</p>\n<p>前一段时间，跟人聊天，谈到职业规划，说是可以从两个角度思考：</p>\n<ul>\n<li>选一个业务方向，比如电商，广告，不断地积累业务领域知识和业务相关技能，随着经验的不断积累，最终你就是这个领域的专家。</li>\n<li>深入一个技术方向，不断钻研底层技术知识，这样就有希望成为此技术专家。坦白来说，虽然我深入研究并实践过领域驱动设计，也用来建模和解决了一些复杂业务问题，但是发自内心的，我其实更喜欢钻研技术，同时，我又对大数据很感兴趣。因此，我决定了，以后的方向，就做数据相关的工作。</li>\n</ul>\n<p>腾讯的四年，是我的第一份工作经历，认识了很多厉害的人，学到了很多。最后自己主动离开，也算走的体面（即使损失了大礼包），还是感谢腾讯。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/640.png",
      "date_published": "2023-03-24T11:23:46.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [
        {
          "name": "pioneeryi"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "Redis持久化机制详解",
      "url": "https://javaguide.cn/database/redis/redis-persistence.html",
      "id": "https://javaguide.cn/database/redis/redis-persistence.html",
      "summary": "使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。 Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式: 快照（snapshotting，RDB） 只追加文件（append-only file, AOF） RDB 和 AOF 的混合持久化(Redis 4.0 新增)",
      "content_html": "<p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>\n<ul>\n<li>快照（snapshotting，RDB）</li>\n<li>只追加文件（append-only file, AOF）</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<p>官方文档地址：<a href=\"https://redis.io/topics/persistence\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/persistence</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> RDB 持久化</h2>\n<h3> 什么是 RDB 持久化？</h3>\n<p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>\n<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>\n<div class=\"language-clojure line-numbers-mode\" data-ext=\"clojure\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> RDB 创建快照时会阻塞主线程吗？</h3>\n<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>\n<ul>\n<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>\n<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<blockquote>\n<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。</p>\n</blockquote>\n<h2> AOF 持久化</h2>\n<h3> 什么是 AOF 持久化？</h3>\n<p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>\n<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>\n<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>\n<h3> AOF 工作基本流程是怎样的？</h3>\n<p>AOF 持久化功能的实现可以简单分为 5 步：</p>\n<ol>\n<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>\n<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>\n<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>\n<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>\n<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>\n</ol>\n<blockquote>\n<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p>\n</blockquote>\n<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>\n<ul>\n<li><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</li>\n<li><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li>\n</ul>\n<p>AOF 工作流程图如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aof-work-process.png\" alt=\"AOF 工作基本流程\" tabindex=\"0\"><figcaption>AOF 工作基本流程</figcaption></figure>\n<h3> AOF 持久化方式有哪些？</h3>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<ol>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>\n</ol>\n<p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p>\n<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>\n<p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>\n<ul>\n<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>\n<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>\n<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>\n</ul>\n<p>Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的<a href=\"https://zhuanlan.zhihu.com/p/467217082\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 7.0 Multi Part AOF 的设计和实现</a> 这篇文章。</p>\n<p><strong>相关 issue</strong>：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/783\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 的 AOF 方式 #783</a>。</p>\n<h3> AOF 为什么是在执行完命令之后记录日志？</h3>\n<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" tabindex=\"0\"><figcaption>AOF 记录日志过程</figcaption></figure>\n<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>\n<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>\n</ul>\n<h3> AOF 重写了解吗？</h3>\n<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aof-rewrite.png\" alt=\"AOF 重写\" tabindex=\"0\"><figcaption>AOF 重写</figcaption></figure>\n<blockquote>\n<p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>\n</blockquote>\n<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>\n<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>\n<p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p>\n<ul>\n<li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li>\n<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li>\n</ul>\n<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>\n<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的<a href=\"https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg\" target=\"_blank\" rel=\"noopener noreferrer\">从 Redis7.0 发布看 Redis 的过去与未来</a> 这篇文章。</p>\n<blockquote>\n<p>AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。</p>\n<p>阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>\n</blockquote>\n<p><strong>相关 issue</strong>：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1439\" target=\"_blank\" rel=\"noopener noreferrer\">Redis AOF 重写描述不准确 #1439</a>。</p>\n<h3> AOF 校验机制了解吗？</h3>\n<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>\n<p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p>\n<h2> Redis 4.0 对于持久化机制做了什么优化？</h2>\n<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>\n<p>官方文档地址：<a href=\"https://redis.io/topics/persistence\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/persistence</a></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 如何选择 RDB 和 AOF？</h2>\n<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href=\"https://redis.io/docs/manual/persistence/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis persistence</a>，这里结合自己的理解简单总结一下。</p>\n<p><strong>RDB 比 AOF 优秀的地方</strong>：</p>\n<ul>\n<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>\n<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>\n</ul>\n<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>\n<ul>\n<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>\n<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>\n<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>\n</ul>\n<p><strong>综上</strong>：</p>\n<ul>\n<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>\n<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>\n<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Redis 设计与实现》</li>\n<li>Redis persistence - Redis 官方文档：<a href=\"https://redis.io/docs/management/persistence/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/docs/management/persistence/</a></li>\n<li>The difference between AOF and RDB persistence：<a href=\"https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/</a></li>\n<li>Redis AOF 持久化详解 - 程序员历小冰：<a href=\"http://remcarpediem.net/article/376c55d8/\" target=\"_blank\" rel=\"noopener noreferrer\">http://remcarpediem.net/article/376c55d8/</a></li>\n<li>Redis RDB 与 AOF 持久化 · Analyze：<a href=\"https://wingsxdu.com/posts/database/redis/rdb-and-aof/\" target=\"_blank\" rel=\"noopener noreferrer\">https://wingsxdu.com/posts/database/redis/rdb-and-aof/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png",
      "date_published": "2023-03-23T13:09:30.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis常见阻塞原因总结",
      "url": "https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html",
      "id": "https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html",
      "summary": "本文整理完善自：https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA ，作者：阿 Q 说代码 这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！ O(n) 命令",
      "content_html": "<blockquote>\n<p>本文整理完善自：<a href=\"https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA</a> ，作者：阿 Q 说代码</p>\n</blockquote>\n<p>这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！</p>\n<h2> O(n) 命令</h2>\n<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>\n<ul>\n<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>\n<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>\n<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>\n<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>\n<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>\n<li>……</li>\n</ul>\n<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>\n<p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>\n<ul>\n<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li>……</li>\n</ul>\n<h2> SAVE 创建 RDB 快照</h2>\n<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>\n<ul>\n<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>\n<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<p>默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p>\n<h2> AOF</h2>\n<h3> AOF 日志记录阻塞</h3>\n<p>Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png\" alt=\"AOF 记录日志过程\" tabindex=\"0\"><figcaption>AOF 记录日志过程</figcaption></figure>\n<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>\n<li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li>\n</ul>\n<h3> AOF 刷盘阻塞</h3>\n<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<ol>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>\n</ol>\n<p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p>\n<p>关于 AOF 工作流程的详细介绍可以查看：<a href=\"/database/redis/redis-persistence.html\" target=\"blank\">Redis 持久化机制详解</a>，有助于理解 AOF 刷盘阻塞。</p>\n<h3> AOF 重写阻塞</h3>\n<ol>\n<li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>\n<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>\n<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>\n</ol>\n<p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p>\n<p>相关阅读：<a href=\"https://cloud.tencent.com/developer/article/1633077\" target=\"_blank\" rel=\"noopener noreferrer\">Redis AOF 重写阻塞问题分析</a>。</p>\n<h2> 大 Key</h2>\n<p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：</p>\n<ul>\n<li>string 类型的 value 超过 1MB</li>\n<li>复合类型（列表、哈希、集合、有序集合等）的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</li>\n</ul>\n<p>大 key 造成的阻塞问题如下：</p>\n<ul>\n<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>\n<li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>\n<li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n</ul>\n<h3> 查找大 key</h3>\n<p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>\n<ul>\n<li>\n<p>我们还可以使用 SCAN 命令来查找大 key；</p>\n</li>\n<li>\n<p>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</p>\n</li>\n<li>\n<ul>\n<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n</li>\n</ul>\n<h3> 删除大 key</h3>\n<p>删除操作的本质是要释放键值对占用的内存空间。</p>\n<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p>\n<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>\n<p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p>\n<h2> 清空数据库</h2>\n<p>清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p>\n<h2> 集群扩容</h2>\n<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p>\n<p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p>\n<p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>\n<h2> Swap（内存交换）</h2>\n<p><strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>\n<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘的读写速度差几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>\n<p>识别 Redis 发生 Swap 的检查方法如下：</p>\n<p>1、查询 Redis 进程号</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2、根据进程号查询内存交换信息</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>\n<p>预防内存交换的方法：</p>\n<ul>\n<li>保证机器充足的可用内存</li>\n<li>确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长</li>\n<li>降低系统使用 swap 优先级，如<code>echo 10 &gt; /proc/sys/vm/swappiness</code></li>\n</ul>\n<h2> CPU 竞争</h2>\n<p>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>\n<p>可以通过<code>reids-cli --stat</code>获取当前 Redis 使用情况。通过<code>top</code>命令获取进程对 CPU 的利用率等信息 通过<code>info commandstats</code>统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>\n<h2> 网络问题</h2>\n<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>\n<h2> 参考</h2>\n<ul>\n<li>Redis 阻塞的 6 大类场景分析与总结：<a href=\"https://mp.weixin.qq.com/s/eaZCEtTjTuEmXfUubVHjew\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/eaZCEtTjTuEmXfUubVHjew</a></li>\n<li>Redis 开发与运维笔记-Redis 的噩梦-阻塞：<a href=\"https://mp.weixin.qq.com/s/TDbpz9oLH6ifVv6ewqgSgA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/TDbpz9oLH6ifVv6ewqgSgA</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png",
      "date_published": "2023-03-23T10:25:39.000Z",
      "date_modified": "2023-11-01T09:34:39.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL查询缓存详解",
      "url": "https://javaguide.cn/database/mysql/mysql-query-cache.html",
      "id": "https://javaguide.cn/database/mysql/mysql-query-cache.html",
      "summary": "缓存是一个有效且实用的系统性能优化的手段，不论是操作系统还是各种软件和网站或多或少都用到了缓存。 然而，有经验的 DBA 都建议生产环境中把 MySQL 自带的 Query Cache（查询缓存）给关掉。而且，从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0 及之后，更是直接删除了查询缓存的功能。 这又是为什么呢？查询缓存真就这么鸡肋么? 带着如下几个问题，我们正式进入本文。 MySQL 查询缓存是什么？适用范围？ MySQL 缓存规则是什么？ MySQL 缓存的优缺点是什么？ MySQL 缓存对性能有什么影响？",
      "content_html": "<p>缓存是一个有效且实用的系统性能优化的手段，不论是操作系统还是各种软件和网站或多或少都用到了缓存。</p>\n<p>然而，有经验的 DBA 都建议生产环境中把 MySQL 自带的 Query Cache（查询缓存）给关掉。而且，从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0 及之后，更是直接删除了查询缓存的功能。</p>\n<p>这又是为什么呢？查询缓存真就这么鸡肋么?</p>\n<p>带着如下几个问题，我们正式进入本文。</p>\n<ul>\n<li>MySQL 查询缓存是什么？适用范围？</li>\n<li>MySQL 缓存规则是什么？</li>\n<li>MySQL 缓存的优缺点是什么？</li>\n<li>MySQL 缓存对性能有什么影响？</li>\n</ul>\n<h2> MySQL 查询缓存介绍</h2>\n<p>MySQL 体系架构如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>为了提高完全相同的查询语句的响应速度，MySQL Server 会对查询语句进行 Hash 计算得到一个 Hash 值。MySQL Server 不会对 SQL 做任何处理，SQL 必须完全一致 Hash 值才会一样。得到 Hash 值之后，通过该 Hash 值到查询缓存中匹配该查询的结果。</p>\n<ul>\n<li>如果匹配（命中），则将查询的结果集直接返回给客户端，不必再解析、执行查询。</li>\n<li>如果没有匹配（未命中），则将 Hash 值和结果集保存在查询缓存中，以便以后使用。</li>\n</ul>\n<p>也就是说，<strong>一个查询语句（select）到了 MySQL Server 之后，会先到查询缓存看看，如果曾经执行过的话，就直接返回结果集给客户端。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> MySQL 查询缓存管理和配置</h2>\n<p>通过 <code>show variables like '%query_cache%'</code>命令可以查看查询缓存相关的信息。</p>\n<p>8.0 版本之前的话，打印的信息可能是下面这样的：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>8.0 以及之后版本之后，打印的信息是下面这样的：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们这里对 8.0 版本之前<code>show variables like '%query_cache%';</code>命令打印出来的信息进行解释。</p>\n<ul>\n<li><strong><code>have_query_cache</code>：</strong> 该 MySQL Server 是否支持查询缓存，如果是 YES 表示支持，否则则是不支持。</li>\n<li><strong><code>query_cache_limit</code>：</strong> MySQL 查询缓存的最大查询结果，查询结果大于该值时不会被缓存。</li>\n<li><strong><code>query_cache_min_res_unit</code>：</strong> 查询缓存分配的最小块的大小(字节)。当查询进行的时候，MySQL 把查询结果保存在查询缓存中，但如果要保存的结果比较大，超过 <code>query_cache_min_res_unit</code> 的值 ，这时候 MySQL 将一边检索结果，一边进行保存结果，也就是说，有可能在一次查询中，MySQL 要进行多次内存分配的操作。适当的调节 <code>query_cache_min_res_unit</code> 可以优化内存。</li>\n<li><strong><code>query_cache_size</code>：</strong> 为缓存查询结果分配的内存的数量，单位是字节，且数值必须是 1024 的整数倍。默认值是 0，即禁用查询缓存。</li>\n<li><strong><code>query_cache_type</code>：</strong> 设置查询缓存类型，默认为 ON。设置 GLOBAL 值可以设置后面的所有客户端连接的类型。客户端可以设置 SESSION 值以影响他们自己对查询缓存的使用。</li>\n<li><strong><code>query_cache_wlock_invalidate</code></strong>：如果某个表被锁住，是否返回缓存中的数据，默认关闭，也是建议的。</li>\n</ul>\n<p><code>query_cache_type</code> 可能的值(修改 <code>query_cache_type</code> 需要重启 MySQL Server)：</p>\n<ul>\n<li>0 或 OFF：关闭查询功能。</li>\n<li>1 或 ON：开启查询缓存功能，但不缓存 <code>Select SQL_NO_CACHE</code> 开头的查询。</li>\n<li>2 或 DEMAND：开启查询缓存功能，但仅缓存 <code>Select SQL_CACHE</code> 开头的查询。</li>\n</ul>\n<p><strong>建议</strong>：</p>\n<ul>\n<li>\n<p><code>query_cache_size</code>不建议设置的过大。过大的空间不但挤占实例其他内存结构的空间，而且会增加在缓存中搜索的开销。建议根据实例规格，初始值设置为 10MB 到 100MB 之间的值，而后根据运行使用情况调整。</p>\n</li>\n<li>\n<p>建议通过调整 <code>query_cache_size</code> 的值来开启、关闭查询缓存，因为修改<code>query_cache_type</code> 参数需要重启 MySQL Server 生效。</p>\n<p>8.0 版本之前，<code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>\n</li>\n</ul>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>或者，MySQL 执行以下命令也可以开启查询缓存</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>手动清理缓存可以使用下面三个 SQL：</p>\n<ul>\n<li><code>flush query cache;</code>：清理查询缓存内存碎片。</li>\n<li><code>reset query cache;</code>：从查询缓存中移除所有查询。</li>\n<li><code>flush tables；</code> 关闭所有打开的表，同时该操作会清空查询缓存中的内容。</li>\n</ul>\n<h2> MySQL 缓存机制</h2>\n<h3> 缓存规则</h3>\n<ul>\n<li>查询缓存会将查询语句和结果集保存到内存（一般是 key-value 的形式，key 是查询语句，value 是查询的结果集），下次再查直接从内存中取。</li>\n<li>缓存的结果是通过 sessions 共享的，所以一个 client 查询的缓存结果，另一个 client 也可以使用。</li>\n<li>SQL 必须完全一致才会导致查询缓存命中（大小写、空格、使用的数据库、协议版本、字符集等必须一致）。检查查询缓存时，MySQL Server 不会对 SQL 做任何处理，它精确的使用客户端传来的查询。</li>\n<li>不缓存查询中的子查询结果集，仅缓存查询最终结果集。</li>\n<li>不确定的函数将永远不会被缓存, 比如 <code>now()</code>、<code>curdate()</code>、<code>last_insert_id()</code>、<code>rand()</code> 等。</li>\n<li>不缓存产生告警（Warnings）的查询。</li>\n<li>太大的结果集不会被缓存 (&lt; query_cache_limit)。</li>\n<li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n<li>MySQL 缓存在分库分表环境下是不起作用的。</li>\n<li>不缓存使用 <code>SQL_NO_CACHE</code> 的查询。</li>\n<li>……</li>\n</ul>\n<p>查询缓存 <code>SELECT</code> 选项示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 缓存机制中的内存管理</h3>\n<p>查询缓存是完全存储在内存中的，所以在配置和使用它之前，我们需要先了解它是如何使用内存的。</p>\n<p>MySQL 查询缓存使用内存池技术，自己管理内存释放和分配，而不是通过操作系统。内存池使用的基本单位是变长的 block, 用来存储类型、大小、数据等信息。一个结果集的缓存通过链表把这些 block 串起来。block 最短长度为 <code>query_cache_min_res_unit</code>。</p>\n<p>当服务器启动的时候，会初始化缓存需要的内存，是一个完整的空闲块。当查询结果需要缓存的时候，先从空闲块中申请一个数据块为参数 <code>query_cache_min_res_unit</code> 配置的空间，即使缓存数据很小，申请数据块也是这个，因为查询开始返回结果的时候就分配空间，此时无法预知结果多大。</p>\n<p>分配内存块需要先锁住空间块，所以操作很慢，MySQL 会尽量避免这个操作，选择尽可能小的内存块，如果不够，继续申请，如果存储完时有空余则释放多余的。</p>\n<p>但是如果并发的操作，余下的需要回收的空间很小，小于 <code>query_cache_min_res_unit</code>，不能再次被使用，就会产生碎片。</p>\n<h2> MySQL 查询缓存的优缺点</h2>\n<p><strong>优点：</strong></p>\n<ul>\n<li>查询缓存的查询，发生在 MySQL 接收到客户端的查询请求、查询权限验证之后和查询 SQL 解析之前。也就是说，当 MySQL 接收到客户端的查询 SQL 之后，仅仅只需要对其进行相应的权限验证之后，就会通过查询缓存来查找结果，甚至都不需要经过 Optimizer 模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互。</li>\n<li>由于查询缓存是基于内存的，直接从内存中返回相应的查询结果，因此减少了大量的磁盘 I/O 和 CPU 计算，导致效率非常高。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>MySQL 会对每条接收到的 SELECT 类型的查询进行 Hash 计算，然后查找这个查询的缓存结果是否存在。虽然 Hash 计算和查找的效率已经足够高了，一条查询语句所带来的开销可以忽略，但一旦涉及到高并发，有成千上万条查询语句时，hash 计算和查找所带来的开销就必须重视了。</li>\n<li>查询缓存的失效问题。如果表的变更比较频繁，则会造成查询缓存的失效率非常高。表的变更不仅仅指表中的数据发生变化，还包括表结构或者索引的任何变化。</li>\n<li>查询语句不同，但查询结果相同的查询都会被缓存，这样便会造成内存资源的过度消耗。查询语句的字符大小写、空格或者注释的不同，查询缓存都会认为是不同的查询（因为他们的 Hash 值会不同）。</li>\n<li>相关系统变量设置不合理会造成大量的内存碎片，这样便会导致查询缓存频繁清理内存。</li>\n</ul>\n<h2> MySQL 查询缓存对性能的影响</h2>\n<p>在 MySQL Server 中打开查询缓存对数据库的读和写都会带来额外的消耗:</p>\n<ul>\n<li>读查询开始之前必须检查是否命中缓存。</li>\n<li>如果读查询可以缓存，那么执行完查询操作后，会查询结果和查询语句写入缓存。</li>\n<li>当向某个表写入数据的时候，必须将这个表所有的缓存设置为失效，如果缓存空间很大，则消耗也会很大，可能使系统僵死一段时间，因为这个操作是靠全局锁操作来保护的。</li>\n<li>对 InnoDB 表，当修改一个表时，设置了缓存失效，但是多版本特性会暂时将这修改对其他事务屏蔽，在这个事务提交之前，所有查询都无法使用缓存，直到这个事务被提交，所以长时间的事务，会大大降低查询缓存的命中。</li>\n</ul>\n<h2> 总结</h2>\n<p>MySQL 中的查询缓存虽然能够提升数据库的查询性能，但是查询同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</p>\n<p>查询缓存是一个适用较少情况的缓存机制。如果你的应用对数据库的更新很少，那么查询缓存将会作用显著。比较典型的如博客系统，一般博客更新相对较慢，数据表相对稳定不变，这时候查询缓存的作用会比较明显。</p>\n<p>简单总结一下查询缓存的适用场景：</p>\n<ul>\n<li>表数据修改不频繁、数据较静态。</li>\n<li>查询（Select）重复度高。</li>\n<li>查询结果集小于 1 MB。</li>\n</ul>\n<p>对于一个更新频繁的系统来说，查询缓存缓存的作用是很微小的，在某些情况下开启查询缓存会带来性能的下降。</p>\n<p>简单总结一下查询缓存不适用的场景：</p>\n<ul>\n<li>表中的数据、表结构或者索引变动频繁</li>\n<li>重复的查询很少</li>\n<li>查询的结果集很大</li>\n</ul>\n<p>《高性能 MySQL》这样写到：</p>\n<blockquote>\n<p>根据我们的经验，在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死。如果你一 定要使用查询缓存，那么不要设置太大内存，而且只有在明确收益的时候才使用（数据库内容修改次数较少）。</p>\n</blockquote>\n<p><strong>确实是这样的！实际项目中，更建议使用本地缓存（比如 Caffeine）或者分布式缓存（比如 Redis） ，性能更好，更通用一些。</strong></p>\n<h2> 参考</h2>\n<ul>\n<li>《高性能 MySQL》</li>\n<li>MySQL 缓存机制：<a href=\"https://zhuanlan.zhihu.com/p/55947158\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/55947158</a></li>\n<li>RDS MySQL 查询缓存（Query Cache）的设置和使用 - 阿里元云数据库 RDS 文档:<a href=\"https://help.aliyun.com/document_detail/41717.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://help.aliyun.com/document_detail/41717.html</a></li>\n<li>8.10.3 The MySQL Query Cache - MySQL 官方文档：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/query-cache.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png",
      "date_published": "2023-03-16T03:33:45.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "程序员的技术成长战略",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "summary": "推荐语：波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。 原文地址： https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。</p>\n<br>\n<p><strong>原文地址：</strong> <a href=\"https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA</a></p>\n</blockquote>\n<h2> 1. 前言</h2>\n<p>在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可以感受到小伙伴们焦虑的心情。</p>\n<p><strong>技术人为啥焦虑？</strong> 恕我直言，说白了是胆识不足格局太小。胆就是胆量，焦虑的人一般对未来的不确定性怀有恐惧。识就是见识，焦虑的人一般看不清楚周围世界，也看不清自己和适合自己的道路。格局也称志向，容易焦虑的人通常视野窄志向小。如果从战略和管理的视角来看，就是对自己和周围世界的认知不足，没有一个清晰和长期的学习成长战略，也没有可执行的阶段性目标计划+严格的执行。</p>\n<p>因为问此类问题的学员很多，让我感觉有点烦了，为了避免重复回答，所以我专门总结梳理了这篇长文，试图统一来回答这类问题。如果后面还有学员问类似问题，我会引导他们来读这篇文章，然后让他们用三个月、一年甚至更长的时间，去思考和回答这样一个问题：<strong>你的技术成长战略究竟是什么？</strong> 如果你想清楚了这个问题，有清晰和可落地的答案，那么恭喜你，你只需按部就班执行就好，根本无需焦虑，你实现自己的战略目标并做出成就只是一个时间问题；否则，你仍然需要通过不断磨炼+思考，务必去搞清楚这个人生的大问题！！！</p>\n<p>下面我们来看一些行业技术大牛是怎么做的。</p>\n<h2> 二. 跟技术大牛学成长战略</h2>\n<p>我们知道软件设计是有设计模式(Design Pattern)的，其实技术人的成长也是有成长模式(Growth Pattern)的。波波经常在 Linkedin 上看一些技术大牛的成长履历，探究其中的成长模式，从而启发制定自己的技术成长战略。</p>\n<p>当然，很少有技术大牛会清晰地告诉你他们的技术成长战略，以及每一年的细分落地计划。但是，这并不妨碍我们通过他们的过往履历和产出成果，去溯源他们的技术成长战略。实际上， <strong>越是牛逼的技术人，他们的技术成长战略和路径越是清晰，我们越容易从中探究出一些成功的模式。</strong></p>\n<h3> 2.1 系统性能专家案例</h3>\n<p>国内的开发者大都热衷于系统性能优化，有些人甚至三句话离不开高性能/高并发，但真正能深入这个领域，做到专家级水平的却寥寥无几。</p>\n<p>我这边要特别介绍的这个技术大牛叫 <strong>Brendan Gregg</strong> ，他是系统性能领域经典书《System Performance: Enterprise and the Cloud》(中文版<a href=\"https://www.amazon.cn/dp/B08GC261P9\" target=\"_blank\" rel=\"noopener noreferrer\">《性能之巅：洞悉系统、企业和云计算》</a>)的作者，也是著名的<a href=\"https://github.com/brendangregg/FlameGraph\" target=\"_blank\" rel=\"noopener noreferrer\">性能分析利器火焰图(Flame Graph)</a>的作者。</p>\n<p>Brendan Gregg 之前是 Netflix 公司的高级性能架构师，在 Netflix 工作近 7 年。2022 年 4 月，他离开了 Netflix 去了 Intel，担任院士职位。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/cdb11ce2f1c3a69fd19e922a7f5f59bf.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>总体上，他已经在系统性能领域深耕超过 10 年，<a href=\"https://www.linkedin.com/in/brendangregg/\" target=\"_blank\" rel=\"noopener noreferrer\">Brendan Gregg 的过往履历</a>可以在 linkedin 上看到。在这 10 年间，除了书籍以外，Brendan Gregg 还产出了超过上百份和系统性能相关的技术文档，演讲视频/ppt，还有各种工具软件，相关内容都整整齐齐地分享在<a href=\"http://www.brendangregg.com/\" target=\"_blank\" rel=\"noopener noreferrer\">他的技术博客</a>上，可以说他是一个非常高产的技术大牛。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231802218.png\" alt=\"性能工具\" tabindex=\"0\"><figcaption>性能工具</figcaption></figure>\n<p>上图来自 Brendan Gregg 的新书《BPF Performance Tools: Linux System and Application Observability》。从这个图可以看出，Brendan Gregg 对系统性能领域的掌握程度，已经深挖到了硬件、操作系统和应用的每一个角落，可以说是 360 度无死角，整个计算机系统对他来说几乎都是透明的。波波认为，Brendan Gregg 是名副其实的，世界级的，系统性能领域的大神级人物。</p>\n<h3> 2.2 从开源到企业案例</h3>\n<p>我要分享的第二个技术大牛是 <strong>Jay Kreps</strong>，他是知名的开源消息中间件 Kafka 的创始人/架构师，也是 Confluent 公司的联合创始人和 CEO，Confluent 公司是围绕 Kafka 开发企业级产品和服务的技术公司。</p>\n<p>从<a href=\"https://www.linkedin.com/in/jaykreps/\" target=\"_blank\" rel=\"noopener noreferrer\">Jay Kreps 的 Linkedin 的履历</a>上我们可以看出，Jay Kreps 之前在 Linkedin 工作了 7 年多(2007.6 ~ 2014. 9)，从高级工程师、工程主管，一直做到首席资深工程师。Kafka 大致是在 2010 年，Jay Kreps 在 Linkedin 发起的一个项目，解决 Linkedin 内部的大数据采集、存储和消费问题。之后，他和他的团队一直专注 Kafka 的打磨，开源(2011 年初)和社区生态的建设。</p>\n<p>到 2014 年底，Kafka 在社区已经非常成功，有了一个比较大的用户群，于是 Jay Kreps 就和几个早期作者一起离开了 Linkedin，成立了<a href=\"https://tech.163.com/14/1107/18/AAFG92LD00094ODU.html\" target=\"_blank\" rel=\"noopener noreferrer\">Confluent 公司</a>，开始了 Kafka 和周边产品的企业化服务道路。今年(2020.4 月)，Confluent 公司已经获得 E 轮 2.5 亿美金融资，公司估值达到 45 亿美金。从 Kafka 诞生到现在，Jay Kreps 差不多在这个产品和公司上投入了整整 10 年。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231805796.png\" alt=\"Confluent创始人三人组\" tabindex=\"0\"><figcaption>Confluent创始人三人组</figcaption></figure>\n<p>上图是 Confluent 创始人三人组，一个非常有意思的组合，一个中国人(左)，一个印度人(右)，中间的 Jay Kreps 是美国人。</p>\n<p>我之所以对 Kafka 和 Jay Kreps 的印象特别深刻，是因为在 2012 年下半年，我在携程框架部也是专门搞大数据采集的，我还开发过一套功能类似 Kafka 的 Log Collector + Agent 产品。我记得同时期有不止 4 个同类型的开源产品：Facebook Scribe、Apache Chukwa、Apache Flume 和 Apache Kafka。现在回头看，只有 Kafka 走到现在发展得最好，这个和创始人的专注和持续投入是分不开的，当然背后和几个创始人的技术大格局也是分不开的。</p>\n<p>当年我对战略性思维几乎没有概念，还处在<strong>什么技术都想学、认为各种项目做得越多越牛的阶段</strong>。搞了半年的数据采集以后，我就掉头搞其它“更有趣的”项目去了(从这个事情的侧面，也可以看出我当年的技术格局是很小的)。中间我陆续关注过 Jay 的一些创业动向，但是没想到他能把 Confluent 公司发展到目前这个规模。现在回想，其实在十年前，Jay Kreps 对自己的技术成长就有比较明确的战略性思考，也具有大的技术格局和成事的一些必要特质。Jay Kreps 和 Kafka 给我上了一堂生动的技术战略和实践课。</p>\n<h3> 2.3 技术媒体大 V 案例</h3>\n<p>介绍到这里，有些同学可能会反驳说：波波你讲的这些大牛都是学历背景好，功底扎实起点高，所以他们才更能成功。其实不然，这里我再要介绍一位技术媒体界的大 V 叫 Brad Traversy，大家可以看<a href=\"https://www.linkedin.com/in/bradtraversy/\" target=\"_blank\" rel=\"noopener noreferrer\">他的 Linkedin 简历</a>，背景很一般，学历差不多是一个非正规的社区大学(相当于大专)，没有正规大厂工作经历，有限几份工作一直是在做网站外包。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/30d6d67dc6dd5f9251f2f01af4de53fc.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是！！！Brad Traversy 目前是技术媒体领域的一个大 V，当前<a href=\"https://www.youtube.com/c/TraversyMedia\" target=\"_blank\" rel=\"noopener noreferrer\">他在 Youtube 上的频道</a>有 138 万多的订阅量，10 年累计输出 Web 开发和编程相关教学视频超过 800 个。Brad Traversy 也是 <a href=\"https://www.udemy.com/user/brad-traversy/\" target=\"_blank\" rel=\"noopener noreferrer\">Udemy</a> 上的一个成功讲师，目前已经在 Udemy 上累计输出课程 19 门，购课学生数量近 42 万。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/160b0bc4f689413757b9b5e2448f940b.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Brad Traversy 目前是自由职业者，他的 Youtube 广告+Udemy 课程的收入相当不错。</p>\n<p>就是这样一位技术媒体大 V，你很难想象，在年轻的时候，贴在他身上的标签是：不良少年，酗酒，抽烟，吸毒，纹身，进监狱。。。直</p>\n<p>到结婚后的第一个孩子诞生，他才开始担起责任做出改变，然后凭借对技术的一腔热情，开始在 Youtube 平台上持续输出免费课程。从此他找到了适合自己的战略目标，然后人生开始发生各种积极的变化。。。如果大家对 Brad Traversy 的过往经历感兴趣，推荐观看他在 Youtube 上的自述视频<a href=\"https://www.youtube.com/watch?v=zA9krklwADI\" target=\"_blank\" rel=\"noopener noreferrer\">《My Struggles &amp; Success》</a>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231830686.png\" alt=\"My Struggles &amp; Success\" tabindex=\"0\"><figcaption>My Struggles &amp; Success</figcaption></figure>\n<p>我粗略浏览了<a href=\"https://www.youtube.com/c/TraversyMedia/videos\" target=\"_blank\" rel=\"noopener noreferrer\">Brad Traversy 在 Youtube 上的所有视频</a>，10 年总计输出 800+视频，平均每年 80+。第一个视频提交于 2010 年 8 月，刚开始几年几乎没有订阅量，2017 年 1 月订阅量才到 50k，这中间差不多隔了 6 年。2017.10 月订阅量猛增到 200k，2018 年 3 月订阅量到 300k。当前 2021.1 月，订阅量达到 138 万。可以认为从 2017 开始，也就是在积累了 6 ～ 7 年后，他的订阅量开始出现拐点。<strong>如果把这些数据画出来，将会是一条非常漂亮的复利曲线</strong>。</p>\n<h3> 2.4 案例小结</h3>\n<p>Brendan Gregg，Jay Kreps 和 Brad Traversy 三个人走的技术路线各不相同，但是他们的成功具有共性或者说模式：</p>\n<p><strong>1、找到了适合自己的长期战略目标。</strong></p>\n<ul>\n<li>Brendan Gregg: 成为系统性能领域顶级专家</li>\n<li>Jay Kreps：开创基于 Kafka 开源消息队列的企业服务公司，并将公司做到上市</li>\n<li>Brad Traversy: 成为技术媒体领域大 V 和课程讲师，并以此作为自己的职业</li>\n</ul>\n<p><strong>2、专注深耕一个(或有限几个相关的)细分领域(Niche)，保持定力，不随便切换领域。</strong></p>\n<ul>\n<li>Brendan Gregg：系统性能领域</li>\n<li>Jay Kreps: 消息中间件/实时计算领域+创业</li>\n<li>Brad Traversy: 技术媒体/教学领域，方向 Web 开发 + 编程语言</li>\n</ul>\n<p><strong>3、长期投入，三人都持续投入了 10 年。</strong></p>\n<p><strong>4、年度细分计划+持续可量化的价值产出(Persistent &amp; Measurable Value Output)。</strong></p>\n<ul>\n<li>Brendan Gregg：除公司日常工作产出以外，每年有超过 10 份以上的技术文档和演讲视频产出，平均每年有 2.5 个开源工具产出。十年共产出书籍 2 本，其中《System Performance》已经更新到第二版。</li>\n<li>Jay Kreps：总体有开源产品+公司产出，1 本书产出，每年有 Kafka 和周边产品发版若干。</li>\n<li>Brad Traversy: 每年有 Youtube 免费视频产出（平均每年 80+）+Udemy 收费视频课产出(平均每年 1.5 门)。</li>\n</ul>\n<p><strong>5、以终为始是牛人和普通人的一大区别。</strong></p>\n<p>普通人通常走一步算一步，很少长远规划。牛人通 常是先有远大目标，然后采用倒推法，将大目标细化到每年/月/周的详细落地计划。Brendan Gregg，Jay Kreps 和 Brad Traversy 三人都是以终为始的典型。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231833871.png\" alt=\"以终为始\" tabindex=\"0\"><figcaption>以终为始</figcaption></figure>\n<p>上面总结了几位技术大牛的成长模式，其中一个重点就是：这些大牛的成长都是通过 <strong>持续有价值产出(Persistent Valuable Output)</strong> 来驱动的。持续产出为啥如此重要，这个还要从下面的学习金字塔说起。</p>\n<h2> 三、学习金字塔和刻意训练</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231836811.png\" alt=\"学习金字塔\" tabindex=\"0\"><figcaption>学习金字塔</figcaption></figure>\n<p>学习金字塔是美国缅因州国家训练实验室的研究成果，它认为：</p>\n<blockquote>\n<ol>\n<li>我们平时上课听讲之后，学习内容平均留存率大致只有 5%左右；</li>\n<li>书本阅读的平均留存率大致只有 10%左右；</li>\n<li>学习配上视听效果的课程，平均留存率大致在 20%左右；</li>\n<li>老师实际动手做实验演示后的平均留存率大致在 30%左右；</li>\n<li>小组讨论(尤其是辩论后)的平均留存率可以达到 50%左右；</li>\n<li>在实践中实际应用所学之后，平均留存率可以达到 75%左右；</li>\n<li>在实践的基础上，再把所学梳理出来，转而再传授给他人后，平均留存率可以达到 90%左右。</li>\n</ol>\n</blockquote>\n<p>上面列出的 7 种学习方法，前四种称为 <strong>被动学习</strong> ，后三种称为 <strong>主动学习</strong>。</p>\n<p>拿学游泳做个类比，被动学习相当于你看别人游泳，而主动学习则是你自己要下水去游。我们知道游泳或者跑步之类的运动是要燃烧身体卡路里的，这样才能达到锻炼身体和长肌肉的效果(肌肉是卡路里燃烧的结果)。如果你只是看别人游泳，自己不实际去游，是不会长肌肉的。同样的，主动学习也是要燃烧脑部卡路里的，这样才能达到训练大脑和长脑部“肌肉”的效果。</p>\n<p>我们也知道，燃烧身体的卡路里，通常会让人感觉不舒适，如果燃烧身体卡路里会让人感觉舒适的话，估计这个世界上应该不会有胖子这类人。同样，燃烧脑部卡路里也会让人感觉不适、紧张、出汗或语无伦次，如果燃烧脑部卡路里会让人感觉舒适的话，估计这个世界上人人都很聪明，人人都能发挥最大潜能。当然，这些不舒适是短期的，长期会使你更健康和聪明。波波一直认为， <strong>人与人之间的先天身体其实都差不多，但是后天身体素质和能力有差异，这些差异，很大程度是由后天对身体和大脑的训练质量、频度和强度所造成的。</strong></p>\n<p>明白这个道理之后，心智成熟和自律的人就会对自己进行持续地 <strong>刻意训练</strong> 。这个刻意训练包括对身体的训练，比如波波现在每天坚持跑步 3km，走 3km，每天做 60 个仰卧起坐，5 分钟平板撑等等，每天保持让身体燃烧一定量的卡路里。刻意训练也包括对大脑的训练，比如波波现在每天做项目写代码 coding(训练脑+手)，平均每天在 B 站上输出十分钟免费视频(训练脑+口头表达)，另外有定期总结输出公众号文章(训练脑+文字表达)，还有每天打半小时左右的平衡球(下图)或古墓丽影游戏(训练小脑+手)，每天保持让大脑燃烧一定量的卡路里，并保持一定强度(适度不适感)。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231839985.png\" alt=\"平衡球游戏\" tabindex=\"0\"><figcaption>平衡球游戏</figcaption></figure>\n<p>关于刻意训练的专业原理和方法论，推荐看书籍《刻意练习》。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231842735.png\" alt=\"刻意练习\" tabindex=\"0\"><figcaption>刻意练习</figcaption></figure>\n<p>注意，如果你平时从来不做举重锻炼的，那么某天突然做举重会很不适应甚至受伤。脑部训练也是一样的，如果你从来没有做过视频输出，那么刚开始做会很不适应，做出来的视频质量会很差。不过没有关系，任何训练都是一个循序渐进，不断强化的过程。等大脑相关区域的\"肌肉\"长出来以后，会逐步进入正循环，后面会越来越顺畅，相关\"肌肉\"会越来越发达。所以，和健身一样，健脑也不能遇到困难就放弃，需要循序渐进(Incremental)+持续地(Persistent)刻意训练。</p>\n<p>理解了学习金字塔和刻意训练以后，现在再来看 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛的做法，他们的学习成长都是建立在持续有价值产出的基础上的，这些产出都是刻意训练+燃烧脑部卡路里的成果。他们的产出要么是建立在实践基础上的产出，例如 Jay Kreps 的 Kafka 开源项目和 Confluent 公司；要么是在实践的基础上，再整理传授给其他人的产出，例如，Brendan Greeg 的技术演讲 ppt/视频，书籍，还有 Brad Traversy 的教学视频等等。换句话说，他们一直在学习金字塔的 5 ～ 7 层主动和高效地学习。并且，他们的学习产出还可以获得用户使用，有客户价值(Customer Value)，有用户就有反馈和度量。记住，有反馈和度量的学习，也称闭环学习，它是能够不断改进提升的；反之，没有反馈和度量的学习，无法改进提升。</p>\n<p>现在，你也应该明白，晒个书单秀个技能图谱很简单，读个书上个课也不难。但是要你给出 5 ～ 10 年的总体技术成长战略，再基于这个战略给出每年的细分落地计划(尤其是产出计划)，然后再严格按计划执行，这的确是很难的事情。这需要大量的实践训练+深度思考，要燃烧大量的脑部卡路里！但这是上天设置的进化法则，成长为真正的技术大牛如同成长为一流的运动员，是需要通过燃烧与之相匹配量的卡路里来交换的。成长为真正的技术大牛，也是需要通过产出与之匹配的社会价值来交换的，只有这样社会才能正常进化。你推进了社会进化，社会才会回馈你。如果不是这样，社会就无法正常进化。</p>\n<h2> 四、战略思维的诞生</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/dc87167f53b243d49f9f4e8c7fe530a1~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"思考周期和机会点\" tabindex=\"0\"><figcaption>思考周期和机会点</figcaption></figure>\n<p>一般毕业生刚进入企业工作的时候，思考大都是以天/星期/月为单位的，基本上都是今天学个什么技术，明天学个什么语言，很少会去思考一年甚至更长的目标。这是个眼前漆黑看不到的懵懂时期，捕捉到机会点的能力和概率都非常小。</p>\n<p>工作了三年以后，悟性好的人通常会以一年为思考周期，制定和实施一些年度计划。这个时期是相信天赋和比拼能力的阶段，可以捕捉到一些小机会。</p>\n<p>工作了五年以后，一些悟性好的人会产生出一定的胆识和眼光，他们会以 3 ～ 5 年为周期来制定和实施计划，开始主动布局去捕捉一些中型机会点。</p>\n<p>工作了十年以后，悟性高的人会看到模式和规则变化，例如看出行业发展模式，还有人才的成长模式等，于是开始诞生出战略性思维。然后他们会以 5 ～ 10 年为周期来制定和实施自己的战略计划，开始主动布局去捕捉一些中大机会点。Brendan Gregg，Jay Kreps 和 Brad Traversy 都是属于这个阶段的人。</p>\n<p>当然还有很少一些更牛的时代精英，他们能够看透时代和人性，他们的思考是以一生甚至更长时间为单位的，这些超人不在本文讨论范围内。</p>\n<h2> 五、建议</h2>\n<p><strong>1、以 5 ～ 10 年为周期去布局谋划你的战略。</strong></p>\n<p>现在大学生毕业的年龄一般在 22 ～ 23 岁，那么在工作了十年后，也就是在你 32 ～ 33 岁的时候，你也差不多看了十年了，应该对自己和周围的世界(你的行业和领域)有一个比较深刻的领悟了。<strong>如果你到这个年纪还懵懵懂懂，今天抓东明天抓西，那么只能说你的胆识格局是相当的低</strong>。在当前 IT 行业竞争这么激烈的情况下，到 35 岁被下岗可能就在眼前了。</p>\n<p>有了战略性思考，你应该以 5 ～ 10 年为周期去布局谋划你的战略。以 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛为例，<strong>人生若真的要干点成就出来，投入周期一般都要十年的</strong>。从 33 岁开始，你大致有 3 个十年，因为到 60 岁以后，一般人都老眼昏花干不了大事了。如果你悟性差一点，到 40 岁才开始规划，那么你大致还有 2 个十年。如果你规划好了，这 2 ～ 3 个十年可以成就不小的事业。否则，你很可能一生都成就不了什么事业，或者一直在帮助别人成就别人的事业。</p>\n<p><strong>2、专注自己的精力。</strong></p>\n<p>考虑到人生能干事业的时间也就是 2 ～ 3 个十年，你会发现人生其实很短暂，这时候你会把精力都投入到实现你的十年战略上去，没有时间再浪费在比如网上的闲聊和扯皮争论上去。</p>\n<p><strong>3、细分落地计划尤其是产出计划。</strong></p>\n<p>有了十年战略方向，下一步是每年的细分落地计划，尤其是产出计划。这些计划主要应该工作在学习金字塔的 5/6/7 层。<strong>产出应该是刻意训练+燃烧卡路里的结果，每天让身体和大脑都保持燃烧一定量的卡路里</strong>。</p>\n<p><strong>4、产出有价值的东西形成正反馈。</strong></p>\n<p>产出应该有客户价值，自己能学习(自己成长进化)，对别人还有用(推动社会成长进化)，这样可以得到<strong>用户回馈和度量</strong>，形成一个闭环，可以持续改进和提升你的学习。</p>\n<p><strong>5、少即是多。</strong></p>\n<p>深耕一个(或有限几个相关的)领域。所有细分计划应该紧密围绕你的战略展开。克制内心欲望，不要贪多和分心，不要被喧嚣的世界所迷惑。</p>\n<p><strong>6、战略方向+细分计划都要写下来，定期 review 优化。</strong></p>\n<p><strong>7、要有定力，持续努力。</strong></p>\n<p>曲则全、枉则直，战略实现是不可能直线的。战略方向和细分计划通常要按需调整，尤其在早期，但是最终要收敛。如果老是变不收敛，就是缺乏战略定力，是个必须思考和解决的大问题。</p>\n<p>别人的成长战略可以参考，但是不要刻意去模仿，你有你自己的颜色，<strong>你应该成为独一无二的你</strong>。</p>\n<p>战略方向和细分计划明确了，接下来就是按部就班执行，十年如一日铁打不动。</p>\n<p><strong>8、慢就是快。</strong></p>\n<p>战略目标的实现也和种树一样是生长出来的，需要时间耐心栽培，记住**慢就是快。**焦虑纠结的时候，像念经一样默念王阳明《传习录》中的教诲：</p>\n<blockquote>\n<p>立志用功，如种树然。方其根芽，犹未有干；及其有干，尚未有枝；枝而后叶，叶而后花实。初种根时，只管栽培灌溉。勿作枝想，勿作花想，勿作实想。悬想何益？但不忘栽培之功，怕没有枝叶花实？</p>\n<p>译文：</p>\n<p>实现战略目标，就像种树一样。刚开始只是一个小根芽，树干还没有长出来；树干长出来了，枝叶才能慢慢长出来；树枝长出来，然后才能开花和结果。刚开始种树的时候，只管栽培灌溉，别老是纠结枝什么时候长出来，花什么时候开，果实什么时候结出来。纠结有什么好处呢？只要你坚持投入栽培，还怕没有枝叶花实吗？</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/cdb11ce2f1c3a69fd19e922a7f5f59bf.png",
      "date_published": "2023-02-23T04:45:00.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [
        {
          "name": "波波微课"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "网络攻击常见手段总结",
      "url": "https://javaguide.cn/cs-basics/network/network-attack-means.html",
      "id": "https://javaguide.cn/cs-basics/network/network-attack-means.html",
      "summary": "本文整理完善自TCP/IP 常见攻击手段 - 暖蓝笔记 - 2021这篇文章。 这篇文章的内容主要是介绍 TCP/IP 常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。 IP 欺骗 IP 是什么? 在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「多少号多少室」，这个号就是分配给整个子网的，「室」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「室」对应的号码为主机号，这个地址的整体就是 IP 地址。",
      "content_html": "<blockquote>\n<p>本文整理完善自<a href=\"https://mp.weixin.qq.com/s/AZwWrOlLxRSSi-ywBgZ0fA\" target=\"_blank\" rel=\"noopener noreferrer\">TCP/IP 常见攻击手段 - 暖蓝笔记 - 2021</a>这篇文章。</p>\n</blockquote>\n<p>这篇文章的内容主要是介绍 TCP/IP 常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。</p>\n<h2> IP 欺骗</h2>\n<h3> IP 是什么?</h3>\n<p>在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「<strong>多少号多少室</strong>」，这个号就是分配给整个子网的，「<strong>室</strong>」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「<strong>室</strong>」对应的号码为主机号，这个地址的整体就是 <strong>IP 地址</strong>。</p>\n<h3> 通过 IP 地址我们能知道什么？</h3>\n<p>通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点</p>\n<p><strong>IP 头部格式</strong> :</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/843fd07074874ee0b695eca659411b42~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> IP 欺骗技术是什么？</h3>\n<p>骗呗，拐骗，诱骗！</p>\n<p>IP 欺骗技术就是<strong>伪造</strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够<strong>伪装</strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p>\n<p>假设现在有一个合法用户 <strong>(1.1.1.1)</strong> 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 <strong>1.1.1.1</strong>，并向服务器发送一个带有 RST 位的 TCP 数据段。服务器接收到这样的数据后，认为从 <strong>1.1.1.1</strong> 发送的连接有错误，就会清空缓冲区中建立好的连接。</p>\n<p>这时，如果合法用户 <strong>1.1.1.1</strong> 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/7547a145adf9404aa3a05f01f5ca2e32~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"IP 欺骗 DDoS 攻击\" tabindex=\"0\"><figcaption>IP 欺骗 DDoS 攻击</figcaption></figure>\n<h3> 如何缓解 IP 欺骗？</h3>\n<p>虽然无法预防 IP 欺骗，但可以采取措施来阻止伪造数据包渗透网络。<strong>入口过滤</strong> 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在<a href=\"https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/\" target=\"_blank\" rel=\"noopener noreferrer\">网络边缘</a>设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。</p>\n<h2> SYN Flood(洪水)</h2>\n<h3> SYN Flood 是什么？</h3>\n<p>SYN Flood 是互联网上最原始、最经典的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</p>\n<p>SYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。<br>\n增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/2b3d2d4dc8f24890b5957df1c7d6feb8~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> TCP SYN Flood 攻击原理是什么？</h3>\n<p><strong>TCP SYN Flood</strong> 攻击利用的是 <strong>TCP</strong> 的三次握手（<strong>SYN -&gt; SYN/ACK -&gt; ACK</strong>），假设连接发起方是 A，连接接受方是 B，即 B 在某个端口（<strong>Port</strong>）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/a39355a1ea404323a11ca6644e009183~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>A 首先发送 <strong>SYN</strong>（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 <strong>SYN-ACK</strong>（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：</p>\n<ul>\n<li>向 A 确认已做好接收数据的准备，</li>\n<li>同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于<strong>半开状态（Half-Open）</strong>，顾名思义只开了一半；A 收到后再次发送 <strong>ACK</strong> (Acknowledgement) 消息给 B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「<strong>连接</strong>」就建立了，</li>\n</ul>\n<p>大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了<strong>可以接收消息</strong>的状态。而这个状态的确认主要是双方将要使用的<strong>消息序号(<strong>SequenceNum)，<strong>TCP</strong> 为保证消息按发送顺序抵达接收方的上层应用，需要用</strong>消息序号</strong>来标记消息的发送先后顺序的。</p>\n<p><strong>TCP</strong>是「<strong>双工</strong>」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 <strong>SYN</strong> 和 <strong>SYN-ACK</strong> 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；<strong>SYN-ACK</strong> 和 <strong>ACK</strong> 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。</p>\n<p>上面讨论的是双方在诚实守信，正常情况下的通信。</p>\n<p>但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。</p>\n<p>假设 B 通过某 <strong>TCP</strong> 端口提供服务，B 在收到 A 的 <strong>SYN</strong> 消息时，积极的反馈了 <strong>SYN-ACK</strong> 消息，使连接进入<strong>半开状态</strong>，因为 B 不确定自己发给 A 的 <strong>SYN-ACK</strong> 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个<strong>Timer</strong>，如果超过时间还没有收到 A 的 <strong>ACK</strong> 消息，则重新发送一次 <strong>SYN-ACK</strong> 消息给 A，直到重试超过一定次数时才会放弃。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/7ff1daddcec44d61994f254e664987b4~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"图片\" tabindex=\"0\"><figcaption>图片</figcaption></figure>\n<p>B 为帮助 A 能顺利连接，需要<strong>分配内核资源</strong>维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，<strong>SYN Flood</strong> 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 <strong>Source IP</strong>，使 B 反馈的 <strong>SYN-ACK</strong> 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>\n<h3> SYN Flood 的常见形式有哪些？</h3>\n<p><strong>恶意用户可通过三种不同方式发起 SYN Flood 攻击</strong>：</p>\n<ol>\n<li><strong>直接攻击：</strong> 不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 <a href=\"https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">Mirai 僵尸网络</a>），通常也不会刻意屏蔽受感染设备的 IP。</li>\n<li><strong>欺骗攻击：</strong> 恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。</li>\n<li><strong>分布式攻击（DDoS）：</strong> 如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。</li>\n</ol>\n<h3> 如何缓解 SYN Flood？</h3>\n<h4> 扩展积压工作队列</h4>\n<p>目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。</p>\n<h4> 回收最先创建的 TCP 半开连接</h4>\n<p>另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。</p>\n<h4> SYN Cookie</h4>\n<p>此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。</p>\n<h2> UDP Flood(洪水)</h2>\n<h3> UDP Flood 是什么？</h3>\n<p><strong>UDP Flood</strong> 也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 <strong>UDP</strong> 泛滥而耗尽，从而导致对合法流量的拒绝服务。</p>\n<h3> UDP Flood 攻击原理是什么？</h3>\n<p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>\n<ul>\n<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>\n<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达。</li>\n</ul>\n<p>举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。</p>\n<p>首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快就变得不堪重负了。</p>\n<p>当服务器接收到每个新的 <strong>UDP</strong> 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 <strong>UDP</strong> 报文时，每个报文将包含源设备的 <strong>IP</strong> 地址。在这种类型的 <strong>DDoS</strong> 攻击期间，攻击者通常不会使用自己的真实 <strong>IP</strong> 地址，而是会欺骗 <strong>UDP</strong> 数据包的源 <strong>IP</strong> 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。</p>\n<p>由于目标服务器利用资源检查并响应每个接收到的 <strong>UDP</strong> 数据包的结果，当接收到大量 <strong>UDP</strong> 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/23dbbc8243a84ed181e088e38bffb37a~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 如何缓解 UDP Flooding？</h3>\n<p>大多数操作系统部分限制了 <strong>ICMP</strong> 报文的响应速率，以中断需要 ICMP 响应的 <strong>DDoS</strong> 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 <strong>UDP Flood</strong> 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。</p>\n<h2> HTTP Flood(洪水)</h2>\n<h3> HTTP Flood 是什么？</h3>\n<p>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/aa64869551d94c8d89fa80eaf4395bfa~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"HTTP 洪水攻击\" tabindex=\"0\"><figcaption>HTTP 洪水攻击</figcaption></figure>\n<h3> HTTP Flood 的攻击原理是什么？</h3>\n<p>HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。</p>\n<p>为了获得最大效率，恶意行为者通常会利用或创建僵尸网络，以最大程度地扩大攻击的影响。通过利用感染了恶意软件的多台设备，攻击者可以发起大量攻击流量来进行攻击。</p>\n<p>HTTP 洪水攻击有两种：</p>\n<ul>\n<li><strong>HTTP GET 攻击</strong>：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。</li>\n<li><strong>HTTP POST 攻击</strong>：一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。</li>\n</ul>\n<h3> 如何防护 HTTP Flood？</h3>\n<p>如前所述，缓解第 7 层攻击非常复杂，而且通常要从多方面进行。一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。</p>\n<p>其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。</p>\n<h2> DNS Flood(洪水)</h2>\n<h3> DNS Flood 是什么？</h3>\n<p>域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood 攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。</p>\n<h3> DNS Flood 的攻击原理是什么？</h3>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/97ea11a212924900b10d159226783887~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>域名系统的功能是将易于记忆的名称（例如 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener noreferrer\">example.com</a>）转换成难以记住的网站服务器地址（例如 192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood 攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽<a href=\"https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/\" target=\"_blank\" rel=\"noopener noreferrer\">物联网（IoT）</a><a href=\"https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">僵尸网络</a>（如 <a href=\"https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">Mirai</a>）兴起后激增的。DNS Flood 攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。</p>\n<p>DNS Flood 攻击不同于 <a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/dns-amplification-ddos-attack/\" target=\"_blank\" rel=\"noopener noreferrer\">DNS 放大攻击</a>。与 DNS Flood 攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。</p>\n<h3> 如何防护 DNS Flood?</h3>\n<p>DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。</p>\n<h2> TCP 重置攻击</h2>\n<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>\n<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>\n<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证。</p>\n<h2> 模拟攻击</h2>\n<blockquote>\n<p>以下实验是在 <code>OSX</code> 系统中完成的，其他系统请自行测试。</p>\n</blockquote>\n<p>现在来总结一下伪造一个 <strong>TCP</strong> 重置报文要做哪些事情：</p>\n<ul>\n<li>嗅探通信双方的交换信息。</li>\n<li>截获一个 <code>ACK</code> 标志位置位 1 的报文段，并读取其 <code>ACK</code> 号。</li>\n<li>伪造一个 TCP 重置报文段（<code>RST</code> 标志位置为 1），其序列号等于上面截获的报文的 <code>ACK</code> 号。这只是理想情况下的方案，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文。</li>\n<li>将伪造的重置报文发送给通信的一方或双方，时其中断连接。</li>\n</ul>\n<p>为了实验简单，我们可以使用本地计算机通过 <code>localhost</code> 与自己通信，然后对自己进行 TCP 重置攻击。需要以下几个步骤：</p>\n<ul>\n<li>在两个终端之间建立一个 TCP 连接。</li>\n<li>编写一个能嗅探通信双方数据的攻击程序。</li>\n<li>修改攻击程序，伪造并发送重置报文。</li>\n</ul>\n<p>下面正式开始实验。</p>\n<blockquote>\n<p>建立 TCP 连接</p>\n</blockquote>\n<p>可以使用 netcat 工具来建立 TCP 连接，这个工具很多操作系统都预装了。打开第一个终端窗口，运行以下命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个命令会启动一个 TCP 服务，监听端口为 <code>8000</code>。接着再打开第二个终端窗口，运行以下命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>该命令会尝试与上面的服务建立连接，在其中一个窗口输入一些字符，就会通过 TCP 连接发送给另一个窗口并打印出来。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/df0508cbf26446708cf98f8ad514dbea~tplv-k3u1fbpfcp-zoom-1.gif\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>嗅探流量</p>\n</blockquote>\n<p>编写一个攻击程序，使用 Python 网络库 <code>scapy</code> 来读取两个终端窗口之间交换的数据，并将其打印到终端上。代码比较长，下面为一部份，完整代码后台回复 TCP 攻击，代码的核心是调用 <code>scapy</code> 的嗅探方法：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/27feb834aa9d4b629fd938611ac9972e~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这段代码告诉 <code>scapy</code> 在 <code>lo0</code> 网络接口上嗅探数据包，并记录所有 TCP 连接的详细信息。</p>\n<ul>\n<li><strong>iface</strong> : 告诉 scapy 在 <code>lo0</code>（localhost）网络接口上进行监听。</li>\n<li><strong>lfilter</strong> : 这是个过滤器，告诉 scapy 忽略所有不属于指定的 TCP 连接（通信双方皆为 <code>localhost</code>，且端口号为 <code>8000</code>）的数据包。</li>\n<li><strong>prn</strong> : scapy 通过这个函数来操作所有符合 <code>lfilter</code> 规则的数据包。上面的例子只是将数据包打印到终端，下文将会修改函数来伪造重置报文。</li>\n<li><strong>count</strong> : scapy 函数返回之前需要嗅探的数据包数量。</li>\n</ul>\n<blockquote>\n<p>发送伪造的重置报文</p>\n</blockquote>\n<p>下面开始修改程序，发送伪造的 TCP 重置报文来进行 TCP 重置攻击。根据上面的解读，只需要修改 prn 函数就行了，让其检查数据包，提取必要参数，并利用这些参数来伪造 TCP 重置报文并发送。</p>\n<p>例如，假设该程序截获了一个从（<code>src_ip</code>, <code>src_port</code>）发往 （<code>dst_ip</code>, <code>dst_port</code>）的报文段，该报文段的 ACK 标志位已置为 1，ACK 号为 <code>100,000</code>。攻击程序接下来要做的是：</p>\n<ul>\n<li>由于伪造的数据包是对截获的数据包的响应，所以伪造数据包的源 <code>IP/Port</code> 应该是截获数据包的目的 <code>IP/Port</code>，反之亦然。</li>\n<li>将伪造数据包的 <code>RST</code> 标志位置为 1，以表示这是一个重置报文。</li>\n<li>将伪造数据包的序列号设置为截获数据包的 ACK 号，因为这是发送方期望收到的下一个序列号。</li>\n<li>调用 <code>scapy</code> 的 <code>send</code> 方法，将伪造的数据包发送给截获数据包的发送方。</li>\n</ul>\n<p>对于我的程序而言，只需将这一行取消注释，并注释这一行的上面一行，就可以全面攻击了。按照步骤 1 的方法设置 TCP 连接，打开第三个窗口运行攻击程序，然后在 TCP 连接的其中一个终端输入一些字符串，你会发现 TCP 连接被中断了！</p>\n<blockquote>\n<p>进一步实验</p>\n</blockquote>\n<ol>\n<li>可以继续使用攻击程序进行实验，将伪造数据包的序列号加减 1 看看会发生什么，是不是确实需要和截获数据包的 <code>ACK</code> 号完全相同。</li>\n<li>打开 <code>Wireshark</code>，监听 lo0 网络接口，并使用过滤器 <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code> 来过滤无关数据。你可以看到 TCP 连接的所有细节。</li>\n<li>在连接上更快速地发送数据流，使攻击更难执行。</li>\n</ol>\n<h2> 中间人攻击</h2>\n<p>猪八戒要向小蓝表白，于是写了一封信给小蓝，结果第三者小黑拦截到了这封信，把这封信进行了篡改，于是乎在他们之间进行搞破坏行动。这个马文才就是中间人，实施的就是中间人攻击。好我们继续聊聊什么是中间人攻击。</p>\n<h3> 什么是中间人?</h3>\n<p>攻击中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/d69b74e63981472b852797f2fa08976f~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"图片\" tabindex=\"0\"><figcaption>图片</figcaption></figure>\n<p>从这张图可以看到，中间人其实就是攻击者。通过这种原理，有很多实现的用途，比如说，你在手机上浏览不健康网站的时候，手机就会提示你，此网站可能含有病毒，是否继续访问还是做其他的操作等等。</p>\n<h3> 中间人攻击的原理是什么？</h3>\n<p>举个例子，我和公司签了一个一份劳动合同，一人一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。</p>\n<p>在安全领域有句话：<strong>我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本</strong>。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。</p>\n<p>为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。</p>\n<p><strong>如果第三方机构内部不严格或容易出现纰漏？</strong></p>\n<p>虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢</p>\n<p>一种可行的办法是引入 <strong>摘要算法</strong> 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。</p>\n<h4> 有哪些常用的摘要算法呢？</h4>\n<p>目前比较常用的加密算法有消息摘要算法和安全散列算法(<strong>SHA</strong>)。<strong>MD5</strong> 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，<strong>MD5</strong> 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。</p>\n<p>所以在大部分的情况下都会选择 <strong>SHA 算法</strong> 。</p>\n<p><strong>出现内鬼了怎么办？</strong></p>\n<p>看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢</p>\n<p><strong>那如何确保员工不会修改合同呢？</strong></p>\n<p>这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大</p>\n<p><strong>那么员工万一和某个用户串通好了呢？</strong></p>\n<p>看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 <strong>数字签名和证书</strong>。</p>\n<h4> 数字证书和签名有什么用？</h4>\n<p>同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 <strong>SHA</strong> 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/e4b7d6fca78b45c8840c12411b717f2f~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改</p>\n<p>在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码</p>\n<p>总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是 <strong>非对称加密</strong> 。</p>\n<p>隐私保护？不是吓唬大家，信息是透明的兄 die，不过尽量去维护个人的隐私吧，今天学习对称加密和非对称加密。</p>\n<p>大家先读读这个字\"钥\",是读\"yao\"，我以前也是，其实读\"yue\"</p>\n<h4> 什么是对称加密？</h4>\n<p>对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/ef81cb5e2f0a4d3d9ac5a44ecf97e3cc~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"图片\" tabindex=\"0\"><figcaption>图片</figcaption></figure>\n<h4> 常见的对称加密算法有哪些？</h4>\n<p><strong>DES</strong></p>\n<p>DES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，<strong>DES</strong> 的有效密钥长度为 56 位，通常称 <strong>DES</strong> 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破 Jie 的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多 1 年的样子。当然，没人这么干。<strong>DES</strong> 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/9eb3a2bf6cf14132a890bc3447480eeb~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>IDEA</strong></p>\n<p>国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。</p>\n<p><strong>AES</strong></p>\n<p>当 DES 被破解以后，没过多久推出了 <strong>AES</strong> 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。</p>\n<p><strong>SM1 和 SM4</strong></p>\n<p>之前几种都是国外的，我们国内自行研究了国密 **SM1 **和 <strong>SM4</strong>。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可</p>\n<p><strong>总结</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/578961e3175540e081e1432c409b075a~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h4> 常见的非对称加密算法有哪些？</h4>\n<p>在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是 123balala,ok,对于其他人而言，很容易就能劫持到密码是 123balala。那么在非对称的情况下，小蓝告诉所有人密码是 123balala,对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/153cf04a0ecc43c38003f3a1ab198cc0~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>其实我们经常都在使用非对称加密，比如使用多台服务器搭建大数据平台 hadoop，为了方便多台机器设置免密登录，是不是就会涉及到秘钥分发。再比如搭建 docker 集群也会使用相关非对称加密算法。</p>\n<p>常见的非对称加密算法：</p>\n<ul>\n<li>\n<p>RSA（RSA 加密算法，RSA Algorithm）：优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。</p>\n</li>\n<li>\n<p>ECC：基于椭圆曲线提出。是目前加密强度最高的非对称加密算法</p>\n</li>\n<li>\n<p>SM2：同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持。</p>\n</li>\n</ul>\n<p>总结：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/28b96fb797904d4b818ee237cdc7614c~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h4> 常见的散列算法有哪些？</h4>\n<p>这个大家应该更加熟悉了，比如我们平常使用的 MD5 校验，在很多时候，我并不是拿来进行加密，而是用来获得唯一性 ID。在做系统的过程中，存储用户的各种密码信息，通常都会通过散列算法，最终存储其散列值。</p>\n<p><strong>MD5</strong></p>\n<p>MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法，具体的应用场景你可以自行  参阅。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 <strong>MD5</strong> 的。</p>\n<p><strong>SHA</strong></p>\n<p>安全散列算法。<strong>SHA</strong> 分为 <strong>SHA1</strong> 和 <strong>SH2</strong> 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。</p>\n<p><strong>SM3</strong></p>\n<p>国密算法<strong>SM3</strong>。加密强度和 SHA-256 想不多。主要是收到国家的支持。</p>\n<p><strong>总结</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/79c3c2f72d2f44c7abf2d73a49024495~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"图片\" tabindex=\"0\"><figcaption>图片</figcaption></figure>\n<p><strong>大部分情况下使用对称加密，具有比较不错的安全性。如果需要分布式进行秘钥分发，考虑非对称。如果不需要可逆计算则散列算法。</strong> 因为这段时间有这方面需求，就看了一些这方面的资料，入坑信息安全，就怕以后洗发水都不用买。谢谢大家查看！</p>\n<h4> 第三方机构和证书机制有什么用？</h4>\n<p>问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了</p>\n<p>所以需要 Sum 过的话做过的事儿需要足够的信誉，这就引入了 <strong>第三方机构和证书机制</strong> 。</p>\n<p>证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是提供由第三方机构，含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ik，信任关系成立</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/b1a3dbf87e3e41ff894f39512a10f66d~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。</p>\n<p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了</p>\n<p>为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/1481f0409da94ba6bb0fee69bf0996f8~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Sum 证书。</p>\n<p>如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。</p>\n<p>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</p>\n<p>如果要验证二级结构证书的合法性，就需要用根证书去解密。</p>\n<p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p>\n<h3> 中间人攻击如何避免?</h3>\n<p>既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/0dde4b76be6240699312d822a3fe1ed3~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：</p>\n<p>想要避免中间人攻击的方法目前主要有两个：</p>\n<ul>\n<li>客户端不要轻易相信证书：因为这些证书极有可能是中间人。</li>\n<li>App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了。</li>\n</ul>\n<h2> DDOS</h2>\n<p>通过上面的描述，总之即好多种攻击都是 <strong>DDOS</strong> 攻击，所以简单总结下这个攻击相关内容。</p>\n<p>其实，像全球互联网各大公司，均遭受过大量的 <strong>DDoS</strong>。</p>\n<p>2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps。</p>\n<h3> DDoS 攻击究竟是什么？</h3>\n<p>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p>\n<blockquote>\n<p>举个例子</p>\n</blockquote>\n<p>我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。</p>\n<p>上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。</p>\n<p>攻击方式很多，比如 <strong>ICMP Flood</strong>、<strong>UDP Flood</strong>、<strong>NTP Flood</strong>、<strong>SYN Flood</strong>、<strong>CC 攻击</strong>、<strong>DNS Query Flood</strong>等等。</p>\n<h3> 如何应对 DDoS 攻击？</h3>\n<h4> 高防服务器</h4>\n<p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p>\n<p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p>\n<h4> 黑名单</h4>\n<p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p>\n<h4> DDoS 清洗</h4>\n<p><strong>DDos</strong> 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p>\n<p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p>\n<h4> CDN 加速</h4>\n<p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p>\n<p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</p>\n<h2> 参考</h2>\n<ul>\n<li>HTTP 洪水攻击 - CloudFlare：<a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/http-flood-ddos-attack/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/ddos/http-flood-ddos-attack/</a></li>\n<li>SYN 洪水攻击：<a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/</a></li>\n<li>什么是 IP 欺骗？：<a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/glossary/ip-spoofing/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/ddos/glossary/ip-spoofing/</a></li>\n<li>什么是 DNS 洪水？| DNS 洪水 DDoS 攻击：<a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/dns-flood-ddos-attack/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cloudflare.com/zh-cn/learning/ddos/dns-flood-ddos-attack/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/p3-juejin/843fd07074874ee0b695eca659411b42~tplv-k3u1fbpfcp-zoom-1.png",
      "date_published": "2023-02-19T09:28:45.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "SQL常见面试题总结（1）",
      "url": "https://javaguide.cn/database/sql/sql-questions-01.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-01.html",
      "summary": "题目来源于：牛客题霸 - SQL 必知必会 检索数据 SELECT 用于从数据库中查询数据。 从 Customers 表中检索所有的 ID 现有表 Customers 如下：",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=298\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 必知必会</a></p>\n</blockquote>\n<h2> 检索数据</h2>\n<p><code>SELECT</code> 用于从数据库中查询数据。</p>\n<h3> 从 Customers 表中检索所有的 ID</h3>\n<p>现有表 <code>Customers</code> 如下：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n</tr>\n<tr>\n<td>B</td>\n</tr>\n<tr>\n<td>C</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，从 <code>Customers</code> 表中检索所有的 <code>cust_id</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索并列出已订购产品的清单</h3>\n<p>表 <code>OrderItems</code> 含有非空的列 <code>prod_id</code> 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n</tr>\n<tr>\n<td>a2</td>\n</tr>\n<tr>\n<td>a3</td>\n</tr>\n<tr>\n<td>a4</td>\n</tr>\n<tr>\n<td>a5</td>\n</tr>\n<tr>\n<td>a6</td>\n</tr>\n<tr>\n<td>a7</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，检索并列出所有已订购商品（<code>prod_id</code>）的去重后的清单。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：<code>DISTINCT</code> 用于返回列中的唯一不同值。</p>\n<h3> 检索所有列</h3>\n<p>现在有 <code>Customers</code> 表（表中含有列 <code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名）</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>an</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>lee</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>需要编写 SQL 语句，检索所有列。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 排序检索数据</h2>\n<p><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</p>\n<h3> 检索顾客名称并且排序</h3>\n<p>有表 <code>Customers</code>，<code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名。</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>an</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>lee</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>从 <code>Customers</code> 中检索所有的顾客名称（<code>cust_name</code>），并按从 Z 到 A 的顺序显示结果。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对顾客 ID 和日期排序</h3>\n<p>有 <code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>order_num</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>andy</td>\n<td>aaaa</td>\n<td>2021-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>andy</td>\n<td>bbbb</td>\n<td>2021-01-01 12:00:00</td>\n</tr>\n<tr>\n<td>bob</td>\n<td>cccc</td>\n<td>2021-01-10 12:00:00</td>\n</tr>\n<tr>\n<td>dick</td>\n<td>dddd</td>\n<td>2021-01-11 00:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期倒序排列。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：<code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>\n<h3> 按照数量和价格排序</h3>\n<p>假设有一个 <code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>100</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n</tr>\n<tr>\n<td>2</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，显示 <code>OrderItems</code> 表中的数量（<code>quantity</code>）和价格（<code>item_price</code>），并按数量由多到少、价格由高到低排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>有 <code>Vendors</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>海底捞</td>\n</tr>\n<tr>\n<td>小龙坎</td>\n</tr>\n<tr>\n<td>大龙燚</td>\n</tr>\n</tbody>\n</table>\n<p>下面的 SQL 语句有问题吗？尝试将它改正确，使之能够正确运行，并且返回结果根据<code>vend_name</code> 逆序排列。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>改正后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>逗号作用是用来隔开列与列之间的。</li>\n<li>ORDER BY 是有 BY 的，需要撰写完整，且位置正确。</li>\n</ul>\n<h2> 过滤数据</h2>\n<p><code>WHERE</code> 可以过滤返回的数据。</p>\n<p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&gt;</td>\n<td style=\"text-align:left\">不等于。 <strong>注释：</strong> 在 SQL 的一些版本中，该操作符可被写成 !=</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">大于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">小于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">大于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">小于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BETWEEN</td>\n<td style=\"text-align:left\">在某个范围内</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LIKE</td>\n<td style=\"text-align:left\">搜索某种模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IN</td>\n<td style=\"text-align:left\">指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<h3> 返回固定价格的产品</h3>\n<p>有表 <code>Products</code>：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0018</td>\n<td>sockets</td>\n<td>9.49</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n<td>600</td>\n</tr>\n<tr>\n<td>b0018</td>\n<td>gucci t-shirts</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9.49 美元的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回更高价格的产品</h3>\n<p>有表 <code>Products</code>：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0018</td>\n<td>sockets</td>\n<td>9.49</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n<td>600</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9 美元或更高的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品并且按照价格排序</h3>\n<p>有表 <code>Products</code>：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>egg</td>\n<td>3</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>sockets</td>\n<td>4</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>coffee</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后按价格对结果进行排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回更多的产品</h3>\n<p><code>OrderItems</code> 表含有：订单号 <code>order_num</code>，<code>quantity</code>产品数量</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】从 <code>OrderItems</code> 表中检索出所有不同且不重复的订单号（<code>order_num</code>），其中每个订单都要包含 100 个或更多的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 高级数据过滤</h2>\n<p><code>AND</code> 和 <code>OR</code> 运算符用于基于一个以上的条件对记录进行过滤，两者可以结合使用。<code>AND</code> 必须 2 个条件都成立，<code>OR</code>只要 2 个条件中的一个成立即可。</p>\n<h3> 检索供应商名称</h3>\n<p><code>Vendors</code> 表有字段供应商名称（<code>vend_name</code>）、供应商国家（<code>vend_country</code>）、供应商州（<code>vend_state</code>）</p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n<th>vend_country</th>\n<th>vend_state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>apple</td>\n<td>USA</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>vivo</td>\n<td>CNA</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>huawei</td>\n<td>CNA</td>\n<td>xian</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索供应商名称（<code>vend_name</code>），仅返回加利福尼亚州的供应商（这需要按国家[USA]和州[CA]进行过滤，没准其他国家也存在一个 CA）</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索并列出已订购产品的清单</h3>\n<p><code>OrderItems</code> 表包含了所有已订购的产品（有些已被订购多次）。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>BR03</td>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>BR017</td>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>BR017</td>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，查找所有订购了数量至少 100 个的 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回 <code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品 ID（<code>prod_id</code>）和数量（<code>quantity</code>），并按产品 ID 和数量进行过滤。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回所有价格在 3 美元到 6 美元之间的产品的名称和价格</h3>\n<p>有表 <code>Products</code>：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>egg</td>\n<td>3</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>sockets</td>\n<td>4</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>coffee</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），使用 AND 操作符，然后按价格对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>供应商表 <code>Vendors</code> 有字段供应商名称 <code>vend_name</code>、供应商国家 <code>vend_country</code>、供应商省份 <code>vend_state</code></p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n<th>vend_country</th>\n<th>vend_state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>apple</td>\n<td>USA</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>vivo</td>\n<td>CNA</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>huawei</td>\n<td>CNA</td>\n<td>xian</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修改正确下面 sql，使之正确返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ORDER BY</code> 语句必须放在 <code>WHERE</code> 之后。</p>\n<h2> 用通配符进行过滤</h2>\n<p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p>\n<p>在 SQL 中，可使用以下通配符：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">通配符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>%</code></td>\n<td style=\"text-align:left\">代表零个或多个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_</code></td>\n<td style=\"text-align:left\">仅替代一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[charlist]</code></td>\n<td style=\"text-align:left\">字符列中的任何单一字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^charlist]</code> 或者 <code>[!charlist]</code></td>\n<td style=\"text-align:left\">不在字符列中的任何单一字符</td>\n</tr>\n</tbody>\n</table>\n<h3> 检索产品名称和描述（一）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中包含 <code>toy</code> 一词的产品名称。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（二）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品，最后按”产品名称“对结果进行排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（三）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego carrots toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中同时出现 <code>toy</code> 和 <code>carrots</code> 的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用 <code>AND</code> 和两个 <code>LIKE</code> 比较。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（四）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy carrots</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以<strong>先后顺序</strong>同时出现 toy 和 carrots 的产品。提示：只需要用带有三个 <code>%</code> 符号的 <code>LIKE</code> 即可。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建计算字段</h2>\n<h3> 别名</h3>\n<p>别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。有表 <code>Vendors</code> 代表供应商信息，<code>vend_id</code> 供应商 id、<code>vend_name</code> 供应商名称、<code>vend_address</code> 供应商地址、<code>vend_city</code> 供应商城市。</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>vend_name</th>\n<th>vend_address</th>\n<th>vend_city</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a001</td>\n<td>tencent cloud</td>\n<td>address1</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>a002</td>\n<td>huawei cloud</td>\n<td>address2</td>\n<td>dongguan</td>\n</tr>\n<tr>\n<td>a003</td>\n<td>aliyun cloud</td>\n<td>address3</td>\n<td>hangzhou</td>\n</tr>\n<tr>\n<td>a003</td>\n<td>netease cloud</td>\n<td>address4</td>\n<td>guangzhou</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>，按供应商名称对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 打折</h3>\n<p>我们的示例商店正在进行打折促销，所有产品均降价 10%。<code>Products</code> 表包含 <code>prod_id</code> 产品 id、<code>prod_price</code> 产品价格。</p>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>。<code>sale_price</code> 是一个包含促销价格的计算字段。提示：可以乘以 0.9，得到原价的 90%（即 10%的折扣）。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：<code>sale_price</code> 是对计算结果的命名，而不是原有的列名。</p>\n<h2> 使用函数处理数据</h2>\n<h3> 顾客登录名</h3>\n<p>我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。</p>\n<p>给出 <code>Customers</code> 表 如下：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n<th>cust_contact</th>\n<th>cust_city</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>Andy Li</td>\n<td>Andy Li</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>Ben Liu</td>\n<td>Ben Liu</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>Tony Dai</td>\n<td>Tony Dai</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>Tom Chen</td>\n<td>Tom Chen</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>An Li</td>\n<td>An Li</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>Lee Chen</td>\n<td>Lee Chen</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>Hex Liu</td>\n<td>Hex Liu</td>\n<td>Oak Park</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。提示：需要使用函数、拼接和别名。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>\n<p>截取函数<code>SUBSTRING()</code>：截取字符串，<code>substring(str ,n ,m)</code>（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；</p>\n</li>\n<li>\n<p>拼接函数<code>CONCAT()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。</p>\n</li>\n<li>\n<p>大写函数 <code>UPPER()</code>：将指定字符串转换为大写。</p>\n</li>\n</ul>\n<h3> 返回 2020 年 1 月的所有订单的订单号和订单日期</h3>\n<p><code>Orders</code> 订单表如下：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>2020-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>2020-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>2020-01-01 12:00:00</td>\n</tr>\n<tr>\n<td>a0004</td>\n<td>2020-02-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0005</td>\n<td>2020-03-01 00:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 2020 年 1 月的所有订单的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期升序排序</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以用通配符来做：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>日期格式：<code>YYYY-MM-DD</code></li>\n<li>时间格式：<code>HH:MM:SS</code></li>\n</ul>\n<p>日期和时间处理相关的常用函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ADDDATE()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>ADDTIME()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CURDATE()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CURTIME()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>DATE()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DATEDIFF</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>DATE_FORMAT()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>DAY()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DAYOFWEEK()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>HOUR()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>MINUTE()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>MONTH()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>NOW()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>SECOND()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>TIME()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>YEAR()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h2> 汇总数据</h2>\n<p>汇总数据相关的函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<h3> 确定已售出产品的总数</h3>\n<p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量。</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10</td>\n</tr>\n<tr>\n<td>100</td>\n</tr>\n<tr>\n<td>1000</td>\n</tr>\n<tr>\n<td>10001</td>\n</tr>\n<tr>\n<td>2</td>\n</tr>\n<tr>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，确定已售出产品的总数。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定已售出产品项 BR01 的总数</h3>\n<p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量，产品项为 <code>prod_id</code>。</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10</td>\n<td>AR01</td>\n</tr>\n<tr>\n<td>100</td>\n<td>AR10</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>BR01</td>\n</tr>\n<tr>\n<td>10001</td>\n<td>BR010</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修改创建的语句，确定已售出产品项（<code>prod_id</code>）为\"BR01\"的总数。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定 Products 表中价格不超过 10 美元的最贵产品的价格</h3>\n<p><code>Products</code> 表如下，<code>prod_price</code> 代表商品的价格。</p>\n<table>\n<thead>\n<tr>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9.49</td>\n</tr>\n<tr>\n<td>600</td>\n</tr>\n<tr>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分组数据</h2>\n<p><code>GROUP BY</code>：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><code>HAVING</code>：</p>\n<ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 必须要与 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<p><code>HAVING</code> vs <code>WHERE</code>：</p>\n<ul>\n<li><code>WHERE</code>：过滤指定的行，后面不能加聚合函数（分组函数）。</li>\n<li><code>HAVING</code>：过滤分组，必须要与 <code>GROUP BY</code> 连用，不能单独使用。</li>\n</ul>\n<h3> 返回每个订单号各有多少行数</h3>\n<p><code>OrderItems</code> 表包含每个订单的每个产品</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a004</td>\n</tr>\n<tr>\n<td>a007</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ol>\n<li><code>count(*)</code>,<code>count(列名)</code>都可以，区别在于，<code>count(列名)</code>是统计非 NULL 的行数；</li>\n<li><code>order by</code> 最后执行，所以可以使用列别名；</li>\n<li>分组聚合一定不要忘记加上 <code>group by</code> ,不然只会有一行结果。</li>\n</ol>\n<h3> 每个供应商成本最低的产品</h3>\n<p>有 <code>Products</code> 表，含有字段 <code>prod_price</code> 代表产品价格，<code>vend_id</code> 代表供应商 id</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>0.1</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>6980</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回订单数量总和不小于 100 的所有订单的订单号</h3>\n<p><code>OrderItems</code> 代表订单商品表，包括：订单号 <code>order_num</code> 和订单数量 <code>quantity</code>。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】请编写 SQL 语句，返回订单数量总和不小于 100 的所有订单号，最后结果按照订单号升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。</li>\n<li><code>having</code>：过滤分组，与 <code>group by</code> 连用，不能单独使用。</li>\n</ul>\n<h3> 计算总和</h3>\n<p><code>OrderItems</code> 表代表订单信息，包括字段：订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，根据订单号聚合，返回订单总价不小于 1000 的所有订单号，最后的结果按订单号进行升序排序。</p>\n<p>提示：总价 = item_price 乘以 quantity</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p><code>OrderItems</code> 表含有 <code>order_num</code> 订单号</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a004</td>\n</tr>\n<tr>\n<td>a007</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将下面代码修改正确后执行</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用子查询</h2>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>\n</ul>\n<blockquote>\n<p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 <code>WHERE</code> 子句的运算符，可以是比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code> 等）或逻辑运算符（如 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code>, <code>NOT EXISTS</code> 等），具体根据需求来确定。</li>\n</ul>\n<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</li>\n<li>子查询需要放在括号 <code>( )</code> 内。</li>\n<li>可以指定多个临时表名，并使用 <code>JOIN</code> 语句连接这些表。</li>\n</ul>\n<h3> 返回购买价格为 10 美元或以上产品的顾客列表</h3>\n<p><code>OrderItems</code> 表示订单商品表，含有字段订单号：<code>order_num</code>、订单价格：<code>item_price</code>；<code>Orders</code> 表代表订单信息表，含有顾客 <code>id：cust_id</code> 和订单号：<code>order_num</code></p>\n<p><code>OrderItems</code> 表:</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust5</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust7</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定哪些订单购买了 prod_id 为 BR01 的产品（一）</h3>\n<p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 \"BR01\" 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）</h3>\n<p>你想知道订购 BR01 产品的日期，有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 <code>cust_id</code> 顾客 id</p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td><a href=\"mailto:cust10@cust.com\">cust10@cust.com</a></td>\n</tr>\n<tr>\n<td>cust1</td>\n<td><a href=\"mailto:cust1@cust.com\">cust1@cust.com</a></td>\n</tr>\n<tr>\n<td>cust2</td>\n<td><a href=\"mailto:cust2@cust.com\">cust2@cust.com</a></td>\n</tr>\n</tbody>\n</table>\n<p>【问题】返回购买 <code>prod_id</code> 为 <code>BR01</code> 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>\n<p>提示：这涉及 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回每个顾客不同订单的总金额</h3>\n<p>我们需要一个顾客 ID 列表，其中包含他们已订购的总金额。</p>\n<p><code>OrderItems</code> 表代表订单信息，<code>OrderItems</code> 表有订单号：<code>order_num</code> 和商品售出价格：<code>item_price</code>、商品数量：<code>quantity</code>。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，返回顾客 ID（<code>Orders</code> 表中的 <code>cust_id</code>），并使用子查询返回 <code>total_ordered</code> 以便返回每个顾客的订单总数，将结果按金额从大到小排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 从 Products 表中检索所有的产品名称以及对应的销售总数</h3>\n<p><code>Products</code> 表中检索所有的产品名称：<code>prod_name</code>、产品 id：<code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 代表订单商品表，订单产品：<code>prod_id</code>、售出数量：<code>quantity</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，从 <code>Products</code> 表中检索所有的产品名称（<code>prod_name</code>），以及名为 <code>quant_sold</code> 的计算列，其中包含所售产品的总数（在 <code>OrderItems</code> 表上使用子查询和 <code>SUM(quantity)</code> 检索）。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 连接表</h2>\n<p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 =。</p>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>\n<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>\n<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INNER JOIN 内连接</td>\n<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>\n</tr>\n<tr>\n<td>LEFT JOIN / LEFT OUTER JOIN 左(外)连接</td>\n<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接</td>\n<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>FULL JOIN / FULL OUTER JOIN 全(外)连接</td>\n<td>只要其中有一个表存在满足条件的记录，就返回行。</td>\n</tr>\n<tr>\n<td>SELF JOIN</td>\n<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td>CROSS JOIN</td>\n<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/d1794312b448516831369f869814ab39.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p>\n<p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回顾客名称和相关订单号</h3>\n<p><code>Customers</code> 表有字段顾客名称 <code>cust_name</code>、顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 订单信息表，含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等连接语法，另外一个使用 INNER JOIN。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回顾客名称和相关订单号以及每个订单的总价</h3>\n<p><code>Customers</code> 表有字段，顾客名称：<code>cust_name</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 订单信息表，含有字段，订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表有字段，商品订单号：<code>order_num</code>、商品数量：<code>quantity</code>、商品价格：<code>item_price</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>1000</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>10</td>\n<td>15</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>25</td>\n<td>50</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>15</td>\n<td>25</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】除了返回顾客名称和订单号，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），添加第三列 <code>OrderTotal</code>，其中包含每个订单的总价，并按顾客名称再按订单号对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，可能有小伙伴会这样写：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是错误的！只对 <code>cust_name</code> 进行聚类确实符合题意，但是不符合 <code>GROUP BY</code> 的语法。</p>\n<p>select 语句中，如果没有 <code>GROUP BY</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity * item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity * item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p>\n<blockquote>\n<p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p>\n</blockquote>\n<h3> 确定哪些订单购买了 prod_id 为 BR01 的产品（二）</h3>\n<p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 \"BR01\" 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>\n<p>提示：这一次使用连接和简单的等连接语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）</h3>\n<p>有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 cust_id 顾客 id</p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td><a href=\"mailto:cust10@cust.com\">cust10@cust.com</a></td>\n</tr>\n<tr>\n<td>cust1</td>\n<td><a href=\"mailto:cust1@cust.com\">cust1@cust.com</a></td>\n</tr>\n<tr>\n<td>cust2</td>\n<td><a href=\"mailto:cust2@cust.com\">cust2@cust.com</a></td>\n</tr>\n</tbody>\n</table>\n<p>【问题】返回购买 <code>prod_id</code> 为 BR01 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>\n<p>提示：涉及到 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>，但是必须使用 INNER JOIN 语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定最佳顾客的另一种方式（二）</h3>\n<p><code>OrderItems</code> 表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，<code>OrderItems</code> 表有订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>顾客表 <code>Customers</code> 有字段 <code>cust_id</code> 客户 id、<code>cust_name</code> 客户姓名</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回订单总价不小于 1000 的客户名称和总额（<code>OrderItems</code> 表中的 <code>order_num</code>）。</p>\n<p>提示：需要计算总和（<code>item_price</code> 乘以 <code>quantity</code>）。按总额对结果进行排序，请使用 <code>INNER JOIN</code>语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建高级连接</h2>\n<h3> 检索每个顾客的名称和所有的订单号（一）</h3>\n<p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用 INNER JOIN 编写 SQL 语句，检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（<code>Orders</code> 表中的 <code>order_num</code>），最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索每个顾客的名称和所有的订单号（二）</h3>\n<p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n<tr>\n<td>cust40</td>\n<td>ace</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（Orders 表中的 <code>order_num</code>），列出所有的顾客，即使他们没有下过订单。最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品名称和与之相关的订单号</h3>\n<p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n<tr>\n<td>a0023</td>\n<td>soda</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>a105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>a1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用外连接（left join、 right join、full join）联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和与之相关的订单号（<code>order_num</code>）的列表，并按照产品名称升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品名称和每一项产品的总订单数</h3>\n<p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n<tr>\n<td>a0023</td>\n<td>soda</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>a105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>a1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>使用 OUTER JOIN 联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和每一项产品的总订单数（不是订单号），并按产品名称升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 列出供应商及其可供产品的数量</h3>\n<p>有 <code>Vendors</code> 表含有 <code>vend_id</code> （供应商 id）</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0002</td>\n</tr>\n<tr>\n<td>a0013</td>\n</tr>\n<tr>\n<td>a0003</td>\n</tr>\n<tr>\n<td>a0010</td>\n</tr>\n</tbody>\n</table>\n<p>有 <code>Products</code> 表含有 <code>vend_id</code>（供应商 id）和 prod_id（供应产品 id）</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>prod_id_iphone</td>\n</tr>\n<tr>\n<td>a00113</td>\n<td>prod_id_tea</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>prod_id_vivo phone</td>\n</tr>\n<tr>\n<td>a0010</td>\n<td>prod_id_huawei phone</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】列出供应商（<code>Vendors</code> 表中的 <code>vend_id</code>）及其可供产品的数量，包括没有产品的供应商。你需要使用 OUTER JOIN 和 COUNT()聚合函数来计算 <code>Products</code> 表中每种产品的数量，最后根据 vend_id 升序排序。</p>\n<p>注意：<code>vend_id</code> 列会显示在多个表中，因此在每次引用它时都需要完全限定它。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 组合查询</h2>\n<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n</ul>\n<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>\n<p><code>JOIN</code> vs <code>UNION</code>：</p>\n<ul>\n<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h3> 将两个 SELECT 语句结合起来（一）</h3>\n<p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n<tr>\n<td>BNBG</td>\n<td>10002</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 将两个 SELECT 语句结合起来（二）</h3>\n<p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n<tr>\n<td>BNBG</td>\n<td>10002</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。 注意：<strong>这次仅使用单个 SELECT 语句。</strong></p>\n<p>答案：</p>\n<p>要求只用一条 select 语句，那就用 <code>or</code> 不用 <code>union</code> 了。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 组合 Products 表中的产品名称和 Customers 表中的顾客名称</h3>\n<p><code>Products</code> 表含有字段 <code>prod_name</code> 代表产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flower</td>\n</tr>\n<tr>\n<td>rice</td>\n</tr>\n<tr>\n<td>ring</td>\n</tr>\n<tr>\n<td>umbrella</td>\n</tr>\n</tbody>\n</table>\n<p>Customers 表代表顾客信息，cust_name 代表顾客名称</p>\n<table>\n<thead>\n<tr>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>andy</td>\n</tr>\n<tr>\n<td>ben</td>\n</tr>\n<tr>\n<td>tony</td>\n</tr>\n<tr>\n<td>tom</td>\n</tr>\n<tr>\n<td>an</td>\n</tr>\n<tr>\n<td>lee</td>\n</tr>\n<tr>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，组合 <code>Products</code> 表中的产品名称（<code>prod_name</code>）和 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）并返回，然后按产品名称对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>表 <code>Customers</code> 含有字段 <code>cust_name</code> 顾客名、<code>cust_contact</code> 顾客联系方式、<code>cust_state</code> 顾客州、<code>cust_email</code> 顾客 <code>email</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_name</th>\n<th>cust_contact</th>\n<th>cust_state</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>8695192</td>\n<td>MI</td>\n<td><a href=\"mailto:cust10@cust.com\">cust10@cust.com</a></td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>8695193</td>\n<td>MI</td>\n<td><a href=\"mailto:cust1@cust.com\">cust1@cust.com</a></td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>8695194</td>\n<td>IL</td>\n<td><a href=\"mailto:cust2@cust.com\">cust2@cust.com</a></td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修正下面错误的 SQL</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修正后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后</p>\n<p>或者直接用 <code>or</code> 来做：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/d1794312b448516831369f869814ab39.png",
      "date_published": "2023-02-17T05:40:22.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL语法基础知识总结",
      "url": "https://javaguide.cn/database/sql/sql-syntax-summary.html",
      "id": "https://javaguide.cn/database/sql/sql-syntax-summary.html",
      "summary": "本文整理完善自下面这两份资料： SQL 语法速成手册 MySQL 超全教程",
      "content_html": "<blockquote>\n<p>本文整理完善自下面这两份资料：</p>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903790571700231\" target=\"_blank\" rel=\"noopener noreferrer\">SQL 语法速成手册</a></li>\n<li><a href=\"https://www.begtut.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 超全教程</a></li>\n</ul>\n</blockquote>\n<h2> 基本概念</h2>\n<h3> 数据库术语</h3>\n<ul>\n<li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>\n<li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li>\n<li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li><code>行（row）</code> - 表中的一个记录。</li>\n<li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li>\n</ul>\n<h3> SQL 语法</h3>\n<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>\n<h4> SQL 语法结构</h4>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>SQL 语法结构包括：</p>\n<ul>\n<li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>\n<li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li>\n<li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>\n<li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>\n<li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>\n</ul>\n<h4> SQL 语法要点</h4>\n<ul>\n<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li>\n<li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li>\n<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>\n</ul>\n<p>SQL 语句可以写成一行，也可以分写为多行。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>SQL 支持三种注释：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> SQL 分类</h3>\n<h4> 数据定义语言（DDL）</h4>\n<p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>\n<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>\n<p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p>\n<h4> 数据操纵语言（DML）</h4>\n<p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>\n<p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p>\n<p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p>\n<h4> 事务控制语言（TCL）</h4>\n<p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>\n<p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h4> 数据控制语言（DCL）</h4>\n<p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>\n<p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p>\n<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p>\n<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>\n<h2> 增删改查</h2>\n<p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<h3> 插入数据</h3>\n<p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<p><strong>插入完整的行</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>插入行的一部分</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>插入查询出来的数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 更新数据</h3>\n<p><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除数据</h3>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<p><strong>删除表中的指定数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>清空表中的数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查询数据</h3>\n<p><code>SELECT</code> 语句用于从数据库中查询数据。</p>\n<p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p>\n<p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>\n<ul>\n<li><code>ASC</code>：升序（默认）</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<p><strong>查询单列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询多列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询所有列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询不同的值</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>限制查询结果</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 排序</h2>\n<p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p>\n<p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分组</h2>\n<p><strong><code>group by</code></strong>：</p>\n<ul>\n<li><code>group by</code> 子句将记录分组到汇总行中。</li>\n<li><code>group by</code> 为每个组返回一个记录。</li>\n<li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li>\n<li><code>group by</code> 可以按一列或多列进行分组。</li>\n<li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><strong>分组</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>分组后排序</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>having</code></strong>：</p>\n<ul>\n<li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li>\n<li><code>having</code> 一般都是和 <code>group by</code> 连用。</li>\n<li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li>\n</ul>\n<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>having</code> vs <code>where</code></strong>：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li>\n<li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li>\n</ul>\n<h2> 子查询</h2>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>\n</ul>\n<blockquote>\n<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 where 子句的运算符。</li>\n</ul>\n<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p>\n<p><strong>子查询的子查询</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/c439da1f5d4e4b00bdfa4316b933d764~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> WHERE</h3>\n<ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !=</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td>IN</td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> IN 和 BETWEEN</h3>\n<ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<p><strong>IN 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>BETWEEN 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> AND、OR、NOT</h3>\n<ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<p><strong>AND 示例</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>OR 示例</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>NOT 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> LIKE</h3>\n<ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<p><strong>% 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>_ 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 连接</h2>\n<p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 =。</p>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>\n<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>\n<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INNER JOIN 内连接</td>\n<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>\n</tr>\n<tr>\n<td>LEFT JOIN / LEFT OUTER JOIN 左(外)连接</td>\n<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接</td>\n<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>FULL JOIN / FULL OUTER JOIN 全(外)连接</td>\n<td>只要其中有一个表存在满足条件的记录，就返回行。</td>\n</tr>\n<tr>\n<td>SELF JOIN</td>\n<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td>CROSS JOIN</td>\n<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p>\n<p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 组合</h2>\n<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n</ul>\n<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>\n<p><code>JOIN</code> vs <code>UNION</code>：</p>\n<ul>\n<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h2> 函数</h2>\n<p>不同数据库的函数往往各不相同，因此不可移植。本节主要以 MySQL 的函数为例。</p>\n<h3> 文本处理</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>LEFT()</code>、<code>RIGHT()</code></td>\n<td>左边或者右边的字符</td>\n</tr>\n<tr>\n<td><code>LOWER()</code>、<code>UPPER()</code></td>\n<td>转换为小写或者大写</td>\n</tr>\n<tr>\n<td><code>LTRIM()</code>、<code>RTRIM()</code></td>\n<td>去除左边或者右边的空格</td>\n</tr>\n<tr>\n<td><code>LENGTH()</code></td>\n<td>长度，以字节为单位</td>\n</tr>\n<tr>\n<td><code>SOUNDEX()</code></td>\n<td>转换为语音值</td>\n</tr>\n</tbody>\n</table>\n<p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 日期和时间处理</h3>\n<ul>\n<li>日期格式：<code>YYYY-MM-DD</code></li>\n<li>时间格式：<code>HH:MM:SS</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddDate()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>AddTime()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CurDate()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CurTime()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>Date()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DateDiff()</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>Date_Add()</code></td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td><code>Date_Format()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>Day()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DayOfWeek()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>Hour()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>Minute()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>Month()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>Now()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>Second()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>Time()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>Year()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h3> 数值处理</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIN()</td>\n<td>正弦</td>\n</tr>\n<tr>\n<td>COS()</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>TAN()</td>\n<td>正切</td>\n</tr>\n<tr>\n<td>ABS()</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>SQRT()</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>MOD()</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>EXP()</td>\n<td>指数</td>\n</tr>\n<tr>\n<td>PI()</td>\n<td>圆周率</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>随机数</td>\n</tr>\n</tbody>\n</table>\n<h3> 汇总</h3>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<p><code>AVG()</code> 会忽略 NULL 行。</p>\n<p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p>\n<h2> 数据定义</h2>\n<h3> 数据库（DATABASE）</h3>\n<h4> 创建数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 删除数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 选择数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 数据表（TABLE）</h3>\n<h4> 创建数据表</h4>\n<p><strong>普通创建</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>根据已有的表创建新表</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除数据表</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 修改数据表</h4>\n<p><strong>添加列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>删除列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>修改列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>添加主键</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>删除主键</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 视图（VIEW）</h3>\n<p>定义：</p>\n<ul>\n<li>视图是基于 SQL 语句的结果集的可视化的表。</li>\n<li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>简化复杂的 SQL 操作，比如复杂的联结；</li>\n<li>只使用实际表的一部分数据；</li>\n<li>通过只给用户访问视图的权限，保证数据的安全性；</li>\n<li>更改数据格式和表示。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/ec4c975296ea4a7097879dac7c353878~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"mysql视图\" tabindex=\"0\"><figcaption>mysql视图</figcaption></figure>\n<h4> 创建视图</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除视图</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 索引（INDEX）</h3>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>\n<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>\n<p>关于索引的详细介绍，请看我写的 <a href=\"https://javaguide.cn/database/mysql/mysql-index.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 索引详解</a> 这篇文章。</p>\n<h4> 创建索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 添加索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 创建唯一索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 约束</h3>\n<p>SQL 约束用于规定表中的数据规则。</p>\n<p>如果存在违反约束的数据行为，行为会被约束终止。</p>\n<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>\n<p>约束类型：</p>\n<ul>\n<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>\n<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>\n</ul>\n<p>创建表时使用约束条件：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p>\n<h2> 事务处理</h2>\n<p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>\n<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>\n<p>指令：</p>\n<ul>\n<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>\n<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>\n<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>\n<li><code>COMMIT</code> - 提交事务。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p>\n<h2> 权限控制</h2>\n<p>要授予用户帐户权限，可以用<code>GRANT</code>命令。有撤销用户的权限，可以用<code>REVOKE</code>命令。这里以 MySQl 为例，介绍权限控制实际应用。</p>\n<p><code>GRANT</code>授予权限语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单解释一下：</p>\n<ol>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（<code>*.*</code>），database（<code>database.*</code>），table（<code>database.table</code>）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ol>\n<p><code>REVOKE</code> 撤销权限语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单解释一下：</p>\n<ol>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ol>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下表说明了可用于<code>GRANT</code>和<code>REVOKE</code>语句的所有允许权限：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特权</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>级别</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局</strong></td>\n<td>数据库</td>\n<td><strong>表</strong></td>\n<td><strong>列</strong></td>\n<td><strong>程序</strong></td>\n<td><strong>代理</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALL [PRIVILEGES]</td>\n<td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>允许用户使用 ALTER TABLE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>允许用户更改或删除存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>允许用户创建数据库和表</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>允许用户创建存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TABLESPACE</td>\n<td>允许用户创建，更改或删除表空间和日志文件组</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>允许用户创建或修改视图。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>允许用户使用 DELETE</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>允许用户删除数据库，表和视图</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EVENT</td>\n<td>启用事件计划程序的事件使用。</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>允许用户执行存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>允许用户读取数据库目录中的任何文件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>允许用户拥有授予或撤消其他帐户权限的权限。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>允许用户创建或删除索引。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>允许用户使用 INSERT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROXY</td>\n<td>启用用户代理。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REFERENCES</td>\n<td>允许用户创建外键</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>允许用户使用 FLUSH 操作</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>允许用户查询以查看主服务器或从属服务器的位置</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>允许用户使用复制从属从主服务器读取二进制日志事件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>允许用户使用 SELECT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>允许用户显示所有数据库</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>允许用户使用 SHOW CREATE VIEW 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>允许用户使用 mysqladmin shutdown 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TRIGGER</td>\n<td>允许用户使用 TRIGGER 操作。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>允许用户使用 UPDATE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>相当于“没有特权”</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3> 创建账户</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 修改账户名</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除账户</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查看权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 授予权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 更改密码</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 存储过程</h2>\n<p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"mysql存储过程\" tabindex=\"0\"><figcaption>mysql存储过程</figcaption></figure>\n<p>使用存储过程的好处：</p>\n<ul>\n<li>代码封装，保证了一定的安全性；</li>\n<li>代码复用；</li>\n<li>由于是预先编译，因此具有很高的性能。</li>\n</ul>\n<p>创建存储过程：</p>\n<ul>\n<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>\n<li>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</li>\n<li>给变量赋值都需要用 <code>select into</code> 语句。</li>\n<li>每次只能给一个变量赋值，不支持集合的操作。</li>\n</ul>\n<p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p>\n<h3> 创建存储过程</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用存储过程</h3>\n<div class=\"language-less line-numbers-mode\" data-ext=\"less\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 游标</h2>\n<p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。</p>\n<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<p>使用游标的几个明确步骤：</p>\n<ul>\n<li>\n<p>在使用游标前，必须声明(定义)它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</p>\n</li>\n<li>\n<p>一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</p>\n</li>\n<li>\n<p>对于填有数据的游标，根据需要取出(检索)各行。</p>\n</li>\n<li>\n<p>在结束游标使用时，必须关闭游标，可能的话，释放游标(有赖于具</p>\n<p>体的 DBMS)。</p>\n</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 触发器</h2>\n<p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p>\n<p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p>\n<p>使用触发器的优点：</p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p>使用触发器的缺点：</p>\n<ul>\n<li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener noreferrer\">ASP.NET</a>，Perl）在服务器端验证用户的输入。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n</ul>\n<p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p>\n<blockquote>\n<p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>\n<p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>\n</blockquote>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li>\n</ul>\n<p>但是，从 MySQL 版本 5.7.2+开始，可以为同一触发事件和操作时间定义多个触发器。</p>\n<p><strong><code>NEW</code> 和 <code>OLD</code></strong>：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：<code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li>\n</ul>\n<h3> 创建触发器</h3>\n<blockquote>\n<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>\n</blockquote>\n<p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p>\n<p>语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>说明：</p>\n<ul>\n<li><code>trigger_name</code>：触发器名</li>\n<li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<p>示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查看触发器</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除触发器</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 文章推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/I-ZT3zGTNBZ6egS7T09jyQ\" target=\"_blank\" rel=\"noopener noreferrer\">后端程序员必备：SQL 高性能优化指南！35+条优化建议立马 GET!</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">后端程序员必备：书写高质量 SQL 的 30 条建议</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png",
      "date_published": "2023-02-17T05:40:22.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Gradle核心概念总结",
      "url": "https://javaguide.cn/tools/gradle/gradle-core-concepts.html",
      "id": "https://javaguide.cn/tools/gradle/gradle-core-concepts.html",
      "summary": "这部分内容主要根据 Gradle 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。 Gradle 这部分内容属于可选内容，可以根据自身需求决定是否学习，目前国内还是使用 Maven 普遍一些。 Gradle 介绍 Gradle 官方文档是这样介绍的 Gradle 的： Gradle is an open-source build automation tool flexible enough to build almost any type of software. Gradle makes few assumptions about what you’re trying to build or how to build it. This makes Gradle particularly flexible. Gradle 是一个开源的构建自动化工具，它足够灵活，可以构建几乎任何类型的软件。Gradle 对你要构建什么或者如何构建它做了很少的假设。这使得 Gradle 特别灵活。",
      "content_html": "<blockquote>\n<p>这部分内容主要根据 Gradle 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。</p>\n</blockquote>\n<p>Gradle 这部分内容属于可选内容，可以根据自身需求决定是否学习，目前国内还是使用 Maven 普遍一些。</p>\n<h2> Gradle 介绍</h2>\n<p>Gradle 官方文档是这样介绍的 Gradle 的：</p>\n<blockquote>\n<p>Gradle is an open-source <a href=\"https://en.wikipedia.org/wiki/Build_automation\" target=\"_blank\" rel=\"noopener noreferrer\">build automation</a> tool flexible enough to build almost any type of software. Gradle makes few assumptions about what you’re trying to build or how to build it. This makes Gradle particularly flexible.</p>\n<p>Gradle 是一个开源的构建自动化工具，它足够灵活，可以构建几乎任何类型的软件。Gradle 对你要构建什么或者如何构建它做了很少的假设。这使得 Gradle 特别灵活。</p>\n</blockquote>\n<p>简单来说，Gradle 就是一个运行在 JVM 上的自动化的项目构建工具，用来帮助我们自动构建项目。</p>\n<p>对于开发者来说，Gradle 的主要作用主要有 3 个：</p>\n<ol>\n<li><strong>项目构建</strong>：提供标准的、跨平台的自动化项目构建方式。</li>\n<li><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li>\n<li><strong>统一开发结构</strong>：提供标准的、统一的项目结构。</li>\n</ol>\n<p>Gradle 构建脚本是使用 Groovy 或 Kotlin 语言编写的，表达能力非常强，也足够灵活。</p>\n<h2> Groovy 介绍</h2>\n<p>Gradle 是运行在 JVM 上的一个程序，它可以使用 Groovy 来编写构建脚本。</p>\n<p>Groovy 是运行在 JVM 上的脚本语言，是基于 Java 扩展的动态语言，它的语法和 Java 非常的相似，可以使用 Java 的类库。Groovy 可以用于面向对象编程，也可以用作纯粹的脚本语言。在语言的设计上它吸纳了 Java、Python、Ruby 和 Smalltalk 语言的优秀特性，比如动态类型转换、闭包和元编程支持。</p>\n<p>我们可以用学习 Java 的方式去学习 Groovy ，学习成本相对来说还是比较低的，即使开发过程中忘记 Groovy 语法，也可以用 Java 语法继续编码。</p>\n<p>基于 JVM 的语言有很多种比如 Groovy，Kotlin，Java，Scala，他们最终都会编译生成 Java 字节码文件并在 JVM 上运行。</p>\n<h2> Gradle 优势</h2>\n<p>Gradle 是新一代的构建系统，具有高效和灵活等诸多优势，广泛用于 Java 开发。不仅 Android 将其作为官方构建系统, 越来越多的 Java 项目比如 Spring Boot 也慢慢迁移到 Gradle。</p>\n<ul>\n<li>在灵活性上，Gradle 支持基于 Groovy 语言编写脚本，侧重于构建过程的灵活性，适合于构建复杂度较高的项目，可以完成非常复杂的构建。</li>\n<li>在粒度性上，Gradle 构建的粒度细化到了每一个 task 之中。并且它所有的 Task 源码都是开源的，在我们掌握了这一整套打包流程后，我们就可以通过去修改它的 Task 去动态改变其执行流程。</li>\n<li>在扩展性上，Gradle 支持插件机制，所以我们可以复用这些插件，就如同复用库一样简单方便。</li>\n</ul>\n<h2> Gradle Wrapper 介绍</h2>\n<p>Gradle 官方文档是这样介绍的 Gradle Wrapper 的：</p>\n<blockquote>\n<p>The recommended way to execute any Gradle build is with the help of the Gradle Wrapper (in short just “Wrapper”). The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary. As a result, developers can get up and running with a Gradle project quickly without having to follow manual installation processes saving your company time and money.</p>\n<p>执行 Gradle 构建的推荐方法是借助 Gradle Wrapper(简而言之就是“Wrapper”)。Wrapper 它是一个脚本，调用了已经声明的 Gradle 版本，如果需要的话，可以预先下载它。因此，开发人员可以快速启动并运行 Gradle 项目，而不必遵循手动安装过程，从而为公司节省时间和金钱。</p>\n</blockquote>\n<p>我们可以称 Gradle Wrapper 为 Gradle 包装器，它将 Gradle 再次包装，让所有的 Gradle 构建方法在 Gradle 包装器的帮助下运行。</p>\n<p>Gradle Wrapper 的工作流程图如下（图源<a href=\"https://docs.gradle.org/current/userguide/gradle_wrapper.html\" target=\"_blank\" rel=\"noopener noreferrer\">Gradle Wrapper 官方文档介绍</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/efa7a0006b04051e2b84cd116c6ccdfc.png\" alt=\"包装器工作流程\" tabindex=\"0\"><figcaption>包装器工作流程</figcaption></figure>\n<p>整个流程主要分为下面 3 步：</p>\n<ol>\n<li>首先当我们刚创建的时候，如果指定的版本没有被下载，就先会去 Gradle 的服务器中下载对应版本的压缩包；</li>\n<li>下载完成后需要先进行解压缩并且执行批处理文件；</li>\n<li>后续项目每次构建都会重用这个解压过的 Gradle 版本。</li>\n</ol>\n<p>Gradle Wrapper 会给我们带来下面这些好处：</p>\n<ol>\n<li>在给定的 Gradle 版本上标准化项目，从而实现更可靠和健壮的构建。</li>\n<li>可以让我们的电脑中不安装 Gradle 环境也可以运行 Gradle 项目。</li>\n<li>为不同的用户和执行环境（例如 IDE 或持续集成服务器）提供新的 Gradle 版本就像更改 Wrapper 定义一样简单。</li>\n</ol>\n<h3> 生成 Gradle Wrapper</h3>\n<p>如果想要生成 Gradle Wrapper 的话，需要本地配置好 Gradle 环境变量。Gradle 中已经内置了内置了 Wrapper Task，在项目根目录执行执行<code>gradle wrapper</code>命令即可帮助我们生成 Gradle Wrapper。</p>\n<p>执行命令 <code>gradle wrapper</code> 命令时可以指定一些参数来控制 wrapper 的生成。具体有如下两个配置参数：</p>\n<ul>\n<li><code>--gradle-version</code> 用于指定使用的 Gradle 的版本</li>\n<li><code>--gradle-distribution-url</code> 用于指定下载 Gradle 版本的 URL，该值的规则是 <code>http://services.gradle.org/distributions/gradle-${gradleVersion}-bin.zip</code></li>\n</ul>\n<p>执行<code>gradle wrapper</code>命令之后，Gradle Wrapper 就生成完成了，项目根目录中生成如下文件：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每个文件的含义如下：</p>\n<ul>\n<li><code>gradle-wrapper.jar</code>：包含了 Gradle 运行时的逻辑代码。</li>\n<li><code>gradle-wrapper.properties</code>：定义了 Gradle 的版本号和 Gradle 运行时的行为属性。</li>\n<li><code>gradlew</code>：Linux 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n<li><code>gradlew.bat</code>：Windows 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n</ul>\n<p><code>gradle-wrapper.properties</code> 文件的内容如下：</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>distributionBase</code>：Gradle 解包后存储的父目录。</li>\n<li><code>distributionPath</code>：<code>distributionBase</code>指定目录的子目录。<code>distributionBase+distributionPath</code>就是 Gradle 解包后的存放的具体目录。</li>\n<li><code>distributionUrl</code>：Gradle 指定版本的压缩包下载地址。</li>\n<li><code>zipStoreBase</code>：Gradle 压缩包下载后存储父目录。</li>\n<li><code>zipStorePath</code>：<code>zipStoreBase</code>指定目录的子目录。<code>zipStoreBase+zipStorePath</code>就是 Gradle 压缩包的存放位置。</li>\n</ul>\n<h3> 更新 Gradle Wrapper</h3>\n<p>更新 Gradle Wrapper 有 2 种方式：</p>\n<ol>\n<li>接修改<code>distributionUrl</code>字段，然后执行 Gradle 命令。</li>\n<li>执行 gradlew 命令<code>gradlew wrapper –-gradle-version [version]</code>。</li>\n</ol>\n<p>下面的命令会将 Gradle 版本升级为 7.6。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>gradle-wrapper.properties</code> 文件中的 <code>distributionUrl</code> 属性也发生了改变。</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 自定义 Gradle Wrapper</h3>\n<p>Gradle 已经内置了 Wrapper Task，因此构建 Gradle Wrapper 会生成 Gradle Wrapper 的属性文件，这个属性文件可以通过自定义 Wrapper Task 来设置。比如我们想要修改要下载的 Gralde 版本为 7.6，可以这么设置：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以设置 Gradle 发行版压缩包的下载地址和 Gradle 解包后的本地存储路径等配置。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>distributionUrl</code> 属性可以设置为本地的项目目录，你也可以设置为网络地址。</p>\n<h2> Gradle 任务</h2>\n<p>在 Gradle 中，任务(Task)是构建执行的单个工作单元。</p>\n<p>Gradle 的构建是基于 Task 进行的，当你运行项目的时候，实际就是在执行了一系列的 Task 比如编译 Java 源码的 Task、生成 jar 文件的 Task。</p>\n<p>Task 的声明方式如下（还有其他几种声明方式）：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个 Task 后，可以根据需要给 Task 添加不同的 Action，上面的“doLast”就是给队列尾增加一个 Action。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一个 Task 中可以有多个 Acton，从队列头部开始向队列尾部执行 Acton。</p>\n<p>Action 代表的是一个个函数、方法，每个 Task 都是一堆 Action 按序组成的执行图。</p>\n<p>Task 声明依赖的关键字是<code>dependsOn</code>，支持声明一个或多个依赖：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行 Task 之前，会先执行它的依赖 Task。</p>\n<p>我们还可以设置默认 Task，脚本中我们不调用默认 Task ，也会执行。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Gradle 本身也内置了很多 Task 比如 copy（复制文件）、delete（删除文件）。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Gradle 插件</h2>\n<p>Gradle 提供的是一套核心的构建机制，而 Gradle 插件则是运行在这套机制上的一些具体构建逻辑，其本质上和 <code>.gradle</code> 文件是相同。你可以将 Gradle 插件看作是封装了一系列 Task 并执行的工具。</p>\n<p>Gradle 插件主要分为两类：</p>\n<ul>\n<li>脚本插件：脚本插件就是一个普通的脚本文件，它可以被导入都其他构建脚本中。</li>\n<li>二进制插件 / 对象插件：在一个单独的插件模块中定义，其他模块通过 Plugin ID 应用插件。因为这种方式发布和复用更加友好，我们一般接触到的 Gradle 插件都是指二进制插件的形式。</li>\n</ul>\n<p>虽然 Gradle 插件与 .gradle 文件本质上没有区别，<code>.gradle</code> 文件也能实现 Gradle 插件类似的功能。但是，Gradle 插件使用了独立模块封装构建逻辑，无论是从开发开始使用来看，Gradle 插件的整体体验都更友好。</p>\n<ul>\n<li><strong>逻辑复用：</strong> 将相同的逻辑提供给多个相似项目复用，减少重复维护类似逻辑开销。当然 .gradle 文件也能做到逻辑复用，但 Gradle 插件的封装性更好；</li>\n<li><strong>组件发布：</strong> 可以将插件发布到 Maven 仓库进行管理，其他项目可以使用插件 ID 依赖。当然 .gradle 文件也可以放到一个远程路径被其他项目引用；</li>\n<li><strong>构建配置：</strong> Gradle 插件可以声明插件扩展来暴露可配置的属性，提供定制化能力。当然 .gradle 文件也可以做到，但实现会麻烦些。</li>\n</ul>\n<h2> Gradle 构建生命周期</h2>\n<p>Gradle 构建的生命周期有三个阶段：<strong>初始化阶段，配置阶段</strong>和<strong>运行阶段</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/dadbdf59fccd9a2ebf60a2d018541e52.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在初始化阶段与配置阶段之间、配置阶段结束之后、执行阶段结束之后，我们都可以加一些定制化的 Hook。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/5c297ccc4dac83229ff3e19caee9d1d2.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 初始化阶段</h3>\n<p>Gradle 支持单项目和多项目构建。在初始化阶段，Gradle 确定哪些项目将参与构建，并为每个项目创建一个 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener noreferrer\">Project 实例</a> 。本质上也就是执行 <code>settings.gradle</code> 脚本，从而读取整个项目中有多少个 Project 实例。</p>\n<h3> 配置阶段</h3>\n<p>在配置阶段，Gradle 会解析每个工程的 <code>build.gradle</code> 文件，创建要执行的任务子集和确定各种任务之间的关系，以供执行阶段按照顺序执行，并对任务的做一些初始化配置。</p>\n<p>每个 <code>build.gradle</code> 对应一个 Project 对象，配置阶段执行的代码包括 <code>build.gradle</code> 中的各种语句、闭包以及 Task 中的配置语句。</p>\n<p>在配置阶段结束后，Gradle 会根据 Task 的依赖关系会创建一个 <strong>有向无环图</strong> 。</p>\n<h3> 运行阶段</h3>\n<p>在运行阶段，Gradle 根据配置阶段创建和配置的要执行的任务子集，执行任务。</p>\n<h2> 参考</h2>\n<ul>\n<li>Gradle 官方文档：<a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.gradle.org/current/userguide/userguide.html</a></li>\n<li>Gradle 入门教程：<a href=\"https://www.imooc.com/wiki/gradlebase\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.imooc.com/wiki/gradlebase</a></li>\n<li>Groovy 快速入门看这篇就够了：<a href=\"https://cloud.tencent.com/developer/article/1358357\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1358357</a></li>\n<li>【Gradle】Gradle 的生命周期详解：<a href=\"https://juejin.cn/post/7067719629874921508\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7067719629874921508</a></li>\n<li>手把手带你自定义 Gradle 插件 —— Gradle 系列(2)：<a href=\"https://www.cnblogs.com/pengxurui/p/16281537.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/pengxurui/p/16281537.html</a></li>\n<li>Gradle 爬坑指南 -- 理解 Plugin、Task、构建流程：<a href=\"https://juejin.cn/post/6889090530593112077\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6889090530593112077</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/csdn/efa7a0006b04051e2b84cd116c6ccdfc.png",
      "date_published": "2023-02-02T10:43:22.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "开发工具"
      ]
    },
    {
      "title": "MySQL自增主键一定是连续的吗",
      "url": "https://javaguide.cn/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "id": "https://javaguide.cn/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "summary": "作者：飞天小牛肉 原文：https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ 众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。 但实际上，MySQL 的自增主键并不能保证一定是连续递增的。",
      "content_html": "<blockquote>\n<p>作者：飞天小牛肉</p>\n<p>原文：<a href=\"https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ</a></p>\n</blockquote>\n<p>众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。</p>\n<p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。</p>\n<p>下面举个例子来看下，如下所示创建一张表：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 自增值保存在哪里？</h2>\n<p>使用 <code>insert into test_pk values(null, 1, 1)</code> 插入一行数据，再执行 <code>show create table</code> 命令来看一下表的结构定义：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/c17e46230bd34150966f0d86b2ad5e91~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/3ec0514dd7be423d80b9e7f2d52f5902~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。</p>\n<p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p>\n<p>1）MyISAM 引擎的自增值保存在数据文件中</p>\n<p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</p>\n<p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/61b8dc9155624044a86d91c368b20059~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿ 也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/27fdb15375664249a31f88b64e6e5e66~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/dee15f93e65d44d384345a03404f3481~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>以上，是在我本地 MySQL 5.x 版本的实验，实际上，<strong>到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力</strong> ，也就是实现了“如果发生重启，表的自增值可以根据 redo log 恢复为 MySQL 重启前的值”</p>\n<p>也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p>\n<p>理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。</p>\n<h2> 自增值不连续的场景</h2>\n<h3> 自增值不连续场景 1</h3>\n<p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>\n<ul>\n<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>\n<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>\n</ul>\n<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p>\n<ul>\n<li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li>\n<li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li>\n</ul>\n<p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101</p>\n<p>一定是这样吗？</p>\n<p>非也~</p>\n<p>了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数</p>\n<p>这个奇数偶数其实是通过 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p>\n<p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100 的值，作为新的自增值。</p>\n<p>所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p>\n<p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的</p>\n<h3> 自增值不连续场景 2</h3>\n<p>举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/c22c4f2cea234c7ea496025eb826c3bc~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/c0325e31398d4fa6bb1cbe08ef797b7f~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！</p>\n<p>这是为啥？</p>\n<p>我们来分析下这个 insert 语句的执行流程：</p>\n<ol>\n<li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li>\n<li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li>\n<li>将传入的记录改成 (2,1,1);</li>\n<li>将表的自增值改成 3；</li>\n<li>继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回</li>\n</ol>\n<p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p>\n<p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p>\n<p>至此，我们已经罗列了两种自增主键不连续的情况：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n</ol>\n<p>除此之外，事务回滚也会导致这种情况</p>\n<h3> 自增值不连续场景 3</h3>\n<p>我们现在表里有一行 <code>(1,1,1)</code> 的记录，AUTO_INCREMENT = 3：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/6220fcf7dac54299863e43b6fb97de3e~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们先插入一行数据 <code>(null, 2, 2)</code>，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/3f02d46437d643c3b3d9f44a004ab269~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>再去执行这样一段 SQL：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/faf5ce4a2920469cae697f845be717f5~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/6cb4c02722674dd399939d3d03a431c1~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/e6eea1c927424ac7bda34a511ca521ae~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 <code>5</code> 了：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/80da69dd13b543c4a32d6ed832a3c568~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？</p>\n<p>事实上，这么做的主要原因是为了提高性能。</p>\n<p>我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p>\n<p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。</p>\n<ol>\n<li>假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是 3，之后继续执行。</li>\n<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。</li>\n<li>接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/5f26f02e60f643c9a7cab88a9f1bdce9~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>而为了解决这个主键冲突，有两种方法：</p>\n<ol>\n<li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li>\n<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li>\n</ol>\n<p>很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。</p>\n<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>\n<p>综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。</p>\n<h3> 自增值不连续场景 4</h3>\n<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>\n<ol>\n<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>\n<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>\n<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>\n<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>\n</ol>\n<p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>\n<p>而对于 <code>insert … select</code>、replace …… select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。</p>\n<p>举个例子，假设我们现在这个表有下面这些数据：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/6453cfc107f94e3bb86c95072d443472~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我们创建一个和当前表 <code>test_pk</code> 有相同结构定义的表 <code>test_pk2</code>：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/45248a6dc34f431bba14d434bee2c79e~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>然后使用 <code>insert...select</code> 往 <code>teset_pk2</code> 表中批量插入数据：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/c1b061e86bae484694d15ceb703b10ca~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>可以看到，成功导入了数据。</p>\n<p>再来看下 <code>test_pk2</code> 的自增值是多少：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/0ff9039366154c738331d64ebaf88d3b~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>如上分析，是 8 而不是 6</p>\n<p>具体来说，insert……select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p>\n<ul>\n<li>第一次申请到了一个 id：id=1</li>\n<li>第二次被分配了两个 id：id=2 和 id=3</li>\n<li>第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7</li>\n</ul>\n<p>由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 <code>insert into test_pk2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/51612fbac3804cff8c5157df21d6e355~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 小结</h2>\n<p>本文总结下自增值不连续的 4 个场景：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n<li>批量插入（如 <code>insert...select</code> 语句）</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/p3-juejin/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.png",
      "date_published": "2023-02-02T09:54:04.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "乐观锁和悲观锁详解",
      "url": "https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html",
      "id": "https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html",
      "summary": "如果将悲观锁（Pessimistic Lock）和乐观锁（PessimisticLock 或 OptimisticLock）对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。 在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！ 什么是悲观锁？ 悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。",
      "content_html": "<p>如果将悲观锁（Pessimistic Lock）和乐观锁（PessimisticLock 或 OptimisticLock）对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。</p>\n<p>在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！</p>\n<h2> 什么是悲观锁？</h2>\n<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>\n<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>\n<h2> 什么是乐观锁？</h2>\n<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>\n<p>像 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/JUC原子类概览-20230814005415437.png\" alt=\"JUC原子类概览\" tabindex=\"0\"><figcaption>JUC原子类概览</figcaption></figure>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。</p>\n<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>\n<p>理论上来说：</p>\n<ul>\n<li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>\n<li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>\n</ul>\n<h2> 如何实现乐观锁？</h2>\n<p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>\n<h3> 版本号机制</h3>\n<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>\n<p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p>\n<ol>\n<li>操作员 A 此时将其读出（ <code>version</code>=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>\n<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>\n<li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>=1 ），连同帐户扣除后余额（ <code>balance</code>=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li>\n<li>操作员 B 完成了操作，也将版本号（ <code>version</code>=1 ）试图向数据库提交数据（ <code>balance</code>=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>\n</ol>\n<p>这样就避免了操作员 B 用基于 <code>version</code>=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p>\n<h3> CAS 算法</h3>\n<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>\n<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>\n<blockquote>\n<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>\n</blockquote>\n<p>CAS 涉及到三个操作数：</p>\n<ul>\n<li><strong>V</strong>：要更新的变量值(Var)</li>\n<li><strong>E</strong>：预期值(Expected)</li>\n<li><strong>N</strong>：拟写入的新值(New)</li>\n</ul>\n<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>\n<p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p>\n<ol>\n<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>\n<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>\n</ol>\n<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n<p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>\n<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于 <code>Unsafe</code> 类的详细介绍可以看这篇文章：<a href=\"https://javaguide.cn/java/basis/unsafe.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 魔法类 Unsafe 详解 - JavaGuide - 2022</a> 。</p>\n<h2> 乐观锁存在哪些问题？</h2>\n<p>ABA 问题是乐观锁最常见的问题。</p>\n<h3> ABA 问题</h3>\n<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>\"ABA\"问题。</strong></p>\n<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 循环时间长开销大</h3>\n<p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>\n<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>\n<ol>\n<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>\n<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>\n</ol>\n<h3> 只能保证一个共享变量的原子操作</h3>\n<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>\n<h2> 总结</h2>\n<ul>\n<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li>\n<li>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</li>\n<li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li>\n<li>乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Java 并发编程核心 78 讲》</li>\n<li>通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其 Java 实现！：<a href=\"https://zhuanlan.zhihu.com/p/71156910\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/71156910</a></li>\n<li>一文彻底搞懂 CAS 实现原理 &amp; 深入到 CPU 指令：<a href=\"https://zhuanlan.zhihu.com/p/94976168\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/94976168</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88-20230814005415437.png",
      "date_published": "2023-01-31T08:27:36.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Elasticsearch常见面试题总结(付费)",
      "url": "https://javaguide.cn/database/elasticsearch/elasticsearch-questions-01.html",
      "id": "https://javaguide.cn/database/elasticsearch/elasticsearch-questions-01.html",
      "summary": "Elasticsearch 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>Elasticsearch</strong> 相关的面试题为我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>中。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/elasticsearch-questions.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220304102536445.png\" alt=\"《Java 面试指北》内容概览\" tabindex=\"0\"><figcaption>《Java 面试指北》内容概览</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/elasticsearch-questions.png",
      "date_published": "2023-01-29T03:31:13.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL执行计划分析",
      "url": "https://javaguide.cn/database/mysql/mysql-query-execution-plan.html",
      "id": "https://javaguide.cn/database/mysql/mysql-query-execution-plan.html",
      "summary": "本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g 优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL EXPLAIN 执行计划相关知识。",
      "content_html": "<blockquote>\n<p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：<a href=\"https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g</a></p>\n</blockquote>\n<p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL <code>EXPLAIN</code> 执行计划相关知识。</p>\n<h2> 什么是执行计划？</h2>\n<p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p>\n<p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>\n<h2> 如何获取执行计划？</h2>\n<p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>\n<p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>我们简单来看下一条查询语句的执行计划：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>SELECT 查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT 关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>所选索引的长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>附加信息</td>\n</tr>\n</tbody>\n</table>\n<h2> 如何分析 EXPLAIN 结果？</h2>\n<p>为了分析 <code>EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p>\n<h3> id</h3>\n<p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p>\n<p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p>\n<h3> select_type</h3>\n<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>\n<ul>\n<li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li>\n<li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li>\n<li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li>\n<li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li>\n<li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li>\n<li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>\n</ul>\n<h3> table</h3>\n<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>\n<ul>\n<li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>\n<li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li>\n<li><strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>\n</ul>\n<h3> type（重要）</h3>\n<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>\n<p>常见的几种类型具体含义如下：</p>\n<ul>\n<li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>\n<li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>\n<li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>\n<li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>\n<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>\n<li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>\n<li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>\n<li><strong>ALL</strong>：全表扫描。</li>\n</ul>\n<h3> possible_keys</h3>\n<p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>\n<h3> key（重要）</h3>\n<p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>\n<h3> key_len</h3>\n<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>\n<h3> rows</h3>\n<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n<h3> Extra（重要）</h3>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>\n<li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h2> 参考</h2>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></li>\n<li><a href=\"https://juejin.cn/post/6953444668973514789\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6953444668973514789</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2023-01-14T10:33:11.000Z",
      "date_modified": "2023-08-23T01:54:01.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "NoSQL基础知识总结",
      "url": "https://javaguide.cn/database/nosql.html",
      "id": "https://javaguide.cn/database/nosql.html",
      "summary": "NoSQL 是什么？ NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。 NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。",
      "content_html": "<h2> NoSQL 是什么？</h2>\n<p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> SQL 和 NoSQL 有什么区别？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th>SQL 数据库</th>\n<th>NoSQL 数据库</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">数据存储模型</td>\n<td>结构化存储，具有固定行和列的表格</td>\n<td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">发展历程</td>\n<td>开发于 1970 年代，重点是减少数据重复</td>\n<td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">例子</td>\n<td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td>\n<td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACID 属性</td>\n<td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td>\n<td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td>\n<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩展</td>\n<td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>\n<td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">用途</td>\n<td>普通企业级的项目的数据存储</td>\n<td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询语法</td>\n<td>结构化查询语言 (SQL)</td>\n<td>数据访问语法可能因数据库而异</td>\n</tr>\n</tbody>\n</table>\n<h2> NoSQL 数据库有什么优势？</h2>\n<p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p>\n<ul>\n<li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li>\n<li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>\n<li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<h2> NoSQL 数据库有哪些类型？</h2>\n<p>NoSQL 数据库主要可以分为下面四种类型：</p>\n<ul>\n<li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<p>下面这张图片来源于 <a href=\"https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/relational-vs-nosql-data\" target=\"_blank\" rel=\"noopener noreferrer\">微软的官方文档 | 关系数据与 NoSQL 数据</a>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/types-of-nosql-datastores.png\" alt=\"NoSQL 数据模型\" tabindex=\"0\"><figcaption>NoSQL 数据模型</figcaption></figure>\n<h2> 参考</h2>\n<ul>\n<li>NoSQL 是什么？- MongoDB 官方文档：<a href=\"https://www.mongodb.com/zh-cn/nosql-explained\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/zh-cn/nosql-explained</a></li>\n<li>什么是 NoSQL? - AWS：<a href=\"https://aws.amazon.com/cn/nosql/\" target=\"_blank\" rel=\"noopener noreferrer\">https://aws.amazon.com/cn/nosql/</a></li>\n<li>NoSQL vs. SQL Databases - MongoDB 官方文档：<a href=\"https://www.mongodb.com/zh-cn/nosql-explained/nosql-vs-sql\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/zh-cn/nosql-explained/nosql-vs-sql</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（上）",
      "url": "https://javaguide.cn/database/mongodb/mongodb-questions-01.html",
      "id": "https://javaguide.cn/database/mongodb/mongodb-questions-01.html",
      "summary": "少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。 MongoDB 基础 MongoDB 是什么？ MongoDB 是一个基于 分布式文件存储 的开源 NoSQL 数据库系统，由 C++ 编写的。MongoDB 提供了 面向文档 的存储方式，操作起来比较简单和容易，支持“无模式”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 文档类型数据库 。",
      "content_html": "<blockquote>\n<p>少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。</p>\n</blockquote>\n<h2> MongoDB 基础</h2>\n<h3> MongoDB 是什么？</h3>\n<p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 提供了 <strong>面向文档</strong> 的存储方式，操作起来比较简单和容易，支持“<strong>无模式</strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong> 。</p>\n<p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p>\n<h3> MongoDB 的存储结构是什么？</h3>\n<p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：</p>\n<ul>\n<li><strong>文档（Document）</strong>：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。</li>\n<li><strong>集合（Collection）</strong>：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。</li>\n<li><strong>数据库（Database）</strong>：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。</li>\n</ul>\n<p>也就是说，MongoDB 将数据记录存储为文档 （更具体来说是<a href=\"https://www.mongodb.com/docs/manual/core/document/#std-label-bson-document-format\" target=\"_blank\" rel=\"noopener noreferrer\">BSON 文档</a>），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。</p>\n<p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>SQL</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>表（Table）</td>\n<td>集合（Collection）</td>\n</tr>\n<tr>\n<td>行（Row）</td>\n<td>文档（Document）</td>\n</tr>\n<tr>\n<td>列（Col）</td>\n<td>字段（Field）</td>\n</tr>\n<tr>\n<td>主键（Primary Key）</td>\n<td>对象 ID（Objectid）</td>\n</tr>\n<tr>\n<td>索引（Index）</td>\n<td>索引（Index）</td>\n</tr>\n<tr>\n<td>嵌套表（Embedded Table）</td>\n<td>嵌入式文档（Embedded Document）</td>\n</tr>\n<tr>\n<td>数组（Array）</td>\n<td>数组（Array）</td>\n</tr>\n</tbody>\n</table>\n<h4> 文档</h4>\n<p>MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。字段的值可能包括其他文档、数组和文档数组。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/crud-annotated-document..png\" alt=\"MongoDB 文档\" tabindex=\"0\"><figcaption>MongoDB 文档</figcaption></figure>\n<p>文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。</p>\n<ul>\n<li>键不能含有 <code>\\0</code>(空字符）。这个字符用来表示键的结尾。</li>\n<li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线<code>_</code>开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<p><strong>BSON [bee·sahn]</strong> 是 Binary <a href=\"http://json.org/\" target=\"_blank\" rel=\"noopener noreferrer\">JSON</a>的简称，是 JSON 文档的二进制表示，支持将文档和数组嵌入到其他文档和数组中，还包含允许表示不属于 JSON 规范的数据类型的扩展。有关 BSON 规范的内容，可以参考 <a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener noreferrer\">bsonspec.org</a>，另见<a href=\"https://www.mongodb.com/docs/manual/reference/bson-types/\" target=\"_blank\" rel=\"noopener noreferrer\">BSON 类型</a>。</p>\n<p>根据维基百科对 BJSON 的介绍，BJSON 的遍历速度优于 JSON，这也是 MongoDB 选择 BSON 的主要原因，但 BJSON 需要更多的存储空间。</p>\n<blockquote>\n<p>与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/bsonspec.org.png\" alt=\"BSON 官网首页\" tabindex=\"0\"><figcaption>BSON 官网首页</figcaption></figure>\n<h4> 集合</h4>\n<p>MongoDB 集合存在于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。不过，通常情况下，插入集合中的数据都会有一定的关联性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/crud-annotated-collection.png\" alt=\"MongoDB 集合\" tabindex=\"0\"><figcaption>MongoDB 集合</figcaption></figure>\n<p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p>\n<p>集合名可以是满足下列条件的任意 UTF-8 字符串：</p>\n<ul>\n<li>集合名不能是空字符串<code>\"\"</code>。</li>\n<li>集合名不能含有 <code>\\0</code> （空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以\"system.\"开头，这是为系统集合保留的前缀。例如 <code>system.users</code> 这个集合保存着数据库的用户信息，<code>system.namespaces</code> 集合保存着所有数据库集合的信息。</li>\n<li>集合名必须以下划线或者字母符号开始，并且不能包含 <code>$</code>。</li>\n</ul>\n<h4> 数据库</h4>\n<p>数据库用于存储所有集合，而集合又用于存储所有文档。一个 MongoDB 中可以创建多个数据库，每一个数据库都有自己的集合和权限。</p>\n<p>MongoDB 预留了几个特殊的数据库。</p>\n<ul>\n<li><strong>admin</strong> : admin 数据库主要是保存 root 用户和角色。例如，system.users 表存储用户，system.roles 表存储角色。一般不建议用户直接操作这个数据库。将一个用户添加到这个数据库，且使它拥有 admin 库上的名为 dbAdminAnyDatabase 的角色权限，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如关闭服务器。</li>\n<li><strong>local</strong> : local 数据库是不会被复制到其他分片的，因此可以用来存储本地单台服务器的任意 collection。一般不建议用户直接使用 local 库存储任何数据，也不建议进行 CRUD 操作，因为数据无法被正常备份与恢复。</li>\n<li><strong>config</strong> : 当 MongoDB 使用分片设置时，config 数据库可用来保存分片的相关信息。</li>\n<li><strong>test</strong> : 默认创建的测试库，连接 <a href=\"https://mongoing.com/docs/reference/program/mongod.html\" target=\"_blank\" rel=\"noopener noreferrer\">mongod</a> 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库。</li>\n</ul>\n<p>数据库名可以是满足以下条件的任意 UTF-8 字符串：</p>\n<ul>\n<li>不能是空字符串<code>\"\"</code>。</li>\n<li>不得含有<code>' '</code>（空格)、<code>.</code>、<code>$</code>、<code>/</code>、<code>\\</code>和 <code>\\0</code> (空字符)。</li>\n<li>应全部小写。</li>\n<li>最多 64 字节。</li>\n</ul>\n<p>数据库名最终会变成文件系统里的文件，这也就是有如此多限制的原因。</p>\n<h3> MongoDB 有什么特点？</h3>\n<ul>\n<li><strong>数据记录被存储为文档</strong>：MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li>\n<li><strong>模式自由</strong>：集合的概念类似 MySQL 里的表，但它不需要定义任何模式，能够用更少的数据对象表现复杂的领域模型对象。</li>\n<li><strong>支持多种查询方式</strong>：MongoDB 查询 API 支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li>\n<li><strong>支持 ACID 事务</strong>：NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</li>\n<li><strong>高效的二进制存储</strong>：存储在集合中的文档，是以键值对的形式存在的。键用于唯一标识一个文档，一般是 ObjectId 类型，值是以 BSON 形式存在的。BSON = Binary JSON， 是在 JSON 基础上加了一些类型及元数据描述的格式。</li>\n<li><strong>自带数据压缩功能</strong>：存储同样的数据所需的资源更少。</li>\n<li><strong>支持 mapreduce</strong>：通过分治的方式完成复杂的聚合任务。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 <a href=\"https://www.mongodb.com/docs/manual/core/aggregation-pipeline/\" target=\"_blank\" rel=\"noopener noreferrer\">聚合管道</a>。聚合管道提供比 map-reduce 更好的性能和可用性。</li>\n<li><strong>支持多种类型的索引</strong>：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li>\n<li><strong>支持 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li><strong>支持分片集群</strong>：MongoDB 支持集群自动切分数据，让集群存储更多的数据，具备更强的性能。在数据插入和更新时，能够自动路由和存储。</li>\n<li><strong>支持存储大文件</strong>：MongoDB 的单文档存储空间要求不超过 16MB。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行分块处理，然后将这些切分后的小文档保存在数据库中。</li>\n</ul>\n<h3> MongoDB 适合什么应用场景？</h3>\n<p><strong>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。</strong></p>\n<p>选用 MongoDB 应该充分考虑 MongoDB 的优势，结合实际项目的需求来决定：</p>\n<ul>\n<li>随着项目的发展，使用类 JSON 格式（BSON）保存数据是否满足项目需求？MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li>\n<li>是否需要大数据量的存储？是否需要快速水平扩展？MongoDB 支持分片集群，可以很方便地添加更多的节点（实例），让集群存储更多的数据，具备更强的性能。</li>\n<li>是否需要更多类型索引来满足更多应用场景？MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li>\n<li>……</li>\n</ul>\n<h2> MongoDB 存储引擎</h2>\n<h3> MongoDB 支持哪些存储引擎？</h3>\n<p>存储引擎（Storage Engine）是数据库的核心组件，负责管理数据在内存和磁盘中的存储方式。</p>\n<p>与 MySQL 一样，MongoDB 采用的也是 <strong>插件式的存储引擎架构</strong> ，支持不同类型的存储引擎，不同的存储引擎解决不同场景的问题。在创建数据库或集合时，可以指定存储引擎。</p>\n<blockquote>\n<p>插件式的存储引擎架构可以实现 Server 层和存储引擎层的解耦，可以支持多种存储引擎，如 MySQL 既可以支持 B-Tree 结构的 InnoDB 存储引擎，还可以支持 LSM 结构的 RocksDB 存储引擎。</p>\n</blockquote>\n<p>在存储引擎刚出来的时候，默认是使用 MMAPV1 存储引擎，MongoDB4.x 版本不再支持 MMAPv1 存储引擎。</p>\n<p>现在主要有下面这两种存储引擎：</p>\n<ul>\n<li><strong>WiredTiger 存储引擎</strong>：自 MongoDB 3.2 以后，默认的存储引擎为 <a href=\"https://www.mongodb.com/docs/manual/core/wiredtiger/\" target=\"_blank\" rel=\"noopener noreferrer\">WiredTiger 存储引擎</a> 。非常适合大多数工作负载，建议用于新部署。WiredTiger 提供文档级并发模型、检查点和数据压缩（后文会介绍到）等功能。</li>\n<li><strong>In-Memory 存储引擎</strong>：<a href=\"https://www.mongodb.com/docs/manual/core/inmemory/\" target=\"_blank\" rel=\"noopener noreferrer\">In-Memory 存储引擎</a>在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是将它们保留在内存中以获得更可预测的数据延迟。</li>\n</ul>\n<p>此外，MongoDB 3.0 提供了 <strong>可插拔的存储引擎 API</strong> ，允许第三方为 MongoDB 开发存储引擎，这点和 MySQL 也比较类似。</p>\n<h3> WiredTiger 基于 LSM Tree 还是 B+ Tree？</h3>\n<p>目前绝大部分流行的数据库存储引擎都是基于 B/B+ Tree 或者 LSM(Log Structured Merge) Tree 来实现的。对于 NoSQL 数据库来说，绝大部分（比如 HBase、Cassandra、RocksDB）都是基于 LSM 树，MongoDB 不太一样。</p>\n<p>上面也说了，自 MongoDB 3.2 以后，默认的存储引擎为 WiredTiger 存储引擎。在 WiredTiger 引擎官网上，我们发现 WiredTiger 使用的是 B+ 树作为其存储结构：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此外，WiredTiger 还支持 <a href=\"https://source.wiredtiger.com/3.1.0/lsm.html\" target=\"_blank\" rel=\"noopener noreferrer\">LSM(Log Structured Merge)</a> 树作为存储结构，MongoDB 在使用 WiredTiger 作为存储引擎时，默认使用的是 B+ 树。</p>\n<p>如果想要了解 MongoDB 使用 B 树的原因，可以看看这篇文章：<a href=\"https://mp.weixin.qq.com/s/mMWdpbYRiT6LQcdaj4hgXQ\" target=\"_blank\" rel=\"noopener noreferrer\">为什么 MongoDB 使用 B 树？</a>。</p>\n<p>使用 B+ 树时，WiredTiger 以 <strong>page</strong> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 page，共有三种类型的 page：</p>\n<ul>\n<li><strong>root page（根节点）</strong>：B+ 树的根节点。</li>\n<li><strong>internal page（内部节点）</strong>：不实际存储数据的中间索引节点。</li>\n<li><strong>leaf page（叶子节点）</strong>：真正存储数据的叶子节点，包含一个页头（page header）、块头（block header）和真正的数据（key/value），其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 checksum、块在磁盘上的寻址位置等信息。</li>\n</ul>\n<p>其整体结构如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-b-plus-tree-integral-structure.png\" alt=\"WiredTiger B+树整体结构\" tabindex=\"0\"><figcaption>WiredTiger B+树整体结构</figcaption></figure>\n<p>如果想要深入研究学习 WiredTiger 存储引擎，推荐阅读 MongoDB 中文社区的 <a href=\"https://mongoing.com/archives/category/wiredtiger%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%b3%bb%e5%88%97\" target=\"_blank\" rel=\"noopener noreferrer\">WiredTiger 存储引擎系列</a>。</p>\n<h2> MongoDB 聚合</h2>\n<h3> MongoDB 聚合有什么用？</h3>\n<p>实际项目中，我们经常需要将多个文档甚至是多个集合汇总到一起计算分析（比如求和、取最大值）并返回计算后的结果，这个过程被称为 <strong>聚合操作</strong> 。</p>\n<p>根据官方文档介绍，我们可以使用聚合操作来：</p>\n<ul>\n<li>将来自多个文档的值组合在一起。</li>\n<li>对集合中的数据进行的一系列运算。</li>\n<li>分析数据随时间的变化。</li>\n</ul>\n<h3> MongoDB 提供了哪几种执行聚合的方法？</h3>\n<p>MongoDB 提供了两种执行聚合的方法：</p>\n<ul>\n<li><strong>聚合管道（Aggregation Pipeline）</strong>：执行聚合操作的首选方法。</li>\n<li><strong>单一目的聚合方法（Single purpose aggregation methods）</strong>：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li>\n</ul>\n<p>绝大部分文章中还提到了 <strong>map-reduce</strong> 这种聚合方法。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 <a href=\"https://www.mongodb.com/docs/manual/core/aggregation-pipeline/\" target=\"_blank\" rel=\"noopener noreferrer\">聚合管道</a>。聚合管道提供比 map-reduce 更好的性能和可用性。</p>\n<p>MongoDB 聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。</p>\n<p>每个管道的工作流程是：</p>\n<ol>\n<li>接受一系列原始数据文档</li>\n<li>对这些文档进行一系列运算</li>\n<li>结果文档输出给下一个阶段</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-aggregation-stage.png\" alt=\"管道的工作流程\" tabindex=\"0\"><figcaption>管道的工作流程</figcaption></figure>\n<p><strong>常用阶段操作符</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$match</td>\n<td>匹配操作符，用于对文档集合进行筛选</td>\n</tr>\n<tr>\n<td>$project</td>\n<td>投射操作符，用于重构每一个文档的字段，可以提取字段，重命名字段，甚至可以对原有字段进行操作后新增字段</td>\n</tr>\n<tr>\n<td>$sort</td>\n<td>排序操作符，用于根据一个或多个字段对文档进行排序</td>\n</tr>\n<tr>\n<td>$limit</td>\n<td>限制操作符，用于限制返回文档的数量</td>\n</tr>\n<tr>\n<td>$skip</td>\n<td>跳过操作符，用于跳过指定数量的文档</td>\n</tr>\n<tr>\n<td>$count</td>\n<td>统计操作符，用于统计文档的数量</td>\n</tr>\n<tr>\n<td>$group</td>\n<td>分组操作符，用于对文档集合进行分组</td>\n</tr>\n<tr>\n<td>$unwind</td>\n<td>拆分操作符，用于将数组中的每一个值拆分为单独的文档</td>\n</tr>\n<tr>\n<td>$lookup</td>\n<td>连接操作符，用于连接同一个数据库中另一个集合，并获取指定的文档，类似于 populate</td>\n</tr>\n</tbody>\n</table>\n<p>更多操作符介绍详见官方文档：<a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.mongodb.com/manual/reference/operator/aggregation/</a></p>\n<p>阶段操作符用于 <code>db.collection.aggregate</code> 方法里面，数组参数中的第一层。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面是 MongoDB 官方文档中的一个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> MongoDB 事务</h2>\n<blockquote>\n<p>MongoDB 事务想要搞懂原理还是比较花费时间的，我自己也没有搞太明白。因此，我这里只是简单介绍一下 MongoDB 事务，想要了解原理的小伙伴，可以自行搜索查阅相关资料。</p>\n<p>这里推荐几篇文章，供大家参考：</p>\n<ul>\n<li><a href=\"https://mongoing.com/archives/82187\" target=\"_blank\" rel=\"noopener noreferrer\">技术干货| MongoDB 事务原理</a></li>\n<li><a href=\"https://developer.aliyun.com/article/782494\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 一致性模型设计与实现</a></li>\n<li><a href=\"https://www.mongodb.com/docs/upcoming/core/transactions/\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 官方文档对事务的介绍</a></li>\n</ul>\n</blockquote>\n<p>我们在介绍 NoSQL 数据的时候也说过，NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。</p>\n<p>与关系型数据库一样，MongoDB 事务同样具有 ACID 特性：</p>\n<ul>\n<li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。WiredTiger 存储引擎支持读未提交（ read-uncommitted ）、读已提交（ read-committed ）和快照（ snapshot ）隔离，MongoDB 启动时默认选快照隔离。在不同隔离级别下，一个事务的生命周期内，可能出现脏读、不可重复读、幻读等现象。</li>\n<li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<p>关于事务的详细介绍这篇文章就不多说了，感兴趣的可以看看我写的<a href=\"/database/mysql/mysql-questions-01.html\" target=\"blank\">MySQL 常见面试题总结</a>这篇文章，里面有详细介绍到。</p>\n<p>MongoDB 单文档原生支持原子性，也具备事务的特性。当谈论 MongoDB 事务的时候，通常指的是 <strong>多文档</strong> 。MongoDB 4.0 加入了对多文档 ACID 事务的支持，但只支持复制集部署模式下的 ACID 事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了 <strong>分布式事务</strong> ，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</p>\n<p>根据官方文档介绍：</p>\n<blockquote>\n<p>从 MongoDB 4.2 开始，分布式事务和多文档事务在 MongoDB 中是一个意思。分布式事务是指分片集群和副本集上的多文档事务。从 MongoDB 4.2 开始，多文档事务（无论是在分片集群还是副本集上）也称为分布式事务。</p>\n</blockquote>\n<p>在大多数情况下，多文档事务比单文档写入会产生更大的性能成本。对于大部分场景来说， <a href=\"https://www.mongodb.com/docs/upcoming/core/data-model-design/#std-label-data-modeling-embedding\" target=\"_blank\" rel=\"noopener noreferrer\">非规范化数据模型（嵌入式文档和数组）</a> 依然是最佳选择。也就是说，适当地对数据进行建模可以最大限度地减少对多文档事务的需求。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>从 MongoDB 4.2 开始，多文档事务支持副本集和分片集群，其中：主节点使用 WiredTiger 存储引擎，同时从节点使用 WiredTiger 存储引擎或 In-Memory 存储引擎。在 MongoDB 4.0 中，只有使用 WiredTiger 存储引擎的副本集支持事务。</li>\n<li>在 MongoDB 4.2 及更早版本中，你无法在事务中创建集合。从 MongoDB 4.4 开始，您可以在事务中创建集合和索引。有关详细信息，请参阅 <a href=\"https://www.mongodb.com/docs/upcoming/core/transactions/#std-label-transactions-create-collections-indexes\" target=\"_blank\" rel=\"noopener noreferrer\">在事务中创建集合和索引</a>。</li>\n</ul>\n<h2> MongoDB 数据压缩</h2>\n<p>借助 WiredTiger 存储引擎（ MongoDB 3.2 后的默认存储引擎），MongoDB 支持对所有集合和索引进行压缩。压缩以额外的 CPU 为代价最大限度地减少存储使用。</p>\n<p>默认情况下，WiredTiger 使用 <a href=\"https://github.com/google/snappy\" target=\"_blank\" rel=\"noopener noreferrer\">Snappy</a> 压缩算法（谷歌开源，旨在实现非常高的速度和合理的压缩，压缩比 3 ～ 5 倍）对所有集合使用块压缩，对所有索引使用前缀压缩。</p>\n<p>除了 Snappy 之外，对于集合还有下面这些压缩算法：</p>\n<ul>\n<li><a href=\"https://github.com/madler/zlib\" target=\"_blank\" rel=\"noopener noreferrer\">zlib</a>：高度压缩算法，压缩比 5 ～ 7 倍</li>\n<li><a href=\"https://github.com/facebook/zstd\" target=\"_blank\" rel=\"noopener noreferrer\">Zstandard</a>（简称 zstd）：Facebook 开源的一种快速无损压缩算法，针对 zlib 级别的实时压缩场景和更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li>\n</ul>\n<p>WiredTiger 日志也会被压缩，默认使用的也是 Snappy 压缩算法。如果日志记录小于或等于 128 字节，WiredTiger 不会压缩该记录。</p>\n<h2> 参考</h2>\n<ul>\n<li>MongoDB 官方文档（主要参考资料，以官方文档为准）：<a href=\"https://www.mongodb.com/docs/manual/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/</a></li>\n<li>《MongoDB 权威指南》</li>\n<li>技术干货| MongoDB 事务原理 - MongoDB 中文社区：<a href=\"https://mongoing.com/archives/82187\" target=\"_blank\" rel=\"noopener noreferrer\">https://mongoing.com/archives/82187</a></li>\n<li>Transactions - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/core/transactions/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/core/transactions/</a></li>\n<li>WiredTiger Storage Engine - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/core/wiredtiger/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/core/wiredtiger/</a></li>\n<li>WiredTiger 存储引擎之一：基础数据结构分析：<a href=\"https://mongoing.com/topic/archives-35143\" target=\"_blank\" rel=\"noopener noreferrer\">https://mongoing.com/topic/archives-35143</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/crud-annotated-document..png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（下）",
      "url": "https://javaguide.cn/database/mongodb/mongodb-questions-02.html",
      "id": "https://javaguide.cn/database/mongodb/mongodb-questions-02.html",
      "summary": "MongoDB 索引 MongoDB 索引有什么用? 和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 集合扫描 ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。 虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。",
      "content_html": "<h2> MongoDB 索引</h2>\n<h3> MongoDB 索引有什么用?</h3>\n<p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 <strong>集合扫描</strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。</p>\n<p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。</p>\n<h3> MongoDB 支持哪些类型的索引？</h3>\n<p><strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</strong></p>\n<ul>\n<li><strong>单字段索引：</strong> 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头/尾开始遍历。</li>\n<li><strong>复合索引：</strong> 建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>\n<li><strong>多键索引</strong>：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>\n<li><strong>哈希索引</strong>：按数据的哈希值索引，用在哈希分片集群上。</li>\n<li><strong>文本索引：</strong> 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>\n<li><strong>地理位置索引：</strong> 基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>\n<li><strong>唯一索引</strong>：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>\n<li><strong>TTL 索引</strong>：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。</li>\n<li>……</li>\n</ul>\n<h3> 复合索引中字段的顺序有影响吗？</h3>\n<p>复合索引中字段的顺序非常重要，例如下图中的复合索引由<code>{userid:1, score:-1}</code>组成，则该复合索引首先按照<code>userid</code>升序排序；然后再每个<code>userid</code>的值内，再按照<code>score</code>降序排序。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png\" alt=\"复合索引\" tabindex=\"0\"><figcaption>复合索引</figcaption></figure>\n<p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p>\n<p>走复合索引的排序：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不走复合索引的排序：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以通过 explain 进行分析：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 复合索引遵循左前缀原则吗？</h3>\n<p><strong>MongoDB 的复合索引遵循左前缀原则</strong>：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>{a: 1, b: 1, c: 1, ..., z: 1}</code> 这样的索引，那么实际上也等于有了 <code>{a: 1}</code>、<code>{a: 1, b: 1}</code>、<code>{a: 1, b: 1, c: 1}</code> 等一系列索引，但是不会有 <code>{b: 1}</code> 这样的非左前缀的索引。</p>\n<h3> 什么是 TTL 索引？</h3>\n<p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code> ，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>\n<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>\n<p><strong>TTL 索引运行原理</strong>：</p>\n<ul>\n<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值来判断文档是否过期，但不会保证已过期的数据会立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>\n<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的 oplog 来做同步。</li>\n</ul>\n<p><strong>TTL 索引限制</strong>：</p>\n<ul>\n<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>\n<li><code>_id</code>字段不支持 TTL 索引。</li>\n<li>无法在上限集合(Capped Collection)上创建 TTL 索引，因为 MongoDB 无法从上限集合中删除文档。</li>\n<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>\n</ul>\n<h3> 什么是覆盖索引查询？</h3>\n<p>根据官方文档介绍，覆盖查询是以下的查询：</p>\n<ul>\n<li>所有的查询字段是索引的一部分。</li>\n<li>结果中返回的所有字段都在同一索引中。</li>\n<li>查询中没有字段等于<code>null</code>。</li>\n</ul>\n<p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p>\n<p>举个例子：我们有如下 <code>users</code> 集合:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>现在，该索引会覆盖以下查询：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p>\n<h2> MongoDB 高可用</h2>\n<h3> 复制集群</h3>\n<h4> 什么是复制集群？</h4>\n<p>MongoDB 的复制集群又称为副本集群，是一组维护相同数据集合的 mongod 进程。</p>\n<p>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p>\n<p>通常来说，一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</p>\n<ul>\n<li><strong>主节点</strong>：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li>\n<li><strong>从节点</strong>：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li>\n<li><strong>仲裁节点</strong>：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li>\n</ul>\n<p>下图是一个典型的三成员副本集群：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-read-write-operations-primary.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>主节点与备节点之间是通过 <strong>oplog（操作日志）</strong> 来同步数据的。oplog 是 local 库下的一个特殊的 <strong>上限集合(Capped Collection)</strong> ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p>\n<blockquote>\n<p>上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/replica-set-primary-with-two-secondaries.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p>\n<p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p>\n<h4> 为什么要用复制集群？</h4>\n<ul>\n<li><strong>实现 failover</strong>：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li><strong>实现读写分离</strong>：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大,不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li>\n</ul>\n<h3> 分片集群</h3>\n<h4> 什么是分片集群？</h4>\n<p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p>\n<p>MongoDB 的分片集群由如下三个部分组成（下图来源于<a href=\"https://www.mongodb.com/docs/manual/sharding/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档对分片集群的介绍</a>）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/sharded-cluster-production-architecture.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ul>\n<li><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li>\n<li><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li>\n<li><strong>Shard</strong>：每个分片是整体数据的一部分子集，从 MongoDB3.6 版本开始，每个 Shard 必须部署为副本集（replica set）架构</li>\n</ul>\n<h4> 为什么要用分片集群？</h4>\n<p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p>\n<p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p>\n<p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 <strong>水平扩展</strong> 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p>\n<p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p>\n<ul>\n<li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li>\n<li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li>\n</ul>\n<h4> 什么是分片键？</h4>\n<p><strong>分片键（Shard Key）</strong> 是数据分区的前提， 从而实现数据分发到不同服务器上，减轻服务器的负担。也就是说，分片键决定了集合内的文档如何在集群的多个分片间的分布状况。</p>\n<p>分片键就是文档里面的一个字段，但是这个字段不是普通的字段，有一定的要求：</p>\n<ul>\n<li>它必须在所有文档中都出现。</li>\n<li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引，不能是多索引、文本索引或地理空间位置索引。</li>\n<li>MongoDB 4.2 之前的版本，文档的分片键字段值不可变。MongoDB 4.2 版本开始，除非分片键字段是不可变的 <code>_id</code> 字段，否则您可以更新文档的分片键值。MongoDB 5.0 版本开始，实现了实时重新分片（live resharding），可以实现分片键的完全重新选择。</li>\n<li>它的大小不能超过 512 字节。</li>\n</ul>\n<h4> 如何选择分片键？</h4>\n<p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自<a href=\"https://cloud.tencent.com/document/product/240/44611\" target=\"_blank\" rel=\"noopener noreferrer\">分片集群使用注意事项 - - 腾讯云文档</a>）：</p>\n<ul>\n<li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有 100 个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li>\n<li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li>\n<li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li>\n<li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li>\n</ul>\n<p>综上，在选择片键时要考虑以上 4 个条件，尽可能满足更多的条件，才能降低 MoveChunks 对性能的影响，从而获得最优的性能体验。</p>\n<h4> 分片策略有哪些？</h4>\n<p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自<a href=\"https://help.aliyun.com/document_detail/64561.html?spm=a2c4g.11186623.0.0.3121565eQhUGGB#h2--shard-key-3\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 分片集群介绍 - 阿里云文档</a>）：</p>\n<p><strong>1、基于范围的分片</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-scope-based-sharding.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p>\n<ul>\n<li>优点：Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li>\n<li>缺点：可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li>\n<li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li>\n</ul>\n<p><strong>2、基于 Hash 值的分片</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/example-of-hash-based-sharding.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p>\n<ul>\n<li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li>\n<li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li>\n<li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li>\n</ul>\n<p>除了上述两种分片策略，您还可以配置 <strong>复合片键</strong> ，例如由一个低基数的键和一个单调递增的键组成。</p>\n<h4> 分片数据如何存储？</h4>\n<p><strong>Chunk（块）</strong> 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中<strong>划分</strong>的概念。</p>\n<p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p>\n<p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/chunk-splitting-shard-a.png\" alt=\"Chunk 分裂\" tabindex=\"0\"><figcaption>Chunk 分裂</figcaption></figure>\n<p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器(Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p>\n<p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/mongodb/mongo-reblance-three-shards.png\" alt=\"Chunk 迁移\" tabindex=\"0\"><figcaption>Chunk 迁移</figcaption></figure>\n<blockquote>\n<p>Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上(自 MongoDB 3.4 版本起)的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p>\n</blockquote>\n<p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p>\n<p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p>\n<h4> Chunk 迁移原理是什么？</h4>\n<p>关于 Chunk 迁移原理的详细介绍，推荐阅读 MongoDB 中文社区的<a href=\"https://mongoing.com/archives/77479\" target=\"_blank\" rel=\"noopener noreferrer\">一文读懂 MongoDB chunk 迁移</a>这篇文章。</p>\n<h2> 学习资料推荐</h2>\n<ul>\n<li><a href=\"https://docs.mongoing.com/\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 中文手册|官方文档中文版</a>（推荐）：基于 4.2 版本，不断与官方最新版保持同步。</li>\n<li><a href=\"https://mongoing.com/archives/docs/mongodb%e5%88%9d%e5%ad%a6%e8%80%85%e6%95%99%e7%a8%8b/mongodb%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e9%9b%86%e5%90%88\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 初学者教程——7 天学习 MongoDB</a>：快速入门。</li>\n<li><a href=\"https://www.cnblogs.com/dxflqm/p/16643981.html\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot 整合 MongoDB 实战 - 2022</a>：很不错的一篇 MongoDB 入门文章，主要围绕 MongoDB 的 Java 客户端使用进行基本的增删改查操作介绍。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>MongoDB 官方文档（主要参考资料，以官方文档为准）：<a href=\"https://www.mongodb.com/docs/manual/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/</a></li>\n<li>《MongoDB 权威指南》</li>\n<li>Indexes - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/indexes/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/indexes/</a></li>\n<li>MongoDB - 索引知识 - 程序员翔仔 - 2022：<a href=\"https://fatedeity.cn/posts/database/mongodb-index-knowledge.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://fatedeity.cn/posts/database/mongodb-index-knowledge.html</a></li>\n<li>MongoDB - 索引: <a href=\"https://www.cnblogs.com/Neeo/articles/14325130.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/Neeo/articles/14325130.html</a></li>\n<li>Sharding - MongoDB 官方文档：<a href=\"https://www.mongodb.com/docs/manual/sharding/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/docs/manual/sharding/</a></li>\n<li>MongoDB 分片集群介绍 - 阿里云文档：<a href=\"https://help.aliyun.com/document_detail/64561.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://help.aliyun.com/document_detail/64561.html</a></li>\n<li>分片集群使用注意事项 - - 腾讯云文档：<a href=\"https://cloud.tencent.com/document/product/240/44611\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/document/product/240/44611</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "软件工程简明教程",
      "url": "https://javaguide.cn/system-design/basis/software-engineering.html",
      "id": "https://javaguide.cn/system-design/basis/software-engineering.html",
      "summary": "大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。 何为软件工程？ 1968 年 NATO（北大西洋公约组织）提出了软件危机（Software crisis）一词。同年，为了解决软件危机问题，“软件工程”的概念诞生了。一门叫做软件工程的学科也就应运而生。 随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！",
      "content_html": "<p>大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。</p>\n<h2> 何为软件工程？</h2>\n<p>1968 年 NATO（北大西洋公约组织）提出了<strong>软件危机</strong>（<strong>Software crisis</strong>）一词。同年，为了解决软件危机问题，“<strong>软件工程</strong>”的概念诞生了。一门叫做软件工程的学科也就应运而生。</p>\n<p>随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！</p>\n<p><strong>什么是软件危机呢？</strong></p>\n<p>简单来说，软件危机描述了当时软件开发的一个痛点：我们很难高效地开发出质量高的软件。</p>\n<p>Dijkstra（Dijkstra 算法的作者） 在 1972 年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。</p>\n<p><strong>说了这么多，到底什么是软件工程呢？</strong></p>\n<p>工程是为了解决实际的问题将理论应用于实践。软件工程指的就是将工程思想应用于软件开发。</p>\n<p>上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将系统化的、规范的、可量化的方法应用到软件的开发、运行及维护中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。</p>\n<p>总之，软件工程的终极目标就是：<strong>在更少资源消耗的情况下，创造出更好、更容易维护的软件。</strong></p>\n<h2> 软件开发过程</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科是这样定义软件开发过程</a>的：</p>\n<blockquote>\n<p>软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。</p>\n</blockquote>\n<ul>\n<li>需求分析：分析用户的需求，建立逻辑模型。</li>\n<li>软件设计：根据需求分析的结果对软件架构进行设计。</li>\n<li>编码：编写程序运行的源代码。</li>\n<li>测试 : 确定测试用例，编写测试报告。</li>\n<li>交付：将做好的软件交付给客户。</li>\n<li>维护：对软件进行维护比如解决 bug，完善功能。</li>\n</ul>\n<p>软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。</p>\n<p>软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。</p>\n<h2> 软件开发模型</h2>\n<p>软件开发模型有很多种，比如瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V 模型（V-model）、W 模型（W-model）、敏捷开发模型。其中最具有代表性的还是 <strong>瀑布模型</strong> 和 <strong>敏捷开发</strong> 。</p>\n<p><strong>瀑布模型</strong> 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/schedule-task/up-264f2750a3d30366e36c375ec3a30ec2775.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>敏捷开发模型</strong> 是目前使用的最多的一种软件开发模型。<a href=\"https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91\" target=\"_blank\" rel=\"noopener noreferrer\">MBA 智库百科对敏捷开发的描述</a>是这样的:</p>\n<blockquote>\n<p><strong>敏捷开发</strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>\n</blockquote>\n<p>像现在比较常见的一些概念比如 <strong>持续集成</strong>、<strong>重构</strong>、<strong>小版本发布</strong>、<strong>低文档</strong>、<strong>站会</strong>、<strong>结对编程</strong>、<strong>测试驱动开发</strong> 都是敏捷开发的核心。</p>\n<h2> 软件开发的基本策略</h2>\n<h3> 软件复用</h3>\n<p>我们在构建一个新的软件的时候，不需要从零开始，通过复用已有的一些轮子（框架、第三方库等）、设计模式、设计原则等等现成的物料，我们可以更快地构建出一个满足要求的软件。</p>\n<p>像我们平时接触的开源项目就是最好的例子。我想，如果不是开源，我们构建出一个满足要求的软件，耗费的精力和时间要比现在多的多！</p>\n<h3> 分而治之</h3>\n<p>构建软件的过程中，我们会遇到很多问题。我们可以将一些比较复杂的问题拆解为一些小问题，然后，一一攻克。</p>\n<p>我结合现在比较火的软件设计方法—领域驱动设计（Domain Driven Design，简称 DDD）来说说。</p>\n<p>在领域驱动设计中，很重要的一个概念就是<strong>领域（Domain）</strong>，它就是我们要解决的问题。在领域驱动设计中，我们要做的就是把比较大的领域（问题）拆解为若干的小领域（子域）。</p>\n<p>除此之外，分而治之也是一个比较常用的算法思想，对应的就是分治算法。如果你想了解分治算法的话，推荐你看一下北大的<a href=\"https://www.coursera.org/learn/algorithms\" target=\"_blank\" rel=\"noopener noreferrer\">《算法设计与分析 Design and Analysis of Algorithms》</a>。</p>\n<h3> 逐步演进</h3>\n<p>软件开发是一个逐步演进的过程，我们需要不断进行迭代式增量开发，最终交付符合客户价值的产品。</p>\n<p>这里补充一个在软件开发领域，非常重要的概念：<strong>MVP（Minimum Viable Product，最小可行产品</strong>）。</p>\n<p>这个最小可行产品，可以理解为刚好能够满足客户需求的产品。下面这张图片把这个思想展示的非常精髓。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/schedule-task/up-a99961ff7725106c0592abca845d555568a.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>利用最小可行产品，我们可以也可以提早进行市场分析，这对于我们在探索产品不确定性的道路上非常有帮助。可以非常有效地指导我们下一步该往哪里走。</p>\n<h3> 优化折中</h3>\n<p>软件开发是一个不断优化改进的过程。任何软件都有很多可以优化的点，不可能完美。我们需要不断改进和提升软件的质量。</p>\n<p>但是，也不要陷入这个怪圈。要学会折中，在有限的投入内，以最有效的方式提高现有软件的质量。</p>\n<h2> 参考</h2>\n<ul>\n<li>软件工程的基本概念-清华大学软件学院 刘强：<a href=\"https://www.xuetangx.com/course/THU08091000367\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.xuetangx.com/course/THU08091000367</a></li>\n<li>软件开发过程-维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/软件开发过程</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/schedule-task/up-264f2750a3d30366e36c375ec3a30ec2775.png",
      "date_published": "2022-12-30T05:45:11.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Maven核心概念总结",
      "url": "https://javaguide.cn/tools/maven/maven-core-concepts.html",
      "id": "https://javaguide.cn/tools/maven/maven-core-concepts.html",
      "summary": "这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。 Maven 介绍 Maven 官方文档是这样介绍的 Maven 的： Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. Apache Maven 的本质是一个软件项目管理和理解工具。基于项目对象模型 (Project Object Model，POM) 的概念，Maven 可以从一条中心信息管理项目的构建、报告和文档。",
      "content_html": "<blockquote>\n<p>这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。</p>\n</blockquote>\n<h2> Maven 介绍</h2>\n<p><a href=\"https://github.com/apache/maven\" target=\"_blank\" rel=\"noopener noreferrer\">Maven</a> 官方文档是这样介绍的 Maven 的：</p>\n<blockquote>\n<p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.</p>\n<p>Apache Maven 的本质是一个软件项目管理和理解工具。基于项目对象模型 (Project Object Model，POM) 的概念，Maven 可以从一条中心信息管理项目的构建、报告和文档。</p>\n</blockquote>\n<p><strong>什么是 POM？</strong> 每一个 Maven 工程都有一个 <code>pom.xml</code> 文件，位于根目录中，包含项目构建生命周期的详细信息。通过 <code>pom.xml</code> 文件，我们可以定义项目的坐标、项目依赖、项目信息、插件信息等等配置。</p>\n<p>对于开发者来说，Maven 的主要作用主要有 3 个：</p>\n<ol>\n<li><strong>项目构建</strong>：提供标准的、跨平台的自动化项目构建方式。</li>\n<li><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li>\n<li><strong>统一开发结构</strong>：提供标准的、统一的项目结构。</li>\n</ol>\n<p>关于 Maven 的基本使用这里就不介绍了，建议看看官网的 5 分钟上手 Maven 的教程：<a href=\"https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html\" target=\"_blank\" rel=\"noopener noreferrer\">Maven in 5 Minutes</a> 。</p>\n<h2> Maven 坐标</h2>\n<p>项目中依赖的第三方库以及插件可统称为构件。每一个构件都可以使用 Maven 坐标唯一标识，坐标元素包括：</p>\n<ul>\n<li><strong>groupId</strong>(必须): 定义了当前 Maven 项目隶属的组织或公司。groupId 一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，artifactId 是 tomcat。</li>\n<li><strong>artifactId</strong>(必须)：定义了当前 Maven 项目的名称，项目的唯一的标识符，对应项目根目录的名称。</li>\n<li><strong>version</strong>(必须)：定义了 Maven 项目当前所处版本。</li>\n<li><strong>packaging</strong>（可选）：定义了 Maven 项目的打包方式（比如 jar，war...），默认使用 jar。</li>\n<li><strong>classifier</strong>(可选)：常用于区分从同一 POM 构建的具有不同内容的构件，可以是任意的字符串，附加在版本号之后。</li>\n</ul>\n<p>只要你提供正确的坐标，就能从 Maven 仓库中找到相应的构件供我们使用。</p>\n<p>举个例子（引入阿里巴巴开源的 EasyExcel）：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以在 <a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://mvnrepository.com/</a> 这个网站上找到几乎所有可用的构件，如果你的项目使用的是 Maven 作为构建工具，那这个网站你一定会经常接触。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/tools/maven/mvnrepository.com.png\" alt=\"Maven 仓库\" tabindex=\"0\"><figcaption>Maven 仓库</figcaption></figure>\n<h2> Maven 依赖</h2>\n<p>如果使用 Maven 构建产生的构件（例如 Jar 文件）被其他的项目引用，那么该构件就是其他项目的依赖。</p>\n<h3> 依赖配置</h3>\n<p><strong>配置信息示例</strong>：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>配置说明</strong>：</p>\n<ul>\n<li>dependencies：一个 pom.xml 文件中只能存在一个这样的标签，是用来管理依赖的总标签。</li>\n<li>dependency：包含在 dependencies 标签中，可以有多个，每一个表示项目的一个依赖。</li>\n<li>groupId,artifactId,version(必要)：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。我们在上面解释过这些元素的具体意思，这里就不重复提了。</li>\n<li>type(可选)：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。</li>\n<li>scope(可选)：依赖的范围，默认值是 compile。</li>\n<li>optional(可选)：标记依赖是否可选</li>\n<li>exclusions(可选)：用来排除传递性依赖,例如 jar 包冲突</li>\n</ul>\n<h3> 依赖范围</h3>\n<p><strong>classpath</strong> 用于指定 <code>.class</code> 文件存放的位置，类加载器会从该路径中加载所需的 <code>.class</code> 文件到内存中。</p>\n<p>Maven 在编译、执行测试、实际运行有着三套不同的 classpath：</p>\n<ul>\n<li><strong>编译 classpath</strong>：编译主代码有效</li>\n<li><strong>测试 classpath</strong>：编译、运行测试代码有效</li>\n<li><strong>运行 classpath</strong>：项目运行时有效</li>\n</ul>\n<p>Maven 的依赖范围如下：</p>\n<ul>\n<li><strong>compile</strong>：编译依赖范围（默认），使用此依赖范围对于编译、测试、运行三种都有效，即在编译、测试和运行的时候都要使用该依赖 Jar 包。</li>\n<li><strong>test</strong>：测试依赖范围，从字面意思就可以知道此依赖范围只能用于测试，而在编译和运行项目时无法使用此类依赖，典型的是 JUnit，它只用于编译测试代码和运行测试代码的时候才需要。</li>\n<li><strong>provided</strong>：此依赖范围，对于编译和测试有效，而对运行时无效。比如 <code>servlet-api.jar</code> 在 Tomcat 中已经提供了，我们只需要的是编译期提供而已。</li>\n<li><strong>runtime</strong>：运行时依赖范围，对于测试和运行有效，但是在编译主代码时无效，典型的就是 JDBC 驱动实现。</li>\n<li><strong>system</strong>：系统依赖范围，使用 system 范围的依赖时必须通过 systemPath 元素显示地指定依赖文件的路径，不依赖 Maven 仓库解析，所以可能会造成建构的不可移植。</li>\n</ul>\n<h3> 传递依赖性</h3>\n<h3> 依赖冲突</h3>\n<p><strong>1、对于 Maven 而言，同一个 groupId 同一个 artifactId 下，只能使用一个 version。</strong></p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>若相同类型但版本不同的依赖存在于同一个 pom 文件，只会引入后一个声明的依赖。</p>\n<p><strong>2、项目的两个依赖同时引入了某个依赖。</strong></p>\n<p>举个例子，项目存在下面这样的依赖关系：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这两条依赖路径上有两个版本的 X，为了避免依赖重复，Maven 只会选择其中的一个进行解析。</p>\n<p><strong>哪个版本的 X 会被 Maven 解析使用呢?</strong></p>\n<p>Maven 在遇到这种问题的时候，会遵循 <strong>路径最短优先</strong> 和 <strong>声明顺序优先</strong> 两大原则。解决这个问题的过程也被称为 <strong>Maven 依赖调解</strong> 。</p>\n<p><strong>路径最短优先</strong></p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>依赖链路二的路径最短，因此，X(2.0)会被解析使用。</p>\n<p>不过，你也可以发现。路径最短优先原则并不是通用的，像下面这种路径长度相等的情况就不能单单通过其解决了：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，Maven 又定义了声明顺序优先原则。</p>\n<p>依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A-&gt;B-&gt;Y(1.0)、A-&gt; C-&gt;Y(2.0)，Y(1.0)和 Y(2.0)的依赖路径长度是一样的，都为 2。Maven 定义了依赖调解的第二原则：</p>\n<p><strong>声明顺序优先</strong></p>\n<p>在依赖路径长度相等的前提下，在 <code>pom.xml</code> 中依赖声明的顺序决定了谁会被解析使用，顺序最前的那个依赖优胜。该例中，如果 B 的依赖声明在 D 之前，那么 X (1.0)就会被解析使用。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 排除依赖</h3>\n<p>单纯依赖 Maven 来进行依赖调解，在很多情况下是不适用的，需要我们手动排除依赖。</p>\n<p>举个例子，当前项目存在下面这样的依赖关系：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据路径最短优先原则，X(1.0) 会被解析使用，也就是说实际用的是 1.0 版本的 X。</p>\n<p>但是！！！这会一些问题：如果 D 依赖用到了 1.5 版本的 X 中才有的一个类，运行项目就会报<code>NoClassDefFoundError</code>错误。如果 D 依赖用到了 1.5 版本的 X 中才有的一个方法，运行项目就会报<code>NoSuchMethodError</code>错误。</p>\n<p>现在知道为什么你的 Maven 项目总是会报<code>NoClassDefFoundError</code>和<code>NoSuchMethodError</code>错误了吧？</p>\n<p><strong>如何解决呢？</strong> 我们可以通过<code>exclusion</code>标签手动将 X(1.0) 给排除。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一般我们在解决依赖冲突的时候，都会优先保留版本较高的。这是因为大部分 jar 在升级的时候都会做到向下兼容。</p>\n<p>如果高版本修改了低版本的一些类或者方法的话，这个时候就能直接保留高版本了，而是应该考虑优化上层依赖，比如升级上层依赖的版本。</p>\n<p>还是上面的例子：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们保留了 1.5 版本的 X，但是这个版本的 X 删除了 1.0 版本中的某些类。这个时候，我们可以考虑升级 D 的版本到一个 X 兼容的版本。</p>\n<h2> Maven 仓库</h2>\n<p>在 Maven 世界中，任何一个依赖、插件或者项目构建的输出，都可以称为 <strong>构件</strong> 。</p>\n<p>坐标和依赖是构件在 Maven 世界中的逻辑表示方式，构件的物理表示方式是文件，Maven 通过仓库来统一管理这些文件。 任何一个构件都有一组坐标唯一标识。有了仓库之后，无需手动引入构件，我们直接给定构件的坐标即可在 Maven 仓库中找到该构件。</p>\n<p>Maven 仓库分为：</p>\n<ul>\n<li><strong>本地仓库</strong>：运行 Maven 的计算机上的一个目录，它缓存远程下载的构件并包含尚未发布的临时构件。<code>settings.xml</code> 文件中可以看到 Maven 的本地仓库路径配置，默认本地仓库路径是在 <code>${user.home}/.m2/repository</code>。</li>\n<li><strong>远程仓库</strong>：官方或者其他组织维护的 Maven 仓库。</li>\n</ul>\n<p>Maven 远程仓库可以分为：</p>\n<ul>\n<li><strong>中央仓库</strong>：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a href=\"https://search.maven.org/\" target=\"_blank\" rel=\"noopener noreferrer\">查询地址</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</li>\n<li><strong>私服</strong>：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</li>\n<li><strong>其他的公共仓库</strong>：有一些公共仓库是为了加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</li>\n</ul>\n<p>Maven 依赖包寻找顺序：</p>\n<ol>\n<li>先去本地仓库找寻，有的话，直接使用。</li>\n<li>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</li>\n<li>远程仓库没有找到的话，会报错。</li>\n</ol>\n<h2> Maven 生命周期</h2>\n<p>Maven 的生命周期就是为了对所有的构建过程进行抽象和统一，包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。</p>\n<p>Maven 定义了 3 个生命周期<code>META-INF/plexus/components.xml</code>：</p>\n<ul>\n<li><code>default</code> 生命周期</li>\n<li><code>clean</code>生命周期</li>\n<li><code>site</code>生命周期</li>\n</ul>\n<p>这些生命周期是相互独立的，每个生命周期包含多个阶段(phase)。并且，这些阶段是有序的，也就是说，后面的阶段依赖于前面的阶段。当执行某个阶段的时候，会先执行它前面的阶段。</p>\n<p>执行 Maven 生命周期的命令格式如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> default 生命周期</h3>\n<p><code>default</code>生命周期是在没有任何关联插件的情况下定义的，是 Maven 的主要生命周期，用于构建应用程序，共包含 23 个阶段。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn test</code>命令的时候，会执行从 validate 到 test 的所有阶段，这也就解释了为什么执行测试的时候，项目的代码能够自动编译。</p>\n<h3> clean 生命周期</h3>\n<p>clean 生命周期的目的是清理项目，共包含 3 个阶段：</p>\n<ol>\n<li>pre-clean</li>\n<li>clean</li>\n<li>post-clean</li>\n</ol>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn clean</code> 的时候，会执行 clean 生命周期中的 pre-clean 和 clean 阶段。</p>\n<h3> site 生命周期</h3>\n<p>site 生命周期的目的是建立和发布项目站点，共包含 4 个阶段：</p>\n<ol>\n<li>pre-site</li>\n<li>site</li>\n<li>post-site</li>\n<li>site-deploy</li>\n</ol>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Maven 能够基于 <code>pom.xml</code> 所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。</p>\n<h2> Maven 插件</h2>\n<p>Maven 本质上是一个插件执行框架，所有的执行过程，都是由一个一个插件独立完成的。像咱们日常使用到的 install、clean、deploy 等命令，其实底层都是一个一个的 Maven 插件。关于 Maven 的核心插件可以参考官方的这篇文档：<a href=\"https://maven.apache.org/plugins/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://maven.apache.org/plugins/index.html</a> 。</p>\n<p>本地默认插件路径: <code>${user.home}/.m2/repository/org/apache/maven/plugins</code></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/tools/maven/maven-plugins.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>除了 Maven 自带的插件之外，还有一些三方提供的插件比如单测覆盖率插件 jacoco-maven-plugin、帮助开发检测代码中不合规范的地方的插件 maven-checkstyle-plugin、分析代码质量的 sonar-maven-plugin。并且，我们还可以自定义插件来满足自己的需求。</p>\n<p>jacoco-maven-plugin 使用示例：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以将 Maven 插件理解为一组任务的集合，用户可以通过命令行直接运行指定插件的任务，也可以将插件任务挂载到构建生命周期，随着生命周期运行。</p>\n<p>Maven 插件被分为下面两种类型：</p>\n<ul>\n<li><strong>Build plugins</strong>：在构建时执行。</li>\n<li><strong>Reporting plugins</strong>：在网站生成过程中执行。</li>\n</ul>\n<h2> Maven 多模块管理</h2>\n<p>多模块管理简单地来说就是将一个项目分为多个模块，每个模块只负责单一的功能实现。直观的表现就是一个 Maven 项目中不止有一个 <code>pom.xml</code> 文件，会在不同的目录中有多个 <code>pom.xml</code> 文件，进而实现多模块管理。</p>\n<p>多模块管理除了可以更加便于项目开发和管理，还有如下好处：</p>\n<ol>\n<li>降低代码之间的耦合性（从类级别的耦合提升到 jar 包级别的耦合）；</li>\n<li>减少重复，提升复用性；</li>\n<li>每个模块都可以是自解释的（通过模块名或者模块文档）；</li>\n<li>模块还规范了代码边界的划分，开发者很容易通过模块确定自己所负责的内容。</li>\n</ol>\n<p>多模块管理下，会有一个父模块，其他的都是子模块。父模块通常只有一个 <code>pom.xml</code>，没有其他内容。父模块的 <code>pom.xml</code> 一般只定义了各个依赖的版本号、包含哪些子模块以及插件有哪些。不过，要注意的是，如果依赖只在某个子项目中使用，则可以在子项目的 pom.xml 中直接引入，防止父 pom 的过于臃肿。</p>\n<p>如下图所示，Dubbo 项目就被分成了多个子模块比如 dubbo-common（公共逻辑模块）、dubbo-remoting（远程通讯模块）、dubbo-rpc（远程调用模块）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/tools/maven/dubbo-maven-multi-module.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 文章推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/flniMiP-eu3JSBnswfd_Ew\" target=\"_blank\" rel=\"noopener noreferrer\">安全同学讲 Maven 间接依赖场景的仲裁机制 - 阿里开发者 - 2022</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Wvq7t2FC58jaCh4UFJ6GGQ\" target=\"_blank\" rel=\"noopener noreferrer\">高效使用 Java 构建工具｜ Maven 篇 - 阿里开发者 - 2022</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/xsJkB0onUkakrVH0wejcIg\" target=\"_blank\" rel=\"noopener noreferrer\">安全同学讲 Maven 重打包的故事 - 阿里开发者 - 2022</a></li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Maven 实战》</li>\n<li>Introduction to Repositories - Maven 官方文档：<a href=\"https://maven.apache.org/guides/introduction/introduction-to-repositories.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://maven.apache.org/guides/introduction/introduction-to-repositories.html</a></li>\n<li>Introduction to the Build Lifecycle - Maven 官方文档：<a href=\"https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference\" target=\"_blank\" rel=\"noopener noreferrer\">https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference</a></li>\n<li>Maven 依赖范围：<a href=\"http://www.mvnbook.com/maven-dependency.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.mvnbook.com/maven-dependency.html</a></li>\n<li>解决 maven 依赖冲突，这篇就够了！：<a href=\"https://www.cnblogs.com/qdhxhz/p/16363532.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/qdhxhz/p/16363532.html</a></li>\n<li>Multi-Module Project with Maven：<a href=\"https://www.baeldung.com/maven-multi-module\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.baeldung.com/maven-multi-module</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/tools/maven/mvnrepository.com.png",
      "date_published": "2022-12-16T14:32:28.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "开发工具"
      ]
    },
    {
      "title": "分布式配置中心常见问题总结(付费)",
      "url": "https://javaguide.cn/distributed-system/distributed-configuration-center.html",
      "id": "https://javaguide.cn/distributed-system/distributed-configuration-center.html",
      "summary": "分布式配置中心 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>分布式配置中心</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/distributed-system.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220304102536445.png\" alt=\"《Java 面试指北》内容概览\" tabindex=\"0\"><figcaption>《Java 面试指北》内容概览</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/distributed-system.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "常见SQL优化手段总结（付费）",
      "url": "https://javaguide.cn/high-performance/sql-optimization.html",
      "id": "https://javaguide.cn/high-performance/sql-optimization.html",
      "summary": "常见 SQL 优化手段总结 相关的内容为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>常见 SQL 优化手段总结</strong> 相关的内容为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/sql-optimization.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/image-20220304102536445.png\" alt=\"《Java 面试指北》内容概览\" tabindex=\"0\"><figcaption>《Java 面试指北》内容概览</figcaption></figure>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>\n<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiufuwu.png\" alt=\"星球服务\" tabindex=\"0\"></a><figcaption>星球服务</figcaption></figure>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 知识星球详细介绍</a> 。</p>\n<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg\" alt=\"知识星球30元优惠卷\" tabindex=\"0\"><figcaption>知识星球30元优惠卷</figcaption></figure>\n<p>进入星球之后，记得查看 <strong><a href=\"https://t.zsxq.com/0d18KSarv\" target=\"_blank\" rel=\"noopener noreferrer\">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href=\"https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1\" target=\"_blank\" rel=\"noopener noreferrer\">星球优质主题汇总</a></strong> 。另外，建议你添加一下我的个人微信（ <strong>javaguide1024</strong> ，备注 <strong>“星球”</strong> ，生活号，球友专属），方便后续交流沟通。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/weixin-guidege666.jpeg\" alt=\"个人微信\" tabindex=\"0\"><figcaption>个人微信</figcaption></figure>\n<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>\n<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/sql-optimization.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "项目经验指南",
      "url": "https://javaguide.cn/interview-preparation/project-experience-guide.html",
      "id": "https://javaguide.cn/interview-preparation/project-experience-guide.html",
      "summary": "友情提示 本文节选自 《Java 面试指北》。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。 没有项目经验怎么办? 没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">友情提示</p>\n<p>本文节选自 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。</p>\n</div>\n<h2> 没有项目经验怎么办?</h2>\n<p>没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。</p>\n<p>说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。</p>\n<h3> 实战项目视频/专栏</h3>\n<p>在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。</p>\n<p>你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/mukewangzhiazhanke.png\" alt=\"慕课网实战课\" tabindex=\"0\"><figcaption>慕课网实战课</figcaption></figure>\n<p>尽量选择一个适合自己的项目，没必要必须做分布式/微服务项目，对于绝大部分同学来说，能把一个单机项目做好就已经很不错了。</p>\n<p>我面试过很多求职者，简历上看着有微服务的项目经验，结果随便问两个问题就知道根本不是自己做的或者说做的时候压根没认真思考。这种情况会给我留下非常不好的印象。</p>\n<p>我在 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的「面试准备篇」中也说过：</p>\n<blockquote>\n<p>个人认为也没必要非要去做微服务或者分布式项目，不一定对你面试有利。微服务或者分布式项目涉及的知识点太多，一般人很难吃透。并且，这类项目其实对于校招生来说稍微有一点超标了。即使你做出来，很多面试官也会认为不是你独立完成的。</p>\n<p>其实，你能把一个单体项目做到极致也很好，对于个人能力提升不比做微服务或者分布式项目差。如何做到极致？代码质量这里就不提了，更重要的是你要尽量让自己的项目有一些亮点（比如你是如何提升项目性能的、如何解决项目中存在的一个痛点的），项目经历取得的成果尽量要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。</p>\n</blockquote>\n<p>跟着老师做的过程中，你一定要有自己的思考，不要浅尝辄止。对于很多知识点，别人的讲解可能只是满足项目就够了，你自己想多点知识的话，对于重要的知识点就要自己学会去深入学习。</p>\n<h3> 实战类开源项目</h3>\n<p>GitHub 或者码云上面有很多实战类别项目，你可以选择一个来研究，为了让自己对这个项目更加理解，在理解原有代码的基础上，你可以对原有项目进行改进或者增加功能。</p>\n<p>你可以参考 <a href=\"https://javaguide.cn/open-source-project/practical-project.html\" title=\"Java 优质开源实战项目\" target=\"_blank\" rel=\"noopener noreferrer\">Java 优质开源实战项目</a> 上面推荐的实战类开源项目，质量都很高，项目类型也比较全面，涵盖博客/论坛系统、考试/刷题系统、商城系统、权限管理系统、快速开发脚手架以及各种轮子。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/javaguide-practical-project.png\" alt=\"Java 优质开源实战项目\" tabindex=\"0\"><figcaption>Java 优质开源实战项目</figcaption></figure>\n<p>一定要记住：<strong>不光要做，还要改进，改善。不论是实战项目视频或者专栏还是实战类开源项目，都一定会有很多可以完善改进的地方。</strong></p>\n<h3> 从头开始做</h3>\n<p>自己动手去做一个自己想完成的东西，遇到不会的东西就临时去学，现学现卖。</p>\n<p>这个要求比较高，我建议你已经有了一个项目经验之后，再采用这个方法。如果你没有做过项目的话，还是老老实实采用上面两个方法比较好。</p>\n<h3> 参加各种大公司组织的各种大赛</h3>\n<p>如果参加这种赛事能获奖的话，项目含金量非常高。即使没获奖也没啥，也可以写简历上。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/up-673f598477242691900a1e72c5d8b26df2c.png\" alt=\"阿里云天池大赛\" tabindex=\"0\"><figcaption>阿里云天池大赛</figcaption></figure>\n<h3> 参与实际项目</h3>\n<p>通常情况下，你有如下途径接触到企业实际项目的开发：</p>\n<ol>\n<li>老师接的项目；</li>\n<li>自己接的私活；</li>\n<li>实习/工作接触到的项目；</li>\n</ol>\n<p>老师接的项目和自己接的私活通常都是一些偏业务的项目，很少会涉及到性能优化。这种情况下，你可以考虑对项目进行改进，别怕花时间，某个时间用心做好一件事情就好比如你对项目的数据模型进行改进、引入缓存提高访问速度等等。</p>\n<p>实习/工作接触到的项目类似，如果遇到一些偏业务的项目，也是要自己私下对项目进行改进优化。</p>\n<p>尽量是真的对项目进行了优化，这本身也是对个人能力的提升。如果你实在是没时间去实践的话，也没关系，吃透这个项目优化手段就好，把一些面试可能会遇到的问题提前准备一下。</p>\n<h2> 有没有还不错的项目推荐？</h2>\n<p><strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的「面试准备篇」中有一篇文章专门整理了一些比较高质量的实战项目，非常适合用来学习或者作为项目经验。</p>\n<figure><img src=\"https://oss.javaguide.cn/javamianshizhibei/project-experience-guide.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这篇文章一共推荐了 15+ 个实战项目，有业务类的，也有轮子类的，有开源项目、也有视频教程。对于参加校招的小伙伴，我更建议做一个业务类项目加上一个轮子类的项目。</p>\n<h2> 我跟着视频做的项目会被面试官嫌弃不？</h2>\n<p>很多应届生都是跟着视频做的项目，这个大部分面试官都心知肚明。</p>\n<p>不排除确实有些面试官不吃这一套，这个也看人。不过我相信大多数面试官都是能理解的，毕竟你在学校的时候实际上是没有什么获得实际项目经验的途径的。</p>\n<p>大部分应届生的项目经验都是自己在网上找的或者像你一样买的付费课程跟着做的，极少部分是比较真实的项目。 从你能想着做一个实战项目来说，我觉得初衷是好的，确实也能真正学到东西。 但是，究竟有多少是自己掌握了很重要。看视频最忌讳的是被动接受，自己多改进一下，多思考一下！就算是你跟着视频做的项目，也是可以优化的！</p>\n<p><strong>如果你想真正学到东西的话，建议不光要把项目单纯完成跑起来，还要去自己尝试着优化！</strong></p>\n<p>简单说几个比较容易的优化点：</p>\n<ol>\n<li><strong>全局异常处理</strong>：很多项目这方面都做的不是很好，可以参考我的这篇文章：<a href=\"https://mp.weixin.qq.com/s/Y4Q4yWRqKG_lw0GLUsY2qw\" target=\"_blank\" rel=\"noopener noreferrer\">《使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！》</a> 来做优化。</li>\n<li><strong>项目的技术选型优化</strong>：比如使用 Guava 做本地缓存的地方可以换成 <strong>Caffeine</strong> 。Caffeine 的各方面的表现要更加好！再比如 Controller 层是否放了太多的业务逻辑。</li>\n<li><strong>数据库方面</strong>：数据库设计可否优化？索引是否使用使用正确？SQL 语句是否可以优化？是否需要进行读写分离？</li>\n<li><strong>缓存</strong>：项目有没有哪些数据是经常被访问的？是否引入缓存来提高响应速度？</li>\n<li><strong>安全</strong>：项目是否存在安全问题？</li>\n<li>……</li>\n</ol>\n<p>另外，我在星球分享过常见的性能优化方向实践案例，涉及到多线程、异步、索引、缓存等方向，强烈推荐你看看：<a href=\"https://t.zsxq.com/06EqfeMZZ\" target=\"_blank\" rel=\"noopener noreferrer\">https://t.zsxq.com/06EqfeMZZ</a> 。</p>\n<p>最后，<strong>再给大家推荐一个 IDEA 优化代码的小技巧，超级实用！</strong></p>\n<p>分析你的代码：右键项目-&gt; Analyze-&gt;Inspect Code</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/up-651672bce128025a135c1536cd5dc00532e.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>扫描完成之后，IDEA 会给出一些可能存在的代码坏味道比如命名问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/up-05c83b319941995b07c8020fddc57f26037.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>并且，你还可以自定义检查规则。</p>\n<figure><img src=\"https://oss.javaguide.cn/xingqiu/up-6b618ad3bad0bc3f76e6066d90c8cd2f255.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/javamianshizhibei/mukewangzhiazhanke.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2023-10-10T03:03:34.000Z",
      "authors": [],
      "tags": [
        "面试准备"
      ]
    },
    {
      "title": "Java 17 新特性概览（重要）",
      "url": "https://javaguide.cn/java/new-features/java17.html",
      "id": "https://javaguide.cn/java/new-features/java17.html",
      "summary": "Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。 下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java 17 最多可以支持到 2029 年 9 月份。",
      "content_html": "<p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。</p>\n<p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java</p>\n<p>17 最多可以支持到 2029 年 9 月份。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。</p>\n<p>这次更新共带来 14 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/jeps/306\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/356\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/382\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/391\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/398\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/403\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/406\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 406:Pattern Matching for switch (switch 的类型匹配)</a>（预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/407\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/409\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 409:Sealed Classes（密封类）</a>（转正）</li>\n<li><a href=\"https://openjdk.java.net/jeps/410\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/411\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412:Foreign Function &amp; Memory API (外部函数和内存 API)</a>（孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414:Vector（向量） API</a>（第二次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/415\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 415:Context-Specific Deserialization Filters</a></li>\n</ul>\n<p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：<a href=\"https://openjdk.java.net/projects/jdk/17/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 17 文档</a> 。</p>\n<h2> JEP 356:增强的伪随机数生成器</h2>\n<p>JDK 17 之前，我们可以借助 <code>Random</code>、<code>ThreadLocalRandom</code>和<code>SplittableRandom</code>来生成随机数。不过，这 3 个类都各有缺陷，且缺少常见的伪随机算法支持。</p>\n<p>Java 17 为伪随机数生成器 （pseudorandom number generator，PRNG，又称为确定性随机位生成器）增加了新的接口类型和实现，使得开发者更容易在应用程序中互换使用各种 PRNG 算法。</p>\n<blockquote>\n<p><a href=\"https://ctf-wiki.org/crypto/streamcipher/prng/intro/\" target=\"_blank\" rel=\"noopener noreferrer\">PRNG</a> 用来生成接近于绝对随机数序列的数字序列。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>\n</blockquote>\n<p>使用示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 398:弃用 Applet API 以进行删除</h2>\n<p>Applet API 用于编写在 Web 浏览器端运行的 Java 小程序，很多年前就已经被淘汰了，已经没有理由使用了。</p>\n<p>Applet API 在 Java 9 时被标记弃用（<a href=\"https://openjdk.java.net/jeps/289\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 289</a>），但不是为了删除。</p>\n<h2> JEP 406:switch 的类型匹配（预览）</h2>\n<p>正如 <code>instanceof</code> 一样， <code>switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>\n<p><code>instanceof</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>switch</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于 <code>null</code> 值的判断也进行了优化。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 407:删除远程方法调用激活机制</h2>\n<p>删除远程方法调用 (RMI) 激活机制，同时保留 RMI 的其余部分。RMI 激活机制已过时且不再使用。</p>\n<h2> JEP 409:密封类（转正）</h2>\n<p>密封类由 <a href=\"https://openjdk.java.net/jeps/360\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href=\"https://openjdk.java.net/jeps/397\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 397</a> 提出了再次预览。</p>\n<p>在 <a href=\"/java/new-features/java14-15.html\" target=\"blank\">Java 14 &amp; 15 新特性概览</a> 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>\n<h2> JEP 410:删除实验性的 AOT 和 JIT 编译器</h2>\n<p>在 Java 9 的 <a href=\"https://openjdk.java.net/jeps/295\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 295</a> ,引入了实验性的提前 (AOT) 编译器，在启动虚拟机之前将 Java 类编译为本机代码。</p>\n<p>Java 17，删除实验性的提前 (AOT) 和即时 (JIT) 编译器，因为该编译器自推出以来很少使用，维护它所需的工作量很大。保留实验性的 Java 级 JVM 编译器接口 (JVMCI)，以便开发人员可以继续使用外部构建的编译器版本进行 JIT 编译。</p>\n<h2> JEP 411:弃用安全管理器以进行删除</h2>\n<p>弃用安全管理器以便在将来的版本中删除。</p>\n<p>安全管理器可追溯到 Java 1.0，多年来，它一直不是保护客户端 Java 代码的主要方法，也很少用于保护服务器端代码。为了推动 Java 向前发展，Java 17 弃用安全管理器，以便与旧版 Applet API ( <a href=\"https://openjdk.java.net/jeps/398\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 398</a> ) 一起移除。</p>\n<h2> JEP 412:外部函数和内存 API（孵化）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在 <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 414:向量 API（第二次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>\n<p>在 <a href=\"/java/new-features/java18.html\" target=\"blank\">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png",
      "date_published": "2022-09-28T12:35:46.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 18 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java18.html",
      "id": "https://javaguide.cn/java/new-features/java18.html",
      "summary": "Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。 Java 18 带来了 9 个新特性： JEP 400:UTF-8 by Default（默认字符集为 UTF-8） JEP 408:Simple Web Server（简易的 Web 服务器） JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段） JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心） JEP 417:Vector（向量） API（第三次孵化） JEP 418:Internet-Address Resolution（互联网地址解析）SPI JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）（第二次孵化） JEP 420:Pattern Matching for switch（switch 模式匹配）（第二次预览） JEP 421:Deprecate Finalization for Removal",
      "content_html": "<p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。</p>\n<p>Java 18 带来了 9 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/jeps/400\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/408\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 408:Simple Web Server（简易的 Web 服务器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/413\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/416\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417:Vector（向量） API</a>（第三次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/418\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 418:Internet-Address Resolution（互联网地址解析）SPI</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/420\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 420:Pattern Matching for switch（switch 模式匹配）</a>（第二次预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/421\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 421:Deprecate Finalization for Removal</a></li>\n</ul>\n<p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。</p>\n<p>这里只对 400、408、413、416、417、418、419 这几个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/projects/jdk/18/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 18 文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PocFKR9z9u7-YCZHsrA5kQ\" target=\"_blank\" rel=\"noopener noreferrer\">IntelliJ IDEA | Java 18 功能支持</a></li>\n</ul>\n<h2> JEP 400:默认字符集为 UTF-8</h2>\n<p>JDK 终于将 UTF-8 设置为默认字符集。</p>\n<p>在 Java 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。就比如说你在 Mac 上运行正常的一段打印文字到控制台的 Java 程序到了 Windows 上就会出现乱码，如果你不手动更改字符集的话。</p>\n<h2> JEP 408:简易的 Web 服务器</h2>\n<p>Java 18 之后，你可以使用 <code>jwebserver</code> 命令启动一个简易的静态 Web 服务器。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个服务器不支持 CGI 和 Servlet，只限于静态文件。</p>\n<h2> JEP 413:优化 Java API 文档中的代码片段</h2>\n<p>在 Java 18 之前，如果我们想要在 Javadoc 中引入代码片段可以使用 <code>&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 这种方式生成的效果比较一般。</p>\n<p>在 Java 18 之后，可以通过 <code>@snippet</code> 标签来做这件事情。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>@snippet</code> 这种方式生成的效果更好且使用起来更方便一些。</p>\n<h2> JEP 416:使用方法句柄重新实现反射核心</h2>\n<p>Java 18 改进了 <code>java.lang.reflect.Method</code>、<code>Constructor</code> 的实现逻辑，使之性能更好，速度更快。这项改动不会改动相关 API ，这意味着开发中不需要改动反射相关代码，就可以体验到性能更好反射。</p>\n<p>OpenJDK 官方给出了新老实现的反射性能基准测试结果。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png\" alt=\"新老实现的反射性能基准测试结果\" tabindex=\"0\"><figcaption>新老实现的反射性能基准测试结果</figcaption></figure>\n<h2> JEP 417: 向量 API（第三次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>\n<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>\n<p>这是对数组元素的简单标量计算：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是使用 Vector API 进行的等效向量计算：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 JDK 18 中，向量 API 的性能得到了进一步的优化。</p>\n<h2> JEP 418:互联网地址解析 SPI</h2>\n<p>Java 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 <code>java.net.InetAddress</code> 可以使用平台之外的第三方解析器。</p>\n<h2> JEP 419:Foreign Function &amp; Memory API（第二次孵化）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在 <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png",
      "date_published": "2022-09-13T12:49:20.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 19 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java19.html",
      "id": "https://javaguide.cn/java/new-features/java19.html",
      "summary": "JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。 JDK 19 只有 7 个新特性： JEP 405: Record Patterns（记录模式）（预览） JEP 422: Linux/RISC-V Port JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）（预览） JEP 425: Virtual Threads（虚拟线程）（预览） JEP 426: Vector（向量）API（第四次孵化） JEP 427: Pattern Matching for switch（switch 模式匹配） JEP 428: Structured Concurrency（结构化并发）（孵化）",
      "content_html": "<p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。</p>\n<p>JDK 19 只有 7 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.org/jeps/405\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 405: Record Patterns（记录模式）</a>（预览）</li>\n<li><a href=\"https://openjdk.org/jeps/422\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 422: Linux/RISC-V Port</a></li>\n<li><a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（预览）</li>\n<li><a href=\"https://openjdk.org/jeps/425\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 425: Virtual Threads（虚拟线程）</a>（预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426: Vector（向量）API</a>（第四次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/427\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 427: Pattern Matching for switch（switch 模式匹配）</a></li>\n<li><a href=\"https://openjdk.org/jeps/428\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 428: Structured Concurrency（结构化并发）</a>（孵化）</li>\n</ul>\n<p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：<a href=\"https://openjdk.org/projects/jdk/19/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 19 文档</a></p>\n<h2> JEP 424: 外部函数和内存 API（预览）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在没有外部函数和内存 API 之前：</p>\n<ul>\n<li>Java 通过 <a href=\"https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java\" target=\"_blank\" rel=\"noopener noreferrer\"><code>sun.misc.Unsafe</code></a> 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），<code>Unsafe</code> 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大。</li>\n<li>Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章：<a href=\"https://www.baeldung.com/jni\" target=\"_blank\" rel=\"noopener noreferrer\">Guide to JNI (Java Native Interface)</a> ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然<a href=\"https://github.com/java-native-access/jna\" target=\"_blank\" rel=\"noopener noreferrer\">JNA</a>、<a href=\"https://github.com/jnr/jnr-ffi\" target=\"_blank\" rel=\"noopener noreferrer\">JNR</a>和<a href=\"https://github.com/bytedeco/javacpp\" target=\"_blank\" rel=\"noopener noreferrer\">JavaCPP</a>等框架对 JNI 进行了改进，但效果还是不太理想。</li>\n</ul>\n<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p>\n<p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p>\n<ul>\n<li>分配外部内存：<code>MemorySegment</code>、、<code>MemoryAddress</code>和<code>SegmentAllocator</code>）；</li>\n<li>操作和访问结构化的外部内存：<code>MemoryLayout</code>, <code>VarHandle</code>；</li>\n<li>控制外部内存的分配和释放：<code>MemorySession</code>；</li>\n<li>调用外部函数：<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>。</li>\n</ul>\n<p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code>radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 425: 虚拟线程（预览）</h2>\n<p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>\n<p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>\n<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：<a href=\"https://www.zhihu.com/question/536743167\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/536743167</a> 。</p>\n<p>Java 虚拟线程的详细解读和原理可以看下面这两篇文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA\" target=\"_blank\" rel=\"noopener noreferrer\">虚拟线程原理及性能分析｜得物技术</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q\" target=\"_blank\" rel=\"noopener noreferrer\">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>\n<li><a href=\"https://www.cnblogs.com/throwable/p/16758997.html\" target=\"_blank\" rel=\"noopener noreferrer\">虚拟线程 - VirtualThread 源码透视</a></li>\n</ul>\n<h2> JEP 426: 向量 API（第四次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>在 <a href=\"/java/new-features/java18.html\" target=\"blank\">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 428: 结构化并发(孵化)</h2>\n<p>JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>\n<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>\n<p>结构化并发的基本 API 是<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>StructuredTaskScope</code></a>。<code>StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>\n<p><code>StructuredTaskScope</code> 的基本用法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2022-09-13T01:11:51.000Z",
      "date_modified": "2023-11-21T02:37:39.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "ARP 协议详解(网络层)",
      "url": "https://javaguide.cn/cs-basics/network/arp.html",
      "id": "https://javaguide.cn/cs-basics/network/arp.html",
      "summary": "每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。 ARP 协议，可以说是在协议栈中属于一个偏底层的、非常重要的、又非常简单的通信协议。 开始阅读这篇文章之前，你可以先看看下面几个问题： ARP 协议在协议栈中的位置？ ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。 ARP 协议解决了什么问题，地位如何？ ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。 ARP 工作原理？ 只希望大家记住几个关键词：ARP 表、广播问询、单播响应。",
      "content_html": "<p>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。</p>\n<p><strong>ARP 协议</strong>，可以说是在协议栈中属于一个<strong>偏底层的、非常重要的、又非常简单的</strong>通信协议。</p>\n<p>开始阅读这篇文章之前，你可以先看看下面几个问题：</p>\n<ol>\n<li><strong>ARP 协议在协议栈中的位置？</strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。</li>\n<li><strong>ARP 协议解决了什么问题，地位如何？</strong> ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>\n<li><strong>ARP 工作原理？</strong> 只希望大家记住几个关键词：<strong>ARP 表、广播问询、单播响应</strong>。</li>\n</ol>\n<h2> MAC 地址</h2>\n<p>在介绍 ARP 协议之前，有必要介绍一下 MAC 地址。</p>\n<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>\n<figure><figcaption>路由器的背面就会注明 MAC 位址</figcaption></figure>\n<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>\n<blockquote>\n<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>\n</blockquote>\n<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>\n<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>\n<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>\n<h2> ARP 协议工作原理</h2>\n<p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p>\n<p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p>\n<p>ARP 的工作原理将分两种场景讨论：</p>\n<ol>\n<li><strong>同一局域网内的 MAC 寻址</strong>；</li>\n<li><strong>从一个局域网到另一个局域网中的网络设备的寻址</strong>。</li>\n</ol>\n<h3> 同一局域网内的 MAC 寻址</h3>\n<p>假设当前有如下场景：IP 地址为<code>137.196.7.23</code>的主机 A，想要给同一局域网内的 IP 地址为<code>137.196.7.14</code>主机 B，发送 IP 数据报文。</p>\n<blockquote>\n<p>再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。</p>\n</blockquote>\n<p>为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：</p>\n<ol>\n<li>\n<p>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</p>\n<p>ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——<code>FF-FF-FF-FF-FF-FF</code>，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。</p>\n</li>\n<li>\n<p>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</p>\n</li>\n<li>\n<p>主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。</p>\n<p>ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。</p>\n</li>\n<li>\n<p>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</p>\n</li>\n</ol>\n<figure><figcaption></figcaption></figure>\n<p>在整个过程中，有几点需要补充说明的是：</p>\n<ol>\n<li>主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。</li>\n<li>ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。</li>\n<li>目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。</li>\n</ol>\n<p>总结来说，ARP 协议是一个<strong>广播问询，单播响应</strong>协议。</p>\n<h3> 不同局域网内的 MAC 寻址</h3>\n<p>更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。</p>\n<p>接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在的子网内所有设备（接口）都将会捕获该分组，因为该分组的目的 IP 与发送主机 A 的 IP 在同一个子网中。但是当目的 IP 与 A 不在同一子网时，A 所在子网内将不会有设备成功接收该分组。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：</p>\n<ol>\n<li>\n<p>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</p>\n<p>目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。</p>\n</li>\n<li>\n<p>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</p>\n</li>\n<li>\n<p>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</p>\n</li>\n<li>\n<p>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</p>\n<p>到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p>\n</li>\n<li>\n<p>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</p>\n</li>\n</ol>\n<figure><figcaption></figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2022-08-28T07:18:49.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "分布式锁介绍",
      "url": "https://javaguide.cn/distributed-system/distributed-lock.html",
      "id": "https://javaguide.cn/distributed-system/distributed-lock.html",
      "summary": "这是一则或许对你有用的小广告 面试专版：准备 Java 面试的小伙伴可以考虑面试专版：《Java 面试指北 》 (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。 知识星球：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 JavaGuide 官方知识星球。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">这是一则或许对你有用的小广告</p>\n<ul>\n<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>\n<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 官方知识星球</a></strong>。</li>\n</ul>\n</div>\n<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>\n<p>这篇文章我们先介绍一下分布式锁的基本概念。</p>\n<h2> 为什么需要分布式锁？</h2>\n<p>在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p>\n<p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p>\n<ul>\n<li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</li>\n<li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\n<li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\n<li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</li>\n<li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</li>\n<li>此时就发生了超卖问题，导致商品被多卖了一份。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png\" alt=\"共享资源未互斥访问导致出现问题\" tabindex=\"0\"><figcaption>共享资源未互斥访问导致出现问题</figcaption></figure>\n<p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p>\n<p><strong>如何才能实现共享资源的互斥访问呢？</strong> 锁是一个比较通用的解决方案，更准确点来说是悲观锁。</p>\n<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>\n<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p>\n<p>下面是我对本地锁画的一张示意图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/jvm-local-lock.png\" alt=\"本地锁\" tabindex=\"0\"><figcaption>本地锁</figcaption></figure>\n<p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p>\n<p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p>\n<p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p>\n<p>下面是我对分布式锁画的一张示意图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock.png\" alt=\"分布式锁\" tabindex=\"0\"><figcaption>分布式锁</figcaption></figure>\n<p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p>\n<h2> 分布式锁应该具备哪些条件？</h2>\n<p>一个最基本的分布式锁需要满足：</p>\n<ul>\n<li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。</li>\n<li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li>\n<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>\n</ul>\n<p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：</p>\n<ul>\n<li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li>\n<li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li>\n</ul>\n<h2> 分布式锁的常见实现方式有哪些？</h2>\n<p>常见分布式锁实现方案如下：</p>\n<ul>\n<li>基于关系型数据库比如 MySQL 实现分布式锁。</li>\n<li>基于分布式协调服务 ZooKeeper 实现分布式锁。</li>\n<li>基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。</li>\n</ul>\n<p>关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。</p>\n<p>基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些，我专门写了一篇文章来详细介绍这两种方案：<a href=\"/distributed-system/distributed-lock-implementations.html\" target=\"blank\">分布式锁常见实现方案总结</a>。</p>\n<h2> 总结</h2>\n<p>这篇文章我们主要介绍了：</p>\n<ul>\n<li>分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。</li>\n<li>分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。</li>\n<li>分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png",
      "date_published": "2022-08-23T10:53:21.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "CDN常见问题总结",
      "url": "https://javaguide.cn/high-performance/cdn.html",
      "id": "https://javaguide.cn/high-performance/cdn.html",
      "summary": "什么是 CDN ？ CDN 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 内容分发网络 。 我们可以将内容分发网络拆开来看： 内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。 分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。",
      "content_html": "<h2> 什么是 CDN ？</h2>\n<p><strong>CDN</strong> 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 <strong>内容分发网络</strong> 。</p>\n<p>我们可以将内容分发网络拆开来看：</p>\n<ul>\n<li>内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。</li>\n<li>分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</li>\n</ul>\n<p>所以，简单来说，<strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</strong></p>\n<p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png\" alt=\"京东仓配系统\" tabindex=\"0\"><figcaption>京东仓配系统</figcaption></figure>\n<p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-101.png\" alt=\"CDN 简易示意图\" tabindex=\"0\"><figcaption>CDN 简易示意图</figcaption></figure>\n<p>我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 <strong>静态资源</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png\" alt=\"阿里云文档：https://help.aliyun.com/document_detail/64836.html\" tabindex=\"0\"><figcaption>阿里云文档：<a href=\"https://help.aliyun.com/document_detail/64836.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://help.aliyun.com/document_detail/64836.html</a></figcaption></figure>\n<p>绝大部分公司都会在项目开发中使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</p>\n<p>很多朋友可能要问了：<strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？</strong></p>\n<ul>\n<li>成本太高，需要部署多份相同的服务。</li>\n<li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。</li>\n</ul>\n<p>同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。</p>\n<h2> CDN 工作原理是什么？</h2>\n<p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：</p>\n<ol>\n<li>静态资源是如何被缓存到 CDN 节点中的？</li>\n<li>如何找到最合适的 CDN 节点？</li>\n<li>如何防止静态资源被盗用？</li>\n</ol>\n<h3> 静态资源是如何被缓存到 CDN 节点中的？</h3>\n<p>你可以通过 <strong>预热</strong> 的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。</p>\n<p>如果不预热的话，你访问的资源可能不在 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 <strong>回源</strong>。</p>\n<blockquote>\n<ul>\n<li>回源：当 CDN 节点上没有用户请求的资源或该资源的缓存已经过期时，CDN 节点需要从原始服务器获取最新的资源内容，这个过程就是回源。当用户请求发生回源的话，会导致该请求的响应速度比未使用 CDN 还慢，因为相比于未使用 CDN 还多了一层 CDN 的调用流程。</li>\n<li>预热：预热是指在 CDN 上提前将内容缓存到 CDN 节点上。这样当用户在请求这些资源时，能够快速地从最近的 CDN 节点获取到而不需要回源，进而减少了对源站的访问压力，提高了访问速度。</li>\n</ul>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-back-to-source.png\" alt=\"CDN 回源\" tabindex=\"0\"><figcaption>CDN 回源</figcaption></figure>\n<p>如果资源有更新的话，你也可以对其 <strong>刷新</strong> ，删除 CDN 节点上缓存的旧资源，并强制 CDN 节点回源站获取最新资源。</p>\n<p>几乎所有云厂商提供的 CDN 服务都具备缓存的刷新和预热功能（下图是阿里云 CDN 服务提供的相应功能）：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-refresh-warm-up.png\" alt=\"CDN 缓存的刷新和预热\" tabindex=\"0\"><figcaption>CDN 缓存的刷新和预热</figcaption></figure>\n<p><strong>命中率</strong> 和 <strong>回源率</strong> 是衡量 CDN 服务质量两个重要指标。命中率越高越好，回源率越低越好。</p>\n<h3> 如何找到最合适的 CDN 节点？</h3>\n<p>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。</p>\n<p>CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的：</p>\n<ol>\n<li>浏览器向 DNS 服务器发送域名请求；</li>\n<li>DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；</li>\n<li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li>\n<li>浏览器直接访问指定的 CDN 节点。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-overview.png\" alt=\"CDN 原理示意图\" tabindex=\"0\"><figcaption>CDN 原理示意图</figcaption></figure>\n<p>为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。</p>\n<p><strong>GSLB 是如何选择出最合适的 CDN 节点呢？</strong> GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。</p>\n<h3> 如何防止资源被盗刷？</h3>\n<p>如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。</p>\n<p>解决这个问题最常用最简单的办法设置 <strong>Referer 防盗链</strong>，具体来说就是根据 HTTP 请求的头信息里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。</p>\n<p>CDN 服务提供商几乎都提供了这种比较基础的防盗链机制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cnd-tencent-cloud-anti-theft.png\" alt=\"腾讯云 CDN Referer 防盗链配置\" tabindex=\"0\"><figcaption>腾讯云 CDN Referer 防盗链配置</figcaption></figure>\n<p>不过，如果站点的防盗链配置允许 Referer 为空的话，通过隐藏 Referer，可以直接绕开防盗链。</p>\n<p>通常情况下，我们会配合其他机制来确保静态资源被盗用，一种常用的机制是 <strong>时间戳防盗链</strong> 。相比之下，<strong>时间戳防盗链</strong> 的安全性更强一些。时间戳防盗链加密的 URL 具有时效性，过期之后就无法再被允许访问。</p>\n<p>时间戳防盗链的 URL 通常会有两个参数一个是签名字符串，一个是过期时间。签名字符串一般是通过对用户设定的加密字符串、请求路径、过期时间通过 MD5 哈希算法取哈希的方式获得。</p>\n<p>时间戳防盗链 URL 示例：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>wsSecret</code>：签名字符串。</li>\n<li><code>wsTime</code>: 过期时间。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/timestamp-anti-theft.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>时间戳防盗链的实现也比较简单，并且可靠性较高，推荐使用。并且，绝大部分 CDN 服务提供商都提供了开箱即用的时间戳防盗链机制。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-performance/cdn/qiniuyun-timestamp-anti-theft.png\" alt=\"七牛云时间戳防盗链配置\" tabindex=\"0\"><figcaption>七牛云时间戳防盗链配置</figcaption></figure>\n<p>除了 Referer 防盗链和时间戳防盗链之外，你还可以 IP 黑白名单配置、IP 访问限频配置等机制来防盗刷。</p>\n<h2> 总结</h2>\n<ul>\n<li>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</li>\n<li>基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</li>\n<li>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点。</li>\n<li>为了防止静态资源被盗用，我们可以利用 <strong>Referer 防盗链</strong> + <strong>时间戳防盗链</strong> 。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>时间戳防盗链 - 七牛云 CDN：<a href=\"https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention</a></li>\n<li>CDN 是个啥玩意？一文说个明白：<a href=\"https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw</a></li>\n<li>《透视 HTTP 协议》- 37 | CDN：加速我们的网络服务：<a href=\"http://gk.link/a/11yOG\" target=\"_blank\" rel=\"noopener noreferrer\">http://gk.link/a/11yOG</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png",
      "date_published": "2022-08-21T05:04:07.000Z",
      "date_modified": "2023-10-10T06:43:53.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "Web 实时消息推送详解",
      "url": "https://javaguide.cn/system-design/web-real-time-message-push.html",
      "id": "https://javaguide.cn/system-design/web-real-time-message-push.html",
      "summary": "原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。 我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。 站内信 Web 消息推送",
      "content_html": "<blockquote>\n<p>原文地址：<a href=\"https://juejin.cn/post/7122014462181113887%EF%BC%8CJavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7122014462181113887，JavaGuide</a> 对本文进行了完善总结。</p>\n</blockquote>\n<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png\" alt=\"站内信 Web 消息推送\" tabindex=\"0\"><figcaption>站内信 Web 消息推送</figcaption></figure>\n<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>\n<h2> 什么是消息推送？</h2>\n<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>\n<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</p>\n<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>\n<p>移动端消息推送示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png\" alt=\"移动端消息推送示例\" tabindex=\"0\"><figcaption>移动端消息推送示例</figcaption></figure>\n<p>Web 端消息推送示例：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png\" alt=\"Web 端消息推送示例\" tabindex=\"0\"><figcaption>Web 端消息推送示例</figcaption></figure>\n<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code>+1</code> 就可以了。</p>\n<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png\" alt=\"消息推送表\" tabindex=\"0\"><figcaption>消息推送表</figcaption></figure>\n<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>\n<h2> 消息推送常见方案</h2>\n<h3> 短轮询</h3>\n<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>\n<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>\n<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>\n<h3> 长轮询</h3>\n<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>\n<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>\n<p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在 Servlet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png\" alt=\"长轮询示意图\" tabindex=\"0\"><figcaption>长轮询示意图</figcaption></figure>\n<p><code>DeferredResult</code>可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code>DeferredResult.setResult(200)</code>提交响应结果。</p>\n<p>下边我们用长轮询来实现消息推送。</p>\n<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的<code>Multimap</code>结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当请求超过设置的超时时间，会抛出<code>AsyncRequestTimeoutException</code>异常，这里直接用<code>@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>\n<div class=\"language-kotlin line-numbers-mode\" data-ext=\"kt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们来测试一下，首先页面发起长轮询请求<code>/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code>/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>\n<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>\n<h3> iframe 流</h3>\n<p>iframe 流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>\n<p>传输的数据通常是 HTML、或是内嵌的 JavaScript 脚本，来达到实时更新页面的效果。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png\" alt=\"iframe 流示意图\" tabindex=\"0\"><figcaption>iframe 流示意图</figcaption></figure>\n<p>这种方式实现简单，前端只要一个<code>&lt;iframe&gt;</code>标签搞定了</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>iframe 流的服务器开销很大，而且 IE、Chrome 等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png\" alt=\"iframe 流效果\" tabindex=\"0\"><figcaption>iframe 流效果</figcaption></figure>\n<p>iframe 流非常不友好，强烈不推荐。</p>\n<h3> SSE (我的方式)</h3>\n<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>\n<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>\n<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png\" alt=\"SSE 示意图\" tabindex=\"0\"><figcaption>SSE 示意图</figcaption></figure>\n<p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>\n<ul>\n<li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li>\n<li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>\n<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>\n<li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>\n<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>\n</ul>\n<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>\n<blockquote>\n<p>技术并没有好坏之分，只有哪个更合适</p>\n</blockquote>\n<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>\n<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p>\n<p>前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务端的实现更简单，创建一个<code>SseEmitter</code>对象放入<code>sseEmitterMap</code>进行管理</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png\" alt=\"SSE 兼容性\" tabindex=\"0\"><figcaption>SSE 兼容性</figcaption></figure>\n<h3> Websocket</h3>\n<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。</p>\n<p>是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png\" alt=\"Websocket 示意图\" tabindex=\"0\"><figcaption>Websocket 示意图</figcaption></figure>\n<p>WebSocket 的工作过程可以分为以下几个步骤：</p>\n<ol>\n<li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示要求升级协议为 WebSocket；</li>\n<li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，<code>Connection: Upgrade</code>和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示成功升级到 WebSocket 协议。</li>\n<li>客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，而不是传统的 HTTP 请求和响应。WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li>\n<li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。</li>\n</ol>\n<p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p>\n<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务端使用<code>@ServerEndpoint</code>注解标注当前类为一个 WebSocket 服务器，客户端可以通过<code>ws://localhost:7777/webSocket/10086</code>来连接到 WebSocket 服务器端。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> MQTT</h3>\n<p><strong>什么是 MQTT 协议？</strong></p>\n<p>MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>\n<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png\" alt=\"MQTT 协议示例\" tabindex=\"0\"><figcaption>MQTT 协议示例</figcaption></figure>\n<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>\n<p><strong>为什么要用 MQTT 协议？</strong></p>\n<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>\n<ul>\n<li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>\n<li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>\n<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。</li>\n</ul>\n<p>具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>\n<ul>\n<li>MQTT 协议的介绍：<a href=\"https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA\" target=\"_blank\" rel=\"noopener noreferrer\">我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单</a></li>\n<li>MQTT 实现消息推送：<a href=\"https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg\" target=\"_blank\" rel=\"noopener noreferrer\">未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~</a></li>\n</ul>\n<h2> 总结</h2>\n<blockquote>\n<p>以下内容为 JavaGuide 补充</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>介绍</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>短轮询</td>\n<td>客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）</td>\n<td>简单、易理解、易实现</td>\n<td>实时性太差，无效请求太多，频繁建立连接太耗费资源</td>\n</tr>\n<tr>\n<td>长轮询</td>\n<td>与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求</td>\n<td>减少了无效请求</td>\n<td>挂起请求会导致资源浪费</td>\n</tr>\n<tr>\n<td>iframe 流</td>\n<td>服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</td>\n<td>简单、易理解、易实现</td>\n<td>维护一个长连接会增加开销，效果太差（图标会不停旋转）</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td>一种服务器端到客户端(浏览器)的单向消息推送。</td>\n<td>简单、易实现，功能丰富</td>\n<td>不支持双向通信</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td>除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。</td>\n<td>性能高、开销小</td>\n<td>对开发人员要求更高，实现相对复杂一些</td>\n</tr>\n<tr>\n<td>MQTT</td>\n<td>基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。</td>\n<td>成熟稳定，轻量级</td>\n<td>对开发人员要求更高，实现相对复杂一些</td>\n</tr>\n</tbody>\n</table>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png",
      "date_published": "2022-08-19T03:13:03.000Z",
      "date_modified": "2023-12-01T04:42:42.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Java 语法糖详解",
      "url": "https://javaguide.cn/java/basis/syntactic-sugar.html",
      "id": "https://javaguide.cn/java/basis/syntactic-sugar.html",
      "summary": "作者：Hollis 原文：https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw 语法糖是大厂 Java 面试常问的一个知识点。 本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。",
      "content_html": "<blockquote>\n<p>作者：Hollis</p>\n<p>原文：<a href=\"https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw</a></p>\n</blockquote>\n<p>语法糖是大厂 Java 面试常问的一个知识点。</p>\n<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。</p>\n<h2> 什么是语法糖？</h2>\n<p><strong>语法糖（Syntactic Sugar）</strong> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<blockquote>\n<p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>\n</blockquote>\n<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。</p>\n<h2> Java 中有哪些常见的语法糖？</h2>\n<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， <strong>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</strong></p>\n<p>说到编译，大家肯定都知道，Java 语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于 Java 虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>\n<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>\n<p>我们这里会用到<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120609&amp;idx=1&amp;sn=5659f96310963ad57d55b48cee63c788&amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">反编译</a>，你可以通过 <a href=\"http://www.javadecompilers.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Decompilers online</a> 对 Class 文件进行在线反编译。</p>\n<h3> switch 支持 String 与枚举</h3>\n<p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中<code>switch</code>开始支持<code>String</code>。</p>\n<p>在开始之前先科普下，Java 中的<code>switch</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其 ascii 码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ascii 码是整型)以及<code>int</code>。</p>\n<p>那么接下来看下<code>switch</code>对<code>String</code>的支持，有以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看到这个代码，你知道原来 <strong>字符串的 switch 是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。</strong> 还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>\n<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 <code>switch</code> 或者使用纯整数常量，但这也不是很差。</p>\n<h3> 泛型</h3>\n<p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和 C#是使用<code>Code specialization</code>的处理机制，而 Java 使用的是<code>Code sharing</code>的机制。</p>\n<blockquote>\n<p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>\n</blockquote>\n<p>也就是说，<strong>对于 Java 虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>\n<p>类型擦除的主要过程如下：1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>\n<p>以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解语法糖之后会变成：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类型擦除后会变成：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>\n<h3> 自动装箱与拆箱</h3>\n<p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>\n<p>先来看个自动装箱的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看个自动拆箱的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>\n<p>所以，<strong>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</strong></p>\n<h3> 可变长参数</h3>\n<p>可变参数(<code>variable arguments</code>)是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>\n<p>看下以下可变参数代码，其中 <code>print</code> 方法接收可变参数：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>\n<h3> 枚举</h3>\n<p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>\n<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。</p>\n<p><strong>当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</strong></p>\n<h3> 内部类</h3>\n<p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>\n<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码编译后会生成两个 class 文件：<code>OutterClass$InnerClass.class</code>、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 条件编译</h3>\n<p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>\n<p>如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(\"Hello, ONLINE!\");</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为 false 的时候，编译器就没有对其内的代码进行编译。</p>\n<p>所以，<strong>Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>\n<h3> 断言</h3>\n<p>在 Java 中，<code>assert</code>关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了<code>assert</code>关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>\n<p>看一段包含断言的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled 字段的值。</p>\n<h3> 数值字面量</h3>\n<p>在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>\n<p>比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code>_</code>，需要在编译阶段把他去掉。</strong></p>\n<h3> for-each</h3>\n<p>增强 for 循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>代码很简单，<strong>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</strong></p>\n<h3> try-with-resource</h3>\n<p>Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>\n<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>\n<h3> Lambda 表达式</h3>\n<p>关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Lambda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</strong></p>\n<p>先来看一个简单的 lambda 表达式。遍历一个 list：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>\n<p>反编译后代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数 <code>implMethod</code> 指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>\n<p>再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两个 lambda 表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>\n<p><strong>所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。</strong></p>\n<h2> 可能遇到的坑</h2>\n<h3> 泛型</h3>\n<p><strong>一、当泛型遇到重载</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是<code>List&lt;String&gt;</code>另一个是<code>List&lt;Integer&gt;</code> ，但是，这段代码是编译通不过的。因为我们前面讲过，参数<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p>\n<p><strong>二、当泛型遇到 catch</strong></p>\n<p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>\n<p><strong>三、当泛型内包含静态变量</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码输出结果为：2！</p>\n<p>由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>\n<h3> 自动装箱与拆箱</h3>\n<p><strong>对象相等比较</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>\n<blockquote>\n<p>适用于整数值区间-128 至 +127。</p>\n<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>\n</blockquote>\n<h3> 增强 for 循环</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>会抛出<code>ConcurrentModificationException</code>异常。</p>\n<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>\n<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>\n<h2> 总结</h2>\n<p>前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>\n<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避过度使用。使用之前最好了解下原理，避免掉坑。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png",
      "date_published": "2022-08-18T12:45:01.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "权限系统设计详解",
      "url": "https://javaguide.cn/system-design/security/design-of-authority-system.html",
      "id": "https://javaguide.cn/system-design/security/design-of-authority-system.html",
      "summary": "JavaGuide官方知识星球 作者：转转技术团队 原文：https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw",
      "content_html": "<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiu.png\" alt=\"JavaGuide官方知识星球\" tabindex=\"0\"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>\n<blockquote>\n<p>作者：转转技术团队</p>\n<p>原文：<a href=\"https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw</a></p>\n</blockquote>\n<h2> 老权限系统的问题与现状</h2>\n<p>转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题：</p>\n<ol>\n<li>各业务重复造轮子，维护成本高</li>\n<li>各系统只解决部分场景问题，方案不够通用，新项目选型时没有可靠的权限管理方案</li>\n<li>缺乏统一的日志管理与审批流程，在授权信息追溯上十分困难</li>\n</ol>\n<p>基于上述问题，去年底公司启动建设转转统一权限系统，目标是开发一套灵活、易用、安全的权限管理系统，供各业务使用。</p>\n<h2> 业界权限系统的设计方式</h2>\n<p>目前业界主流的权限模型有两种，下面分别介绍下：</p>\n<ul>\n<li><strong>基于角色的访问控制（RBAC）</strong></li>\n<li><strong>基于属性的访问控制（ABAC）</strong></li>\n</ul>\n<h3> RBAC 模型</h3>\n<p><strong>基于角色的访问控制（Role-Based Access Control，简称 RBAC）</strong> 指的是通过用户的角色（Role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。</p>\n<p>一个用户可以拥有若干角色，每一个角色又可以被分配若干权限这样，就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。</p>\n<p>用一个图来描述如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/rbac.png\" alt=\"RBAC 权限模型示意图\" tabindex=\"0\"><figcaption>RBAC 权限模型示意图</figcaption></figure>\n<p>当使用 <code>RBAC模型</code> 时，通过分析用户的实际情况，基于共同的职责和需求，授予他们不同角色。这种 <code>用户 -&gt; 角色 -&gt; 权限</code> 间的关系，让我们可以不用再单独管理单个用户权限，用户从授予的角色里面获取所需的权限。</p>\n<p>以一个简单的场景（Gitlab 的权限系统）为例，用户系统中有 <code>Admin</code>、<code>Maintainer</code>、<code>Operator</code> 三种角色，这三种角色分别具备不同的权限，比如只有 <code>Admin</code> 具备创建代码仓库、删除代码仓库的权限，其他的角色都不具备。我们授予某个用户 <code>Admin</code> 这个角色，他就具备了 <strong>创建代码仓库</strong> 和 <strong>删除代码仓库</strong> 这两个权限。</p>\n<p>通过 <code>RBAC模型</code> ，当存在多个用户拥有相同权限时，我们只需要创建好拥有该权限的角色，然后给不同的用户分配不同的角色，后续只需要修改角色的权限，就能自动修改角色内所有用户的权限。</p>\n<h3> ABAC 模型</h3>\n<p><strong>基于属性的访问控制（Attribute-Based Access Control，简称 ABAC）</strong> 是一种比 <code>RBAC模型</code> 更加灵活的授权模型，它的原理是通过各种属性来动态判断一个操作是否可以被允许。这个模型在云系统中使用的比较多，比如 AWS，阿里云等。</p>\n<p>考虑下面这些场景的权限控制：</p>\n<ol>\n<li>授权某个人具体某本书的编辑权限</li>\n<li>当一个文档的所属部门跟用户的部门相同时，用户可以访问这个文档</li>\n<li>当用户是一个文档的拥有者并且文档的状态是草稿，用户可以编辑这个文档</li>\n<li>早上九点前禁止 A 部门的人访问 B 系统</li>\n<li>在除了上海以外的地方禁止以管理员身份访问 A 系统</li>\n<li>用户对 2022-06-07 之前创建的订单有操作权限</li>\n</ol>\n<p>可以发现上述的场景通过 <code>RBAC模型</code> 很难去实现，因为 <code>RBAC模型</code> 仅仅描述了用户可以做什么操作，但是操作的条件，以及操作的数据，<code>RBAC模型</code> 本身是没有这些限制的。但这恰恰是 <code>ABAC模型</code> 的长处，<code>ABAC模型</code> 的思想是基于用户、访问的数据的属性、以及各种环境因素去动态计算用户是否有权限进行操作。</p>\n<h4> ABAC 模型的原理</h4>\n<p>在 <code>ABAC模型</code> 中，一个操作是否被允许是基于对象、资源、操作和环境信息共同动态计算决定的。</p>\n<ul>\n<li><strong>对象</strong>：对象是当前请求访问资源的用户。用户的属性包括 ID，个人资源，角色，部门和组织成员身份等</li>\n<li><strong>资源</strong>：资源是当前用户要访问的资产或对象，例如文件，数据，服务器，甚至 API</li>\n<li><strong>操作</strong>：操作是用户试图对资源进行的操作。常见的操作包括“读取”，“写入”，“编辑”，“复制”和“删除”</li>\n<li><strong>环境</strong>：环境是每个访问请求的上下文。环境属性包含访问的时间和位置，对象的设备，通信协议和加密强度等</li>\n</ul>\n<p>在 <code>ABAC模型</code> 的决策语句的执行过程中，决策引擎会根据定义好的决策语句，结合对象、资源、操作、环境等因素动态计算出决策结果。每当发生访问请求时，<code>ABAC模型</code> 决策系统都会分析属性值是否与已建立的策略匹配。如果有匹配的策略，访问请求就会被通过。</p>\n<h2> 新权限系统的设计思想</h2>\n<p>结合转转的业务现状，<code>RBAC模型</code> 满足了转转绝大部分业务场景，并且开发成本远低于 <code>ABAC模型</code> 的权限系统，所以新权限系统选择了基于 <code>RBAC模型</code> 来实现。对于实在无法满足的业务系统，我们选择了暂时性不支持，这样可以保障新权限系统的快速落地，更快的让业务使用起来。</p>\n<p>标准的 <code>RBAC模型</code> 是完全遵守 <code>用户 -&gt; 角色 -&gt; 权限</code> 这个链路的，也就是用户的权限完全由他所拥有的角色来控制，但是这样会有一个缺点，就是给用户加权限必须新增一个角色，导致实际操作起来效率比较低。所以我们在 <code>RBAC模型</code> 的基础上，新增了给用户直接增加权限的能力，也就是说既可以给用户添加角色，也可以给用户直接添加权限。最终用户的权限是由拥有的角色和权限点组合而成。</p>\n<p><strong>新权限系统的权限模型</strong>：用户最终权限 = 用户拥有的角色带来的权限 + 用户独立配置的权限，两者取并集。</p>\n<p>新权限系统方案如下图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-design.png\" alt=\"新权限系统方案\" tabindex=\"0\"><figcaption>新权限系统方案</figcaption></figure>\n<ul>\n<li>首先，将集团所有的用户（包括外部用户），通过 <strong>统一登录与注册</strong> 功能实现了统一管理，同时与公司的组织架构信息模块打通，实现了同一个人员在所有系统中信息的一致，这也为后续基于组织架构进行权限管理提供了可行性。</li>\n<li>其次，因为新权限系统需要服务集团所有业务，所以需要支持多系统权限管理。用户进行权限管理前，需要先选择相应的系统，然后配置该系统的 <strong>菜单权限</strong> 和 <strong>数据权限</strong> 信息，建立好系统的各个权限点。<em>PS：菜单权限和数据权限的具体说明，下文会详细介绍。</em></li>\n<li>最后，创建该系统下的不同角色，给不同角色配置好权限点。比如店长角色，拥有店员操作权限、本店数据查看权限等，配置好这个角色后，后续只需要给店长增加这个角色，就可以让他拥有对应的权限。</li>\n</ul>\n<p>完成上述配置后，就可以进行用户的权限管理了。有两种方式可以给用户加权限：</p>\n<ol>\n<li>先选用户，然后添加权限。该方式可以给用户添加任意角色或是菜单/数据权限点。</li>\n<li>先选择角色，然后关联用户。该方式只可给用户添加角色，不能单独添加菜单/数据权限点。</li>\n</ol>\n<p>这两种方式的具体设计方案，后文会详细说明。</p>\n<h3> 权限系统自身的权限管理</h3>\n<p>对于权限系统来说，首先需要设计好系统自身的权限管理，也就是需要管理好 ”谁可以进入权限系统，谁可以管理其他系统的权限“，对于权限系统自身的用户，会分为三类：</p>\n<ol>\n<li><strong>超级管理员</strong>：拥有权限系统的全部操作权限，可以进行系统自身的任何操作，也可以管理接入权限的应用系统的管理操作。</li>\n<li><strong>权限操作用户</strong>：拥有至少一个已接入的应用系统的超级管理员角色的用户。该用户能进行的操作限定在所拥有的应用系统权限范围内。权限操作用户是一种身份，无需分配，而是根据规则自动获得的。</li>\n<li><strong>普通用户</strong>：普通用户也可以认为是一种身份，除去上述 2 类人，其余的都为普通用户。他们只能申请接入系统以及访问权限申请页面。</li>\n</ol>\n<h3> 权限类型的定义</h3>\n<p>新权限系统中，我们把权限分为两大类，分别是：</p>\n<ul>\n<li><strong>菜单功能权限</strong>：包括系统的目录导航、菜单的访问权限，以及按钮和 API 操作的权限</li>\n<li><strong>数据权限</strong>：包括定义数据的查询范围权限，在不同系统中，通常叫做 “组织”、”站点“等，在新权限系统中，统一称作 ”组织“ 来管理数据权限</li>\n</ul>\n<h3> 默认角色的分类</h3>\n<p>每个系统中设计了三个默认角色，用来满足基本的权限管理需求，分别如下：</p>\n<ul>\n<li><strong>超级管理员</strong>：该角色拥有该系统的全部权限，可以修改系统的角色权限等配置，可以给其他用户授权。</li>\n<li><strong>系统管理员</strong>：该角色拥有给其他用户授权以及修改系统的角色权限等配置能力，但角色本身不具有任何权限。</li>\n<li><strong>授权管理员</strong>：该角色拥有给其他用户授权的能力。但是授权的范围不超出自己所拥有的权限。</li>\n</ul>\n<blockquote>\n<p>举个栗子：授权管理员 A 可以给 B 用户添加权限，但添加的范围 小于等于 A 用户已拥有的权限。</p>\n</blockquote>\n<p>经过这么区分，把 <strong>拥有权限</strong> 和 <strong>拥有授权能力</strong> ，这两部分给分隔开来，可以满足所有的权限控制的场景。</p>\n<h2> 新权限系统的核心模块设计</h2>\n<p>上面介绍了新权限系统的整体设计思想，接下来分别介绍下核心模块的设计</p>\n<h3> 系统/菜单/数据权限管理</h3>\n<p>把一个新系统接入权限系统有下列步骤：</p>\n<ol>\n<li>创建系统</li>\n<li>配置菜单功能权限</li>\n<li>配置数据权限（可选）</li>\n<li>创建系统的角色</li>\n</ol>\n<p>其中，1、2、3 的步骤，都是在系统管理模块完成，具体流程如下图:</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-design-access-flow-chart.png\" alt=\"系统接入流程图\" tabindex=\"0\"><figcaption>系统接入流程图</figcaption></figure>\n<p>用户可以对系统的基本信息进行增删改查的操作，不同系统之间通过 <code>系统编码</code> 作为唯一区分。同时 <code>系统编码</code> 也会用作于菜单和数据权限编码的前缀，通过这样的设计保证权限编码全局唯一性。</p>\n<p>例如系统的编码为 <code>test_online</code>，那么该系统的菜单编码格式便为 <code>test_online:m_xxx</code>。</p>\n<p>系统管理界面设计如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-management-interface.png\" alt=\"系统管理界面设计\" tabindex=\"0\"><figcaption>系统管理界面设计</figcaption></figure>\n<h4> 菜单管理</h4>\n<p>新权限系统首先对菜单进行了分类，分别是 <code>目录</code>、<code>菜单</code> 和 <code>操作</code>，示意如下图</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-menu.png\" alt=\"菜单管理界面\" tabindex=\"0\"><figcaption>菜单管理界面</figcaption></figure>\n<p>它们分别代表的含义是：</p>\n<ul>\n<li><strong>目录</strong>：指的是应用系统中最顶部的一级目录，通常在系统 Logo 的右边</li>\n<li><strong>菜单</strong>：指的是应用系统左侧的多层级菜单，通常在系统 Logo 的下面，也是最常用的菜单结构</li>\n<li><strong>操作</strong>：指页面中的按钮、接口等一系列可以定义为操作或页面元素的部分。</li>\n</ul>\n<p>菜单管理界面设计如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-menu-management-interface.png\" alt=\"菜单管理界面设计\" tabindex=\"0\"><figcaption>菜单管理界面设计</figcaption></figure>\n<p>菜单权限数据的使用，也提供两种方式：</p>\n<ul>\n<li><strong>动态菜单模式</strong>：这种模式下，菜单的增删完全由权限系统接管。也就是说在权限系统增加菜单，应用系统会同步增加。这种模式好处是修改菜单无需项目上线。</li>\n<li><strong>静态菜单模式</strong>：菜单的增删由应用系统的前端控制，权限系统只控制访问权限。这种模式下，权限系统只能标识出用户是否拥有当前菜单的权限，而具体的显示控制是由前端根据权限数据来决定。</li>\n</ul>\n<h3> 角色与用户管理</h3>\n<p>角色与用户管理都是可以直接改变用户权限的核心模块，整个设计思路如下图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/role-and-user-management.png\" alt=\"角色与用户管理模块设计\" tabindex=\"0\"><figcaption>角色与用户管理模块设计</figcaption></figure>\n<p>这个模块设计重点是需要考虑到批量操作。无论是通过角色关联用户，还是给用户批量增加/删除/重置权限，批量操作的场景都是系统需要设计好的。</p>\n<h3> 权限申请</h3>\n<p>除了给其他用户添加权限外，新权限系统同时支持了用户自主申请权限。这个模块除了常规的审批流（申请、审批、查看）等，有一个比较特别的功能，就是如何让用户能选对自己要的权限。所以在该模块的设计上，除了直接选择角色外，还支持通过菜单/数据权限点，反向选择角色，如下图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/permission-application.png\" alt=\"权限申请界面\" tabindex=\"0\"><figcaption>权限申请界面</figcaption></figure>\n<h3> 操作日志</h3>\n<p>系统操作日志会分为两大类：</p>\n<ol>\n<li><strong>操作流水日志</strong>：用户可看、可查的关键操作日志</li>\n<li><strong>服务 Log 日志</strong>：系统服务运行过程中产生的 Log 日志,其中，服务 Log 日志信息量大于操作流水日志，但是不方便搜索查看。所以权限系统需要提供操作流水日志功能。</li>\n</ol>\n<p>在新权限系统中，用户所有的操作可以分为三类，分别为新增、更新、删除。所有的模块也可枚举，例如用户管理、角色管理、菜单管理等。明确这些信息后，那么一条日志就可以抽象为：什么人(Who)在什么时间(When)对哪些人(Target)的哪些模块做了哪些操作。<br>\n这样把所有的记录都入库，就可以方便的进行日志的查看和筛选了。</p>\n<h2> 总结与展望</h2>\n<p>至此，新权限系统的核心设计思路与模块都已介绍完成，新系统在转转内部有大量的业务接入使用，权限管理相比以前方便了许多。权限系统作为每家公司的一个基础系统，灵活且完备的设计可以助力日后业务的发展更加高效。</p>\n<p>后续两篇：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/hFTDckfxhSnoM_McP18Vkg\" target=\"_blank\" rel=\"noopener noreferrer\">转转统一权限系统的设计与实现（后端实现篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/a_P4JAwxgunhfmJvpBnWYA\" target=\"_blank\" rel=\"noopener noreferrer\">转转统一权限系统的设计与实现（前端实现篇）</a></li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>选择合适的权限模型：<a href=\"https://docs.authing.cn/v2/guides/access-control/choose-the-right-access-control-model.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.authing.cn/v2/guides/access-control/choose-the-right-access-control-model.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/rbac.png",
      "date_published": "2022-08-15T07:12:39.000Z",
      "date_modified": "2023-10-26T22:49:28.000Z",
      "authors": [],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "应用层常见协议总结（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/application-layer-protocol.html",
      "id": "https://javaguide.cn/cs-basics/network/application-layer-protocol.html",
      "summary": "HTTP:超文本传输协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。 HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。",
      "content_html": "<h2> HTTP:超文本传输协议</h2>\n<p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</p>\n<p>HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/450px-HTTP-Header.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>\n<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>\n<h2> Websocket：全双工通信协议</h2>\n<p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p>\n<p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。</p>\n<p>WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png\" alt=\"Websocket 示意图\" tabindex=\"0\"><figcaption>Websocket 示意图</figcaption></figure>\n<p>下面是 WebSocket 的常见应用场景：</p>\n<ul>\n<li>视频弹幕</li>\n<li>实时消息推送，详见<a href=\"https://javaguide.cn/system-design/web-real-time-message-push.html\" target=\"_blank\" rel=\"noopener noreferrer\">Web 实时消息推送详解</a>这篇文章</li>\n<li>实时游戏对战</li>\n<li>多用户协同编辑</li>\n<li>社交聊天</li>\n<li>……</li>\n</ul>\n<p>WebSocket 的工作过程可以分为以下几个步骤：</p>\n<ol>\n<li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示要求升级协议为 WebSocket；</li>\n<li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，<code>Connection: Upgrade</code>和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示成功升级到 WebSocket 协议。</li>\n<li>客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li>\n<li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。</li>\n</ol>\n<p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p>\n<h2> SMTP:简单邮件传输(发送)协议</h2>\n<p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，是一种用于发送电子邮件的协议</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/what-is-smtp.png\" alt=\"SMTP 协议\" tabindex=\"0\"><figcaption>SMTP 协议</figcaption></figure>\n<p>注意 ⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>\n<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>\n<ol>\n<li>电子邮件的发送过程</li>\n<li>如何判断邮箱是真正存在的？</li>\n</ol>\n<p><strong>电子邮件的发送过程？</strong></p>\n<p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p>\n<ol>\n<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。</li>\n<li>163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。</li>\n<li>qq 邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>\n</ol>\n<p><strong>如何判断邮箱是真正存在的？</strong></p>\n<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>\n<ol>\n<li>查找邮箱域名对应的 SMTP 服务器地址</li>\n<li>尝试与服务器建立连接</li>\n<li>连接成功后尝试向需要验证的邮箱发送邮件</li>\n<li>根据返回结果判定邮箱地址的真实性</li>\n</ol>\n<p>推荐几个在线邮箱是否有效检测工具：</p>\n<ol>\n<li><a href=\"https://verify-email.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://verify-email.org/</a></li>\n<li><a href=\"http://tool.chacuo.net/mailverify\" target=\"_blank\" rel=\"noopener noreferrer\">http://tool.chacuo.net/mailverify</a></li>\n<li><a href=\"https://www.emailcamel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.emailcamel.com/</a></li>\n</ol>\n<h2> POP3/IMAP:邮件接收的协议</h2>\n<p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong> 即可（二者也是基于 TCP 协议）。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是 POP3/IMAP。</strong></p>\n<p>IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</p>\n<h2> FTP:文件传输协议</h2>\n<p><strong>FTP 协议</strong> 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</p>\n<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>\n<blockquote>\n<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>\n<ol>\n<li>控制连接：用于传送控制信息（命令和响应）</li>\n<li>数据连接：用于数据传送；</li>\n</ol>\n<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/ftp.png\" alt=\"FTP工作过程\" tabindex=\"0\"><figcaption>FTP工作过程</figcaption></figure>\n<p>注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。</p>\n<h2> Telnet:远程登陆协议</h2>\n<p><strong>Telnet 协议</strong> 基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/Telnet_is_vulnerable_to_eavesdropping-2.png\" alt=\"Telnet:远程登陆协议\" tabindex=\"0\"><figcaption>Telnet:远程登陆协议</figcaption></figure>\n<h2> SSH:安全的网络传输协议</h2>\n<p><strong>SSH（Secure Shell）</strong> 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>\n<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。</p>\n<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/ssh-client-server.png\" alt=\"SSH:安全的网络传输协议\" tabindex=\"0\"><figcaption>SSH:安全的网络传输协议</figcaption></figure>\n<h2> RTP:实时传输协议</h2>\n<p>RTP（Real-time Transport Protocol，实时传输协议）通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</p>\n<p>RTP 协议分为两种子协议：</p>\n<ul>\n<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：传输具有实时特性的数据。</li>\n<li><strong>RTCP（RTP Control Protocol，RTP 控制协议）</strong>：提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包</li>\n</ul>\n<h2> DNS:域名系统</h2>\n<p>DNS（Domain Name System，域名管理系统）基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png\" alt=\"DNS:域名系统\" tabindex=\"0\"><figcaption>DNS:域名系统</figcaption></figure>\n<h2> 参考</h2>\n<ul>\n<li>《计算机网络自顶向下方法》（第七版）</li>\n<li>RTP 协议介绍:<a href=\"https://mthli.xyz/rtp-introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">https://mthli.xyz/rtp-introduction/</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/450px-HTTP-Header.png",
      "date_published": "2022-08-14T09:10:17.000Z",
      "date_modified": "2023-12-01T04:42:42.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "TCP 传输可靠性保障（传输层）",
      "url": "https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html",
      "id": "https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html",
      "summary": "TCP 如何保证传输的可靠性？ 基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。 校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。 流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。 拥塞控制 : 当网络拥塞时，减少数据的发送。",
      "content_html": "<h2> TCP 如何保证传输的可靠性？</h2>\n<ol>\n<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>\n<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>\n<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85\" target=\"_blank\" rel=\"noopener noreferrer\">已丢失</a>并进行重传。</li>\n<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>\n<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>\n</ol>\n<h2> TCP 如何实现流量控制？</h2>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>\n<p>这里需要注意的是（常见误区）：</p>\n<ul>\n<li>发送端不等同于客户端</li>\n<li>接收端不等同于服务端</li>\n</ul>\n<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>\n<p><strong>TCP 发送窗口可以划分成四个部分</strong>：</p>\n<ol>\n<li>已经发送并且确认的 TCP 段（已经发送并确认）；</li>\n<li>已经发送但是没有确认的 TCP 段（已经发送未确认）；</li>\n<li>未发送但是接收方准备接收的 TCP 段（可以发送）；</li>\n<li>未发送并且接收方也并未准备接受的 TCP 段（不可发送）。</li>\n</ol>\n<p><strong>TCP 发送窗口结构图示</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-send-window.png\" alt=\"TCP发送窗口结构\" tabindex=\"0\"><figcaption>TCP发送窗口结构</figcaption></figure>\n<ul>\n<li><strong>SND.WND</strong>：发送窗口。</li>\n<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>\n<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>\n</ul>\n<p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>\n<p><strong>TCP 接收窗口可以划分成三个部分</strong>：</p>\n<ol>\n<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>\n<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>\n<li>不可接收且不允许发送方发送 TCP 段（不可接收）。</li>\n</ol>\n<p><strong>TCP 接收窗口结构图示</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-receive-window.png\" alt=\"TCP接收窗口结构\" tabindex=\"0\"><figcaption>TCP接收窗口结构</figcaption></figure>\n<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>\n<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>\n<h2> TCP 的拥塞控制是怎么实现的？</h2>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-congestion-control.png\" alt=\"TCP的拥塞控制\" tabindex=\"0\"><figcaption>TCP的拥塞控制</figcaption></figure>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>\n<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<h2> ARQ 协议了解吗?</h2>\n<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>\n<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>\n<h3> 停止等待 ARQ 协议</h3>\n<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>\n<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>\n<p><strong>1) 无差错情况:</strong></p>\n<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong></p>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong>：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>\n<li><strong>确认迟到</strong>：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>\n</ul>\n<h3> 连续 ARQ 协议</h3>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>\n<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h2> Reference</h2>\n<ol>\n<li>《计算机网络（第 7 版）》</li>\n<li>《图解 HTTP》</li>\n<li><a href=\"https://www.9tut.com/tcp-and-udp-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.9tut.com/tcp-and-udp-tutorial</a></li>\n<li><a href=\"https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md</a></li>\n<li>TCP Flow Control—<a href=\"https://www.brianstorti.com/tcp-flow-control/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.brianstorti.com/tcp-flow-control/</a></li>\n<li>TCP 流量控制(Flow Control)：<a href=\"https://notfalse.net/24/tcp-flow-control\" target=\"_blank\" rel=\"noopener noreferrer\">https://notfalse.net/24/tcp-flow-control</a></li>\n<li>TCP 之滑动窗口原理 : <a href=\"https://cloud.tencent.com/developer/article/1857363\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1857363</a></li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-send-window.png",
      "date_published": "2022-08-14T09:10:17.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "《计算机网络》（谢希仁）内容总结",
      "url": "https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html",
      "id": "https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html",
      "summary": "本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的《计算机网络》第七版这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。",
      "content_html": "<p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的<a href=\"https://www.elias.ltd/usr/local/etc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《计算机网络》第七版</a>这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/fb5d8645cd55484ab0177f25a13e97db~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>相关问题：<a href=\"https://www.zhihu.com/question/327872966\" target=\"_blank\" rel=\"noopener noreferrer\">如何评价谢希仁的计算机网络（第七版）？ - 知乎</a> 。</p>\n<h2> 1. 计算机网络概述</h2>\n<h3> 1.1. 基本术语</h3>\n<ol>\n<li><strong>结点 （node）</strong>：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>\n<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>\n<li><strong>主机（host）</strong>：连接在因特网上的计算机。</li>\n<li><strong>ISP（Internet Service Provider）</strong>：因特网服务提供者（提供商）。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/e77e26123d404d438d0c5943e3c65893~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"ISP (Internet Service Provider) Definition\" tabindex=\"0\"><figcaption>ISP (Internet Service Provider) Definition</figcaption></figure>\n<ol start=\"5\">\n<li><strong>IXP（Internet eXchange Point）</strong>：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/7f9a6ddaa09441ceac11cb77f7a69d8f~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"IXP Traffic Levels During the Stratos Skydive — RIPE Labs\" tabindex=\"0\"><figcaption>IXP Traffic Levels During the Stratos Skydive — RIPE Labs</figcaption></figure>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p>\n<ol start=\"6\">\n<li><strong>RFC(Request For Comments)</strong>：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>\n<li><strong>广域网 WAN（Wide Area Network）</strong>：任务是通过长距离运送主机发送的数据。</li>\n<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>\n<li><strong>局域网 LAN（Local Area Network）</strong>：学校或企业大多拥有多个互连的局域网。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/eb48d21b2e984a63a26250010d7adac4~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado\" tabindex=\"0\"><figcaption>MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado</figcaption></figure>\n<p style=\"text-align:center;font-size:13px;color:gray\">http://conexionesmanwman.blogspot.com/</p>\n<ol start=\"10\">\n<li><strong>个人区域网 PAN（Personal Area Network）</strong>：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/54bd7b420388494fbe917e3c9c13f1a7~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"Advantages and disadvantages of personal area network (PAN) - IT Release\" tabindex=\"0\"><figcaption>Advantages and disadvantages of personal area network (PAN) - IT Release</figcaption></figure>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p>\n<ol start=\"12\">\n<li><strong>分组（packet ）</strong>：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>\n<li><strong>存储转发（store and forward ）</strong>：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/addb6b2211444a4da9e0ffc129dd444f~tplv-k3u1fbpfcp-zoom-1.gif\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ol start=\"14\">\n<li><strong>带宽（bandwidth）</strong>：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>\n<li><strong>吞吐量（throughput ）</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>\n</ol>\n<h3> 1.2. 重要知识点总结</h3>\n<ol>\n<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>\n<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>\n<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>\n<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>\n<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>\n<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>\n<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>\n<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>\n<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>\n<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/acec0fa44041449b8088872dcd7c0b3a~tplv-k3u1fbpfcp-zoom-1.gif\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>\n<h2> 2. 物理层（Physical Layer）</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/cf1bfdd36e5f4bde94aea44bbe7a6f8a~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"物理层\" tabindex=\"0\"><figcaption>物理层</figcaption></figure>\n<h3> 2.1. 基本术语</h3>\n<ol>\n<li><strong>数据（data）</strong>：运送消息的实体。</li>\n<li><strong>信号（signal）</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>\n<li><strong>码元（ code）</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>\n<li><strong>单工（simplex ）</strong>：只能有一个方向的通信而没有反方向的交互。</li>\n<li><strong>半双工（half duplex ）</strong>：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>\n<li><strong>全双工（full duplex）</strong>：通信的双方可以同时发送和接收信息。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/b1f02095b7c34eafb3c255ee81f58c2a~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ol start=\"7\">\n<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/f939342f543046459ffabdc476f7bca4~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ol start=\"8\">\n<li><strong>奈氏准则</strong>：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>\n<li><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>\n<li><strong>基带信号（baseband signal）</strong>：来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>\n<li><strong>带通（频带）信号（bandpass signal）</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>\n<li><strong>调制（modulation ）</strong>：对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>\n<li><strong>信噪比（signal-to-noise ratio ）</strong>：指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>\n<li><strong>信道复用（channel multiplexing ）</strong>：指多个用户共享同一个信道。（并不一定是同时）。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/5d9bf7b3db324ae7a88fcedcbace45d8~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"信道复用技术\" tabindex=\"0\"><figcaption>信道复用技术</figcaption></figure>\n<ol start=\"15\">\n<li><strong>比特率（bit rate ）</strong>：单位时间（每秒）内传送的比特数。</li>\n<li><strong>波特率（baud rate）</strong>：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>\n<li><strong>复用（multiplexing）</strong>：共享信道的方法。</li>\n<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong>：非对称数字用户线。</li>\n<li><strong>光纤同轴混合网（HFC 网）</strong>：在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>\n</ol>\n<h3> 2.2. 重要知识点总结</h3>\n<ol>\n<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>\n<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>\n<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li>\n<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>\n<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>\n<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>\n<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>\n<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>\n<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>\n</ol>\n<h3> 2.3. 补充</h3>\n<h4> 2.3.1. 物理层主要做啥？</h4>\n<p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p>\n<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>\n<h4> 2.3.2. 几种常用的信道复用技术</h4>\n<ol>\n<li><strong>频分复用(FDM)</strong>：所有用户在同样的时间占用不同的带宽资源。</li>\n<li><strong>时分复用（TDM）</strong>：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>\n<li><strong>统计时分复用 (Statistic TDM)</strong>：改进的时分复用，能够明显提高信道的利用率。</li>\n<li><strong>码分复用(CDM)</strong>：用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>\n<li><strong>波分复用( WDM)</strong>：波分复用就是光的频分复用。</li>\n</ol>\n<h4> 2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4>\n<p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>\n<h2> 3. 数据链路层（Data Link Layer）</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/83ec6dafc8c14ca185bafb656d86f0b2~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"数据链路层\" tabindex=\"0\"><figcaption>数据链路层</figcaption></figure>\n<h3> 3.1. 基本术语</h3>\n<ol>\n<li><strong>链路（link）</strong>：一个结点到相邻结点的一段物理链路。</li>\n<li><strong>数据链路（data link）</strong>：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li>\n<li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong>：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li>\n<li><strong>帧（frame）</strong>：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>\n<li><strong>MTU（Maximum Transfer Uint ）</strong>：最大传送单元。帧的数据部分的的长度上限。</li>\n<li><strong>误码率 BER（Bit Error Rate ）</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>\n<li><strong>PPP（Point-to-Point Protocol ）</strong>：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：<br>\n<img src=\"https://oss.javaguide.cn/p3-juejin/6b0310d3103c4149a725a28aaf001899~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"PPP\"></li>\n<li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong>：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/057b83e7ec5b4c149e56255a3be89141~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"ARP (Address Resolution Protocol) explained\" tabindex=\"0\"><figcaption>ARP (Address Resolution Protocol) explained</figcaption></figure>\n<ol start=\"9\">\n<li><strong>网桥（bridge）</strong>：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>\n<li><strong>交换机（switch ）</strong>：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>\n</ol>\n<h3> 3.2. 重要知识点总结</h3>\n<ol>\n<li>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>\n<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>\n<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>\n<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>\n<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>\n<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>\n<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>\n<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>\n<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>\n<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</li>\n<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>\n<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>\n</ol>\n<h3> 3.3. 补充</h3>\n<ol>\n<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>\n<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>\n<li>以太网的 MAC 层硬件地址</li>\n<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>\n</ol>\n<h2> 4. 网络层（Network Layer）</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/775dc8136bec486aad4f1182c68f24cd~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"网络层\" tabindex=\"0\"><figcaption>网络层</figcaption></figure>\n<h3> 4.1. 基本术语</h3>\n<ol>\n<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>\n<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>\n<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>\n<li><strong>ICMP（Internet Control Message Protocol ）</strong>：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>\n<li><strong>子网掩码（subnet mask ）</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>\n<li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>\n<li><strong>默认路由（default route）</strong>：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>\n<li><strong>路由选择算法（Virtual Circuit）</strong>：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>\n</ol>\n<h3> 4.2. 重要知识点总结</h3>\n<ol>\n<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责</strong></li>\n<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>\n<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>\n<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>\n<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></li>\n<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>\n<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li>\n<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>\n<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>\n<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>\n</ol>\n<h2> 5. 传输层（Transport Layer）</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/9fe85e137e7f4f03a580512200a59609~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"传输层\" tabindex=\"0\"><figcaption>传输层</figcaption></figure>\n<h3> 5.1. 基本术语</h3>\n<ol>\n<li><strong>进程（process）</strong>：指计算机中正在运行的程序实体。</li>\n<li><strong>应用进程互相通信</strong>：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>\n<li><strong>传输层的复用与分用</strong>：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>\n<li><strong>TCP（Transmission Control Protocol）</strong>：传输控制协议。</li>\n<li><strong>UDP（User Datagram Protocol）</strong>：用户数据报协议。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/b136e69e0b9b426782f77623dcf098bd~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"TCP和UDP\" tabindex=\"0\"><figcaption>TCP和UDP</figcaption></figure>\n<ol start=\"6\">\n<li><strong>端口（port）</strong>：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>\n<li><strong>停止等待协议（stop-and-wait）</strong>：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>\n<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>\n<li><strong>拥塞控制</strong>：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>\n</ol>\n<h3> 5.2. 重要知识点总结</h3>\n<ol>\n<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>\n<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>\n<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>\n<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>\n<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>\n<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>\n<li>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</li>\n<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>\n<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>\n<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></li>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>\n<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>\n<li>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</li>\n<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>\n<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>\n<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>\n<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>\n<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>\n<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>\n<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>\n</ol>\n<h3> 5.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>端口和套接字的意义</li>\n<li>UDP 和 TCP 的区别以及两者的应用场景</li>\n<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>\n<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>\n<li>TCP 的三次握手，四次挥手机制</li>\n</ol>\n<h2> 6. 应用层（Application Layer）</h2>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/0f13f0ee13b24af7bdddf56162eb6602~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"应用层\" tabindex=\"0\"><figcaption>应用层</figcaption></figure>\n<h3> 6.1. 基本术语</h3>\n<ol>\n<li><strong>域名系统（DNS）</strong>：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener noreferrer\">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/e7da4b07947f4c0094d46dc96a067df0~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p style=\"text-align:right;font-size:12px\">https://www.seobility.net/en/wiki/HTTP_headers</p>\n<ol start=\"2\">\n<li><strong>文件传输协议（FTP）</strong>：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：\"下载\"（Download）和\"上传\"（Upload）。 \"下载\"文件就是从远程主机拷贝文件至自己的计算机上；\"上传\"文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/f3f2caaa361045a38fb89bb9fee15bd3~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"FTP工作过程\" tabindex=\"0\"><figcaption>FTP工作过程</figcaption></figure>\n<ol start=\"3\">\n<li><strong>简单文件传输协议（TFTP）</strong>：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>\n<li><strong>远程终端协议（TELNET）</strong>：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>\n<li><strong>万维网（WWW）</strong>：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，\"环球网\"等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>\n<li><strong>万维网的大致工作工程：</strong></li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/ba628fd37fdc4ba59c1a74eae32e03b1~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"万维网的大致工作工程\" tabindex=\"0\"><figcaption>万维网的大致工作工程</figcaption></figure>\n<ol start=\"7\">\n<li><strong>统一资源定位符（URL）</strong>：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>\n<li><strong>超文本传输协议（HTTP）</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>\n</ol>\n<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/8e3efca026654874bde8be88c96e1783~tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<ol start=\"10\">\n<li><strong>代理服务器（Proxy Server）</strong>：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>\n<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/2bdccb760474435aae52559f2ef9652f~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"一个电子邮件被发送的过程\" tabindex=\"0\"><figcaption>一个电子邮件被发送的过程</figcaption></figure>\n<p style=\"text-align:right;font-size:12px\">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/</p>\n<ol start=\"11\">\n<li>\n<p><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</p>\n</li>\n<li>\n<p><strong>垂直搜索引擎</strong>：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p>\n</li>\n<li>\n<p><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p>\n</li>\n<li>\n<p><strong>目录索引</strong>：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p>\n</li>\n</ol>\n<h3> 6.2. 重要知识点总结</h3>\n<ol>\n<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>\n<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>\n<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>\n<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>\n</ol>\n<h3> 6.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>应用层的常见协议（重点关注 HTTP 协议）</li>\n<li>域名系统-从域名解析出 IP 地址</li>\n<li>访问一个网站大致的过程</li>\n<li>系统调用和应用编程接口概念</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/p3-juejin/fb5d8645cd55484ab0177f25a13e97db~tplv-k3u1fbpfcp-zoom-1.png",
      "date_published": "2022-08-13T15:23:13.000Z",
      "date_modified": "2023-10-10T06:43:53.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "TCP 三次握手和四次挥手（传输层）",
      "url": "https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html",
      "id": "https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html",
      "summary": "为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。 建立连接-TCP 三次握手 TCP 三次握手图解 建立一个 TCP 连接需要“三次握手”，缺一不可： 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认； 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。",
      "content_html": "<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>\n<h2> 建立连接-TCP 三次握手</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png\" alt=\"TCP 三次握手图解\" tabindex=\"0\"><figcaption>TCP 三次握手图解</figcaption></figure>\n<p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>\n<ul>\n<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>\n<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>\n<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li>\n</ul>\n<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>\n<h3> 为什么要三次握手?</h3>\n<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>\n<ol>\n<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>\n<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>\n<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>\n</ol>\n<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>\n<p>更详细的解答可以看这个：<a href=\"https://www.zhihu.com/question/24853633/answer/115173386\" target=\"_blank\" rel=\"noopener noreferrer\">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎</a> 。</p>\n<h3> 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3>\n<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>\n<blockquote>\n<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h2> 断开连接-TCP 四次挥手</h2>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png\" alt=\"TCP 四次挥手图解\" tabindex=\"0\"><figcaption>TCP 四次挥手图解</figcaption></figure>\n<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>\n<ol>\n<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>\n<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>\n<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>\n<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>\n</ol>\n<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>\n<h3> 为什么要四次挥手？</h3>\n<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后。</p>\n<ol>\n<li><strong>第一次挥手</strong>：A 说“我没啥要说的了”</li>\n<li><strong>第二次挥手</strong>：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>\n<li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>\n<li><strong>第四次挥手</strong>：A 回答“知道了”，这样通话才算结束。</li>\n</ol>\n<h3> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3>\n<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>\n<h3> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3>\n<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>\n<h3> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3>\n<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>\n<blockquote>\n<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>\n</blockquote>\n<h2> 参考</h2>\n<ul>\n<li>\n<p>《计算机网络（第 7 版）》</p>\n</li>\n<li>\n<p>《图解 HTTP》</p>\n</li>\n<li>\n<p>TCP and UDP Tutorial：<a href=\"https://www.9tut.com/tcp-and-udp-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.9tut.com/tcp-and-udp-tutorial</a></p>\n</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png",
      "date_published": "2022-08-13T14:50:48.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "JMM（Java 内存模型）详解",
      "url": "https://javaguide.cn/java/concurrent/jmm.html",
      "id": "https://javaguide.cn/java/concurrent/jmm.html",
      "summary": "JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。 要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！ 从 CPU 缓存模型说起 为什么要弄一个 CPU 高速缓存呢？ 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。",
      "content_html": "<p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<p>要想理解透彻 JMM（Java 内存模型），我们先要从 <strong>CPU 缓存模型和指令重排序</strong> 说起！</p>\n<h2> 从 CPU 缓存模型说起</h2>\n<p><strong>为什么要弄一个 CPU 高速缓存呢？</strong> 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>\n<p>我们甚至可以把 <strong>内存看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>\n<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>\n<p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。</p>\n<blockquote>\n<p><strong>🐛 修正（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1848\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1848</a>）</strong>：对 CPU 缓存模型绘图不严谨的地方进行完善。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png\" alt=\"CPU 缓存模型示意图\" tabindex=\"0\"><figcaption>CPU 缓存模型示意图</figcaption></figure>\n<p>现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache。有些 CPU 可能还有 L4 Cache，这里不做讨论，并不常见</p>\n<p><strong>CPU Cache 的工作方式：</strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p>\n<p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 <a href=\"https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener noreferrer\">MESI 协议</a>）或者其他手段来解决。</strong> 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache-protocol.png\" alt=\"缓存一致性协议\" tabindex=\"0\"><figcaption>缓存一致性协议</figcaption></figure>\n<p>我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。</p>\n<p>操作系统通过 <strong>内存模型（Memory Model）</strong> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p>\n<h2> 指令重排序</h2>\n<p>说完了 CPU 缓存模型，我们再来看看另外一个比较重要的概念 <strong>指令重排序</strong> 。</p>\n<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>\n<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>\n<p>常见的指令重排序有下面 2 种情况：</p>\n<ul>\n<li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>\n<li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n</ul>\n<p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>\n<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>\n<blockquote>\n<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>\n</blockquote>\n<h2> JMM(Java Memory Model)</h2>\n<h3> 什么是 JMM？为什么需要 JMM？</h3>\n<p>Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型 <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/CommunityReview.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《JSR-133：Java Memory Model and Thread Specification》</a> 。</p>\n<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>\n<p>这只是 JMM 存在的其中一个原因。实际上，对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>\n<p><strong>为什么要遵守这些并发相关的原则和规范呢？</strong> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题。</p>\n<p>JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>\n<h3> JMM 是如何抽象线程和主内存之间的关系？</h3>\n<p><strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p>\n<p>在 JDK1.2 之前，Java 的内存模型实现总是从 <strong>主存</strong> （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>\n<p>这和我们上面讲到的 CPU 缓存模型非常相似。</p>\n<p><strong>什么是主内存？什么是本地内存？</strong></p>\n<ul>\n<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>\n<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>\n</ul>\n<p>Java 内存模型的抽象示意图如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png\" alt=\"JMM(Java 内存模型)\" tabindex=\"0\"><figcaption>JMM(Java 内存模型)</figcaption></figure>\n<p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p>\n<ol>\n<li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li>\n<li>线程 2 到主存中读取对应的共享变量的值。</li>\n</ol>\n<p>也就是说，JMM 为共享变量提供了可见性的保障。</p>\n<p>不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：</p>\n<ol>\n<li>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</li>\n<li>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</li>\n</ol>\n<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：</p>\n<ul>\n<li><strong>锁定（lock）</strong>: 作用于主内存中的变量，将他标记为一个线程独享变量。</li>\n<li><strong>解锁（unlock）</strong>: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li>\n<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>\n<li><strong>load(载入)</strong>：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>\n<li><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>\n<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>\n<li><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>\n</ul>\n<p>除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</p>\n<ul>\n<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li>\n<li>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</li>\n<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>\n<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>\n<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>\n<li>……</li>\n</ul>\n<h3> Java 内存区域和 JMM 有何区别？</h3>\n<p>这是一个比较常见的问题，很多初学者非常容易搞混。 <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong>：</p>\n<ul>\n<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>\n<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n</ul>\n<h3> happens-before 原则是什么？</h3>\n<p>happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文<a href=\"https://lamport.azurewebsites.net/pubs/time-clocks.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《Time，Clocks and the Ordering of Events in a Distributed System》</a>。在这篇论文中，Leslie Lamport 提出了<a href=\"https://writings.sh/post/logical-clocks\" target=\"_blank\" rel=\"noopener noreferrer\">逻辑时钟</a>的概念，这也成了第一个逻辑时钟算法 。在分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。<strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong></p>\n<p>上面提到的 happens-before 这个概念诞生的背景并不是重点，简单了解即可。</p>\n<p>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</p>\n<p><strong>为什么需要 happens-before 原则？</strong> happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：</p>\n<ul>\n<li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li>\n<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>\n</ul>\n<p>下面这张是 《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图，非常清晰。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/image-20220731155332375.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>了解了 happens-before 原则的设计思想，我们再来看看 JSR-133 对 happens-before 原则的定义：</p>\n<ul>\n<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>\n<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>\n</ul>\n<p>我们看下面这段代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>1 happens-before 2</li>\n<li>2 happens-before 3</li>\n<li>1 happens-before 3</li>\n</ul>\n<p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p>\n<p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p>\n<p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p>\n<h3> happens-before 常见规则有哪些？谈谈你的理解？</h3>\n<p>happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。</p>\n<ol>\n<li><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li>\n<li><strong>解锁规则</strong>：解锁 happens-before 于加锁；</li>\n<li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li>\n<li><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li>\n<li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</li>\n</ol>\n<p>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</p>\n<h3> happens-before 和 JMM 什么关系？</h3>\n<p>happens-before 与 JMM 的关系用《Java 并发编程的艺术》这本书中的一张图就可以非常好的解释清楚。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/image-20220731084604667.png\" alt=\"happens-before 与 JMM 的关系\" tabindex=\"0\"><figcaption>happens-before 与 JMM 的关系</figcaption></figure>\n<h2> 再看并发编程三个重要特性</h2>\n<h3> 原子性</h3>\n<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>\n<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>\n<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>\n<h3> 可见性</h3>\n<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>\n<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>\n<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3> 有序性</h3>\n<p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>\n<p>我们上面讲重排序的时候也提到过：</p>\n<blockquote>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n</blockquote>\n<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>\n<h2> 总结</h2>\n<ul>\n<li>Java 是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n<li>CPU 可以通过制定缓存一致协议（比如 <a href=\"https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener noreferrer\">MESI 协议</a>）来解决内存缓存不一致性问题。</li>\n<li>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</li>\n<li>你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n<li>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Java 并发编程的艺术》第三章 Java 内存模型</li>\n<li>《深入浅出 Java 多线程》：<a href=\"http://concurrent.redspider.group/RedSpider.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://concurrent.redspider.group/RedSpider.html</a></li>\n<li>Java 内存访问重排序的研究：<a href=\"https://tech.meituan.com/2014/09/23/java-memory-reordering.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.meituan.com/2014/09/23/java-memory-reordering.html</a></li>\n<li>嘿，同学，你要的 Java 内存模型 (JMM) 来了：<a href=\"https://xie.infoq.cn/article/739920a92d0d27e2053174ef2\" target=\"_blank\" rel=\"noopener noreferrer\">https://xie.infoq.cn/article/739920a92d0d27e2053174ef2</a></li>\n<li>JSR 133 (Java Memory Model) FAQ：<a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png",
      "date_published": "2022-08-04T13:00:03.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "RabbitMQ常见问题总结",
      "url": "https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html",
      "id": "https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html",
      "summary": "本篇文章由 JavaGuide 收集自网络，原出处不明。 RabbitMQ 是什么？ RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。",
      "content_html": "<blockquote>\n<p>本篇文章由 JavaGuide 收集自网络，原出处不明。</p>\n</blockquote>\n<h2> RabbitMQ 是什么？</h2>\n<p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p>\n<p>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p>\n<h2> RabbitMQ 特点?</h2>\n<ul>\n<li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>\n<li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li>\n<li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li>\n<li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li>\n<li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li>\n<li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li>\n<li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li>\n<li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li>\n</ul>\n<h2> RabbitMQ 核心概念？</h2>\n<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>\n<p>RabbitMQ 的整体模型架构如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/96388546.jpg\" alt=\"图1-RabbitMQ 的整体模型架构\" tabindex=\"0\"><figcaption>图1-RabbitMQ 的整体模型架构</figcaption></figure>\n<p>下面我会一一介绍上图中的一些概念。</p>\n<h3> Producer(生产者) 和 Consumer(消费者)</h3>\n<ul>\n<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>\n<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>\n</ul>\n<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>\n<h3> Exchange(交换器)</h3>\n<p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>\n<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将 RabbitMQ 中的交换器看作一个简单的实体。</p>\n<p><strong>RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的 Exchange 转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>\n<p>Exchange(交换器) 示意图如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/24007899.jpg\" alt=\"Exchange(交换器) 示意图\" tabindex=\"0\"><figcaption>Exchange(交换器) 示意图</figcaption></figure>\n<p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>\n<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>\n<p>Binding(绑定) 示意图：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/70553134.jpg\" alt=\"Binding(绑定) 示意图\" tabindex=\"0\"><figcaption>Binding(绑定) 示意图</figcaption></figure>\n<p>生产者将消息发送给交换器时，需要一个 RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如 fanout 类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>\n<h3> Queue(消息队列)</h3>\n<p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>\n<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p>\n<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>\n<h3> Broker（消息中间件的服务节点）</h3>\n<p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>\n<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从 Broker 中消费数据的整个流程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/67952922.jpg\" alt=\"消息队列的运转过程\" tabindex=\"0\"><figcaption>消息队列的运转过程</figcaption></figure>\n<p>这样图 1 中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>\n<h3> Exchange Types(交换器类型)</h3>\n<p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>\n<p><strong>1、fanout</strong></p>\n<p>fanout 类型的 Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>\n<p><strong>2、direct</strong></p>\n<p>direct 类型的 Exchange 路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/37008021.jpg\" alt=\"direct 类型交换器\" tabindex=\"0\"><figcaption>direct 类型交换器</figcaption></figure>\n<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为\"Info”或者\"debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>\n<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>\n<p><strong>3、topic</strong></p>\n<p>前面讲到 direct 类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>\n<ul>\n<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>\n<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>\n<li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/rabbitmq/73843.jpg\" alt=\"topic 类型交换器\" tabindex=\"0\"><figcaption>topic 类型交换器</figcaption></figure>\n<p>以上图为例：</p>\n<ul>\n<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li>\n<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>\n<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>\n<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li>\n<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>\n</ul>\n<p><strong>4、headers(不推荐)</strong></p>\n<p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>\n<h2> AMQP 是什么?</h2>\n<p>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p>\n<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>\n<p><strong>AMQP 协议的三层</strong>：</p>\n<ul>\n<li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>\n<li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>\n<li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li>\n</ul>\n<p><strong>AMQP 模型的三大组件</strong>：</p>\n<ul>\n<li><strong>交换器 (Exchange)</strong>：消息代理服务器中用于把消息路由到队列的组件。</li>\n<li><strong>队列 (Queue)</strong>：用来存储消息的数据结构，位于硬盘或内存中。</li>\n<li><strong>绑定 (Binding)</strong>：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>\n</ul>\n<h2> <strong>说说生产者 Producer 和消费者 Consumer?</strong></h2>\n<p><strong>生产者</strong> :</p>\n<ul>\n<li>消息生产者，就是投递消息的一方。</li>\n<li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li>\n</ul>\n<p><strong>消费者</strong>：</p>\n<ul>\n<li>消费消息，也就是接收消息的一方。</li>\n<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>\n</ul>\n<h2> 说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2>\n<ul>\n<li><strong>Broker</strong>：可以看做 RabbitMQ 的服务节点。一般情况下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>\n<li><strong>Queue</strong>：RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>\n<li><strong>Exchange</strong>：生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>\n</ul>\n<h2> 什么是死信队列？如何导致的？</h2>\n<p>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>\n<p><strong>导致的死信的几种原因</strong>：</p>\n<ul>\n<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li>\n<li>消息 TTL 过期。</li>\n<li>队列满了，无法再添加。</li>\n</ul>\n<h2> 什么是延迟队列？RabbitMQ 怎么实现延迟队列？</h2>\n<p>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>\n<p>RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：</p>\n<ol>\n<li>通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。</li>\n<li>在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。</li>\n</ol>\n<p>也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。</p>\n<h2> 什么是优先级队列？</h2>\n<p>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</p>\n<p>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p>\n<h2> RabbitMQ 有哪些工作模式？</h2>\n<ul>\n<li>简单模式</li>\n<li>work 工作模式</li>\n<li>pub/sub 发布订阅模式</li>\n<li>Routing 路由模式</li>\n<li>Topic 主题模式</li>\n</ul>\n<h2> RabbitMQ 消息怎么传输？</h2>\n<p>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。</p>\n<h2> <strong>如何保证消息的可靠性？</strong></h2>\n<p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p>\n<ul>\n<li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>\n<li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li>\n<li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li>\n</ul>\n<h2> 如何保证 RabbitMQ 消息的顺序性？</h2>\n<ul>\n<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li>\n<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li>\n</ul>\n<h2> 如何保证 RabbitMQ 高可用的？</h2>\n<p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<p><strong>单机模式</strong></p>\n<p>Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p>\n<p><strong>普通集群模式</strong></p>\n<p>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</p>\n<p>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>\n<p><strong>镜像集群模式</strong></p>\n<p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>\n<p>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>\n<h2> 如何解决消息队列的延时以及过期失效问题？</h2>\n<p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/rabbitmq/96388546.jpg",
      "date_published": "2022-08-02T10:06:55.000Z",
      "date_modified": "2023-09-19T04:03:55.000Z",
      "authors": [],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "有了 HTTP 协议，为什么还要有 RPC ？",
      "url": "https://javaguide.cn/distributed-system/rpc/http_rpc.html",
      "id": "https://javaguide.cn/distributed-system/rpc/http_rpc.html",
      "summary": "本文来自小白 debug投稿，原文：https://juejin.cn/post/7121882245605883934 。 我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？",
      "content_html": "<blockquote>\n<p>本文来自<a href=\"https://juejin.cn/user/4001878057422087\" target=\"_blank\" rel=\"noopener noreferrer\">小白 debug</a>投稿，原文：<a href=\"https://juejin.cn/post/7121882245605883934\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7121882245605883934</a> 。</p>\n</blockquote>\n<p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</p>\n<p>于是就到网上去搜。</p>\n<p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p>\n<p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p>\n<p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p>\n<h2> 从 TCP 聊起</h2>\n<p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p>\n<p>这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong> 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。</p>\n<p>类似下面这样。</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p>\n<p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"握手建立连接流程\" tabindex=\"0\"><figcaption>握手建立连接流程</figcaption></figure>\n<p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p>\n<p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？</p>\n<p>不行，这么用会有问题。</p>\n<h2> 使用纯裸 TCP 会有什么问题</h2>\n<p>八股文常背，TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/acb4508111cb47d8a3df6734d04818bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"TCP是什么\" tabindex=\"0\"><figcaption>TCP是什么</figcaption></figure>\n<p>这三个特点真的概括的 <strong>非常精辟</strong> ，这个八股文我们没白背。</p>\n<p>每个特点展开都能聊一篇文章，而今天我们需要关注的是 <strong>基于字节流</strong> 这一点。</p>\n<p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/b82d4fcdd0c4491e979856c93c1750d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"01二进制字节流\" tabindex=\"0\"><figcaption>01二进制字节流</figcaption></figure>\n<p>正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>\"夏洛\"和\"特烦恼\"</strong> 的时候，接收端收到的就是 <strong>\"夏洛特烦恼\"</strong> ，这时候接收端没发区分你是想要表达 <strong>\"夏洛\"+\"特烦恼\"</strong> 还是 <strong>\"夏洛特\"+\"烦恼\"</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/4e120d0f1152419585565f693e744a3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息对比\" tabindex=\"0\"><figcaption>消息对比</figcaption></figure>\n<p>这就是所谓的 <strong>粘包问题</strong>，之前也写过一篇专门的<a href=\"https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA\" target=\"_blank\" rel=\"noopener noreferrer\">文章</a>聊过这个问题。</p>\n<p>说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。</p>\n<p>于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/cb29659d4907446e9f70551c44c6369f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息边界长度标志\" tabindex=\"0\"><figcaption>消息边界长度标志</figcaption></figure>\n<p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p>\n<p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p>\n<p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p>\n<h2> HTTP 和 RPC</h2>\n<h3> RPC 其实是一种调用方式</h3>\n<p>我们回过头来看网络的分层图。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"四层网络协议\" tabindex=\"0\"><figcaption>四层网络协议</figcaption></figure>\n<p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p>\n<p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP调用\" tabindex=\"0\"><figcaption>HTTP调用</figcaption></figure>\n<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。</p>\n<p>举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC可以像调用本地方法那样调用远端方法\" tabindex=\"0\"><figcaption>RPC可以像调用本地方法那样调用远端方法</figcaption></figure>\n<p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p>\n<p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p>\n<p>到这里，我们回到文章标题的问题。</p>\n<h3> 那既然有 RPC 了，为什么还要有 HTTP 呢？</h3>\n<p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p>\n<p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p>\n<p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p>\n<p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser/Server (B/S)</strong> 的协议。</p>\n<p>也就是说在多年以前，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>\n<p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p>\n<p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p>\n<h3> HTTP 和 RPC 有什么区别</h3>\n<p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p>\n<h4> 服务发现</h4>\n<p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>\n<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>\n<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>\n<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>\n<h4> 底层连接形式</h4>\n<p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>\n<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"connection_pool\" tabindex=\"0\"><figcaption>connection_pool</figcaption></figure>\n<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>\n<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>\n<h4> 传输的内容</h4>\n<p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>\n<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>\n<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>\n<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"序列化和反序列化\" tabindex=\"0\"><figcaption>序列化和反序列化</figcaption></figure>\n<p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p>\n<p>我们可以随便截个图直观看下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/04e8a79ddb7247759df23f1132c01655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP报文\" tabindex=\"0\"><figcaption>HTTP报文</figcaption></figure>\n<p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p>\n<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/284c26bb7f2848889d1d9b95cf49decb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP原理\" tabindex=\"0\"><figcaption>HTTP原理</figcaption></figure>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/edb050d383c644e895e505253f1c4d90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC原理\" tabindex=\"0\"><figcaption>RPC原理</figcaption></figure>\n<p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>\n<p>那么问题又来了。</p>\n<h3> 为什么既然有了 HTTP2，还要有 RPC 协议？</h3>\n<p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p>\n<h2> 总结</h2>\n<ul>\n<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>\n<li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li>\n<li>从发展历史来说，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>\n<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>\n<li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png",
      "date_published": "2022-08-02T06:41:11.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Java并发常见面试题总结（下）",
      "url": "https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html",
      "id": "https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html",
      "summary": "JavaGuide官方知识星球 ThreadLocal ThreadLocal 有什么用？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？",
      "content_html": "<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiu.png\" alt=\"JavaGuide官方知识星球\" tabindex=\"0\"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>\n<h2> ThreadLocal</h2>\n<h3> ThreadLocal 有什么用？</h3>\n<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>\n<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>\n<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>\n<h3> 如何使用 ThreadLocal？</h3>\n<p>相信看了上面的解释，大家已经搞懂 <code>ThreadLocal</code> 类是个什么东西了。下面简单演示一下如何在项目中实际使用 <code>ThreadLocal</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果 :</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出中可以看出，虽然 <code>Thread-0</code> 已经改变了 <code>formatter</code> 的值，但 <code>Thread-1</code> 默认格式化值与初始化值相同，其他线程也一样。</p>\n<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ThreadLocal 原理了解吗？</h3>\n<p>从 <code>Thread</code>类源代码入手。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>\n<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>\n<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>\n<p><code>ThreadLocal</code> 数据结构如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png\" alt=\"ThreadLocal 数据结构\" tabindex=\"0\"><figcaption>ThreadLocal 数据结构</figcaption></figure>\n<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-local-inner-class.png\" alt=\"ThreadLocal内部类\" tabindex=\"0\"><figcaption>ThreadLocal内部类</figcaption></figure>\n<h3> ThreadLocal 内存泄露问题是怎么导致的？</h3>\n<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>\n<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>弱引用介绍：</strong></p>\n<blockquote>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<h2> 线程池</h2>\n<h3> 什么是线程池?</h3>\n<p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3> 为什么要用线程池？</h3>\n<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>\n<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>\n<ul>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h3> 如何创建线程池？</h3>\n<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>\n<figure><figcaption>通过构造方法实现</figcaption></figure>\n<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>\n<p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p>\n<ul>\n<li><strong><code>FixedThreadPool</code></strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>\n<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>\n<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>\n<li><strong><code>ScheduledThreadPool</code></strong>：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>\n</ul>\n<p>对应 <code>Executors</code> 工具类中的方法如图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-inner-threadpool.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 为什么不推荐使用内置线程池？</h3>\n<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>\n</blockquote>\n<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>\n<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>\n<ul>\n<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong>：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>\n<li><strong><code>CachedThreadPool</code></strong>：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>\n<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 线程池常见参数有哪些？如何解释？</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>\n<ul>\n<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</li>\n<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>\n<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>\n</ul>\n<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>\n<figure><figcaption>线程池各个参数的关系</figcaption></figure>\n<h3> 线程池的饱和策略有哪些？</h3>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>举个例子：Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略来配置线程池的时候，默认使用的是 <code>AbortPolicy</code>。在这种饱和策略下，如果队列满了，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用<code>CallerRunsPolicy</code>。<code>CallerRunsPolicy</code> 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 线程池常用的阻塞队列有哪些？</h3>\n<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>\n<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>\n<ul>\n<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li>\n<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3> 线程池处理任务的流程了解吗？</h3>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/图解线程池实现原理.png\" alt=\"图解线程池实现原理\" tabindex=\"0\"><figcaption>图解线程池实现原理</figcaption></figure>\n<ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>\n</ol>\n<h3> 如何给线程池命名？</h3>\n<p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>\n<p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p>\n<p>给线程池里的线程命名通常有下面两种方式：</p>\n<p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>2、自己实现 <code>ThreadFactory</code>。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 如何设定线程池的大小？</h3>\n<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>\n<blockquote>\n<p>上下文切换：</p>\n<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n</blockquote>\n<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>\n<ul>\n<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>\n<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>\n</ul>\n<p>有一个简单并且适用面比较广的公式：</p>\n<ul>\n<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>\n<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>\n</ul>\n<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>\n<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>\n<blockquote>\n<p>🌈 拓展一下（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1737\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1737</a>）：</p>\n<p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p>\n<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>\n<p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p>\n<p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</p>\n<p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p>\n</blockquote>\n<p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</p>\n<h3> 如何动态修改线程池的参数？</h3>\n<p>美团技术团队在<a href=\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 线程池实现原理及其在美团业务中的实践》</a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>\n<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><strong>为什么是这三个参数？</strong></p>\n<p>我在<a href=\"https://javaguide.cn/java/concurrent/java-thread-pool-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 线程池详解</a> 这篇文章中就说过这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p>\n<p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpoolexecutor-methods.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>\n<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p>\n<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/meituan-dynamically-configuring-thread-pool-parameters.png\" alt=\"动态配置线程池参数最终效果\" tabindex=\"0\"><figcaption>动态配置线程池参数最终效果</figcaption></figure>\n<p>还没看够？推荐 why 神的<a href=\"https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A\" target=\"_blank\" rel=\"noopener noreferrer\">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。</a>这篇文章，深度剖析，很不错哦！</p>\n<p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p>\n<ul>\n<li><strong><a href=\"https://github.com/opengoofy/hippo4j\" target=\"_blank\" rel=\"noopener noreferrer\">Hippo4j</a></strong>：异步线程池框架，支持线程池动态变更&amp;监控&amp;报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li>\n<li><strong><a href=\"https://github.com/dromara/dynamic-tp\" target=\"_blank\" rel=\"noopener noreferrer\">Dynamic TP</a></strong>：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li>\n</ul>\n<h3> 如何设计一个能够根据任务的优先级来执行的线程池？</h3>\n<p>这是一个常见的面试问题，本质其实还是在考察求职者对于线程池以及阻塞队列的掌握。</p>\n<p>我们上面也提到了，不同的线程池会选用不同的阻塞队列作为任务队列，比如<code>FixedThreadPool</code> 使用的是<code>LinkedBlockingQueue</code>（无界队列），由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p>\n<p>假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 <code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/common-parameters-of-threadpool-workqueue.jpg\" alt=\"ThreadPoolExecutor构造函数\" tabindex=\"0\"><figcaption>ThreadPoolExecutor构造函数</figcaption></figure>\n<p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 <code>PriorityQueue</code>，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，<code>PriorityQueue</code> 不支持阻塞操作。</p>\n<p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p>\n<ol>\n<li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li>\n<li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li>\n</ol>\n<p>不过，这存在一些风险和问题，比如：</p>\n<ul>\n<li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。</li>\n<li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。</li>\n<li>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</li>\n</ul>\n<p>对于 OOM 这个问题的解决比较简单粗暴，就是继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。</p>\n<p>饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</p>\n<p>对于性能方面的影响，是没办法避免的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的。</p>\n<h2> Future</h2>\n<h3> Future 类有什么用？</h3>\n<p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>\n<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>\n<ul>\n<li>取消任务；</li>\n<li>判断任务是否被取消;</li>\n<li>判断任务是否已经执行完成;</li>\n<li>获取任务执行结果。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p>\n<h3> Callable 和 Future 有什么关系？</h3>\n<p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p>\n<p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>\n<h3> CompletableFuture 类有什么用？</h3>\n<p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p>\n<p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>\n<p>下面我们来简单看看 <code>CompletableFuture</code> 类的定义。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>\n<p><code>CompletionStage</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>\n<figure><img src=\"https://oss.javaguide.cn/javaguide/image-20210902093026059.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> AQS</h2>\n<h3> AQS 是什么？</h3>\n<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/AQS.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p>\n<h3> AQS 的原理是什么？</h3>\n<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p>\n<p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>\n<p>CLH 队列结构如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/40cb932a64694262993907ebda6a0bfe~tplv-k3u1fbpfcp-zoom-1.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图（图源<a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 并发之 AQS 详解</a>）如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/CLH.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p>\n<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>\n<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>\n<h3> Semaphore 有什么用？</h3>\n<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>\n<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p>\n<p><code>Semaphore</code> 有两种模式：。</p>\n<ul>\n<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>\n<li><strong>非公平模式：</strong> 抢占式的。</li>\n</ul>\n<p><code>Semaphore</code> 对应的两个构造方法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>\n<p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p>\n<h3> Semaphore 的原理是什么？</h3>\n<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>\n<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CountDownLatch 有什么用？</h3>\n<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>\n<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>\n<h3> CountDownLatch 的原理是什么？</h3>\n<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>\n<h3> 用过 CountDownLatch 么？什么场景下用的？</h3>\n<p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>\n<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>\n<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>\n<p>伪代码是下面这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>有没有可以改进的地方呢？</strong></p>\n<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CyclicBarrier 有什么用？</h3>\n<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>\n<blockquote>\n<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>\n</blockquote>\n<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>\n<h3> CyclicBarrier 的原理是什么？</h3>\n<p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面我们结合源码来简单看看。</p>\n<p>1、<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中，<code>parties</code> 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>\n<p>2、当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>dowait(false, 0L)</code>方法源码分析如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 虚拟线程</h2>\n<p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<p>虽然目前面试中问的不多，但还是建议大家去简单了解一下，具体可以阅读这篇文章：<a href=\"/java/concurrent/virtual-thread.html\" target=\"blank\">虚拟线程极简入门</a> 。重点搞清楚虚拟线程和平台线程的关系以及虚拟线程的优势即可。</p>\n<h2> 参考</h2>\n<ul>\n<li>《深入理解 Java 虚拟机》</li>\n<li>《实战 Java 高并发程序设计》</li>\n<li>带你了解下 SynchronousQueue（并发队列专题）：<a href=\"https://juejin.cn/post/7031196740128768037\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7031196740128768037</a></li>\n<li>阻塞队列 — DelayedWorkQueue 源码分析：<a href=\"https://zhuanlan.zhihu.com/p/310621485\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/310621485</a></li>\n<li>Java 多线程（三）——FutureTask/CompletableFuture：<a href=\"https://www.cnblogs.com/iwehdio/p/14285282.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/iwehdio/p/14285282.html</a></li>\n<li>Java 并发之 AQS 详解：<a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/waterystone/p/4920797.html</a></li>\n<li>Java 并发包基石-AQS 详解：<a href=\"https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png",
      "date_published": "2022-07-30T10:58:06.000Z",
      "date_modified": "2023-10-15T12:01:30.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java SPI 机制详解",
      "url": "https://javaguide.cn/java/basis/spi.html",
      "id": "https://javaguide.cn/java/basis/spi.html",
      "summary": "本文来自 Kingshion 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。",
      "content_html": "<blockquote>\n<p>本文来自 <a href=\"https://github.com/jjx0708\" target=\"_blank\" rel=\"noopener noreferrer\">Kingshion</a> 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href=\"https://javaguide.cn/javaguide/contribution-guideline.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 贡献指南</a> 。</p>\n</blockquote>\n<p>在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。</p>\n<p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</strong></p>\n<h2> SPI 介绍</h2>\n<h3> 何谓 SPI?</h3>\n<p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>\n<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>\n<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> SPI 和 API 有什么区别？</h3>\n<p><strong>那 SPI 和 API 有啥区别？</strong></p>\n<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>\n<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>\n<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>\n<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>\n<h2> 实战演示</h2>\n<p>SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/image-20220723213306039-165858318917813.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>这就是依赖 SPI 机制实现的，那我们接下来就实现一个简易版本的日志框架。</p>\n<h3> Service Provider Interface</h3>\n<p>新建一个 Java 项目 <code>service-provider-interface</code> 目录结构如下：（注意直接新建 Java 项目就好了，不用新建 Maven 项目，Maven 项目会涉及到一些编译配置，如果有私服的话，直接 deploy 会比较方便，但是没有的话，在过程中可能会遇到一些奇怪的问题。）</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Logger</code> 接口，这个就是 SPI ， 服务提供者接口，后面的服务提供者就要针对这个接口进行实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接下来就是 <code>LoggerService</code> 类，这个主要是为服务使用者（调用方）提供特定功能的。这个类也是实现 Java SPI 机制的关键所在，如果存在疑惑的话可以先往后面继续看。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Main</code> 类（服务使用者，调用方），启动程序查看结果。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序结果：</p>\n<blockquote>\n<p>info 中没有发现 Logger 服务提供者<br>\ndebug 中没有发现 Logger 服务提供者</p>\n</blockquote>\n<p>此时我们只是空有接口，并没有为 <code>Logger</code> 接口提供任何的实现，所以输出结果中没有按照预期打印相应的结果。</p>\n<p>你可以使用命令或者直接使用 IDEA 将整个程序直接打包成 jar 包。</p>\n<h3> Service Provider</h3>\n<p>接下来新建一个项目用来实现 <code>Logger</code> 接口</p>\n<p>新建项目 <code>service-provider</code> 目录结构如下：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Logback</code> 类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将 <code>service-provider-interface</code> 的 jar 导入项目中。</p>\n<p>新建 lib 目录，然后将 jar 包拷贝过来，再添加到项目中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/523d5e25198444d3b112baf68ce49daetplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>再点击 OK 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/f4ba0aa71e9b4d509b9159892a220850tplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>接下来就可以在项目中导入 jar 包里面的一些类和方法了，就像 JDK 工具类导包一样的。</p>\n<p>实现 <code>Logger</code> 接口，在 <code>src</code> 目录下新建 <code>META-INF/services</code> 文件夹，然后新建文件 <code>edu.jiangxuan.up.spi.Logger</code> （SPI 的全类名），文件里面的内容是：<code>edu.jiangxuan.up.spi.service.Logback</code> （Logback 的全类名，即 SPI 的实现类的包名 + 类名）。</p>\n<p><strong>这是 JDK SPI 机制 ServiceLoader 约定好的标准。</strong></p>\n<p>这里先大概解释一下：Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>\n<p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p>\n<p>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个 jar 包就是服务提供方的实现。通常我们导入 maven 的 pom 依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven 公共仓库中，所以在需要使用的地方只能手动的添加到项目中。</p>\n<h3> 效果展示</h3>\n<p>为了更直观的展示效果，我这里再新建一个专门用来测试的工程项目：<code>java-spi-test</code></p>\n<p>然后先导入 <code>Logger</code> 的接口 jar 包，再导入具体的实现类的 jar 包。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/spi/image-20220723215812708-165858469599214.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>新建 Main 方法测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果如下：</p>\n<blockquote>\n<p>Logback info 打印日志：你好<br>\nLogback debug 打印日志：测试 Java SPI 机制</p>\n</blockquote>\n<p>说明导入 jar 包中的实现类生效了。</p>\n<p>如果我们不导入具体的实现类的 jar 包，那么此时程序运行的结果就会是：</p>\n<blockquote>\n<p>info 中没有发现 Logger 服务提供者<br>\ndebug 中没有发现 Logger 服务提供者</p>\n</blockquote>\n<p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和 服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改 <code>service-provider</code> 项目中针对 <code>Logger</code> 接口的具体实现就可以了，只需要换一个 jar 包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J 原理吗？</p>\n<p>如果某一天需求变更了，此时需要将日志输出到消息队列，或者做一些别的操作，这个时候完全不需要更改 Logback 的实现，只需要新增一个服务实现（service-provider）可以通过在本项目里面新增实现也可以从外部引入新的服务实现 jar 包。我们可以在服务(LoggerService)中选择一个具体的 服务实现(service-provider) 来完成我们需要的操作。</p>\n<p>那么接下来我们具体来说说 Java SPI 工作的重点原理—— <strong>ServiceLoader</strong> 。</p>\n<h2> ServiceLoader</h2>\n<h3> ServiceLoader 具体实现</h3>\n<p>想要使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，那么我们接下来看看 <code>ServiceLoader</code> 具体是怎么做的：</p>\n<p><code>ServiceLoader</code> 是 JDK 提供的一个工具类， 位于<code>package java.util;</code>包下。</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这是 JDK 官方给的注释：<strong>一种加载服务实现的工具。</strong></p>\n<p>再往下看，我们发现这个类是一个 <code>final</code> 类型的，所以是不可被继承修改，同时它实现了 <code>Iterable</code> 接口。之所以实现了迭代器，是为了方便后续我们能够通过迭代的方式得到对应的服务实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以看到一个熟悉的常量定义：</p>\n<p><code>private static final String PREFIX = \"META-INF/services/\";</code></p>\n<p>下面是 <code>load</code> 方法：可以发现 <code>load</code> 方法支持两种重载后的入参；</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据代码的调用顺序，在 <code>reload()</code> 方法中是通过一个内部类 <code>LazyIterator</code> 实现的。先继续往下面看。</p>\n<p><code>ServiceLoader</code> 实现了 <code>Iterable</code> 接口的方法后，具有了迭代的能力，在这个 <code>iterator</code> 方法被调用时，首先会在 <code>ServiceLoader</code> 的 <code>Provider</code> 缓存中进行查找，如果缓存中没有命中那么则在 <code>LazyIterator</code> 中进行查找。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在调用 <code>LazyIterator</code> 时，具体实现如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可能很多人看这个会觉得有点复杂，没关系，我这边实现了一个简单的 <code>ServiceLoader</code> 的小模型，流程和原理都是保持一致的，可以先从自己实现一个简易版本的开始学：</p>\n<h3> 自己实现一个 ServiceLoader</h3>\n<p>我先把代码贴出来：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关键信息基本已经通过代码注释描述出来了，</p>\n<p>主要的流程就是：</p>\n<ol>\n<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>\n<li>读取这个文件的名称找到对应的 spi 接口，</li>\n<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>\n<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>\n<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>\n</ol>\n<h2> 总结</h2>\n<p>其实不难发现，SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 <code>META-INF/services/</code> 文件下声明。</strong></p>\n<p>另外，SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的方式。还有 Dubbo 框架提供同样的 SPI 扩展机制，只不过 Dubbo 和 spring 框架中的 SPI 机制具体实现方式跟咱们今天学得这个有些细微的区别，不过整体的原理都是一致的，相信大家通过对 JDK 中 SPI 机制的学习，能够一通百通，加深对其他高深框的理解。</p>\n<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>\n<ol>\n<li>遍历加载所有的实现类，这样效率还是相对较低的；</li>\n<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>\n</ol>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg",
      "date_published": "2022-07-24T09:10:58.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Redis常见面试题总结(下)",
      "url": "https://javaguide.cn/database/redis/redis-questions-02.html",
      "id": "https://javaguide.cn/database/redis/redis-questions-02.html",
      "summary": "JavaGuide官方知识星球 Redis 事务 什么是 Redis 事务？ 你可以将 Redis 中的事务理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。",
      "content_html": "<figure><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\"><img src=\"https://oss.javaguide.cn/xingqiu/xingqiu.png\" alt=\"JavaGuide官方知识星球\" tabindex=\"0\"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>\n<h2> Redis 事务</h2>\n<h3> 什么是 Redis 事务？</h3>\n<p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>\n<p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p>\n<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>\n<p>因此，Redis 事务是不建议在日常开发中使用的。</p>\n<h3> 如何使用 Redis 事务？</h3>\n<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://redis.io/commands/multi\" target=\"_blank\" rel=\"noopener noreferrer\"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href=\"https://redis.io/commands/exec\" target=\"_blank\" rel=\"noopener noreferrer\"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>\n<p>这个过程是这样的：</p>\n<ol>\n<li>开始事务（<code>MULTI</code>）；</li>\n<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>\n<li>执行事务(<code>EXEC</code>)。</li>\n</ol>\n<p>你也可以通过 <a href=\"https://redis.io/commands/discard\" target=\"_blank\" rel=\"noopener noreferrer\"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以通过<a href=\"https://redis.io/commands/watch\" target=\"_blank\" rel=\"noopener noreferrer\"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1714\" target=\"_blank\" rel=\"noopener noreferrer\">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>\n<p>事务内部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>事务外部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Redis 官网相关介绍 <a href=\"https://redis.io/topics/transactions\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/transactions</a> 如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png\" alt=\"Redis 事务\" tabindex=\"0\"><figcaption>Redis 事务</figcaption></figure>\n<h3> Redis 事务支持原子性吗？</h3>\n<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n</ol>\n<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>\n<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-rollback.png\" alt=\"Redis 为什么不支持回滚\" tabindex=\"0\"><figcaption>Redis 为什么不支持回滚</figcaption></figure>\n<p><strong>相关 issue</strong> :</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/452\" target=\"_blank\" rel=\"noopener noreferrer\">issue#452: 关于 Redis 事务不满足原子性的问题</a> 。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/491\" target=\"_blank\" rel=\"noopener noreferrer\">Issue#491:关于 Redis 没有事务回滚？</a></li>\n</ul>\n<h3> Redis 事务支持持久性吗？</h3>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>\n<ul>\n<li>快照（snapshotting，RDB）</li>\n<li>只追加文件（append-only file, AOF）</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>\n<p>因此，Redis 事务的持久性也是没办法保证的。</p>\n<h3> 如何解决 Redis 事务的缺陷？</h3>\n<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>\n<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>\n<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>\n<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>\n<p>另外，Redis 7.0 新增了 <a href=\"https://redis.io/docs/manual/programmability/functions-intro/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>\n<h2> Redis 性能优化（重要）</h2>\n<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ\" target=\"_blank\" rel=\"noopener noreferrer\">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</a></li>\n<li><a href=\"https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 常见阻塞原因总结 - JavaGuide</a></li>\n</ul>\n<h3> 使用批量操作减少网络传输</h3>\n<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li>命令执行</li>\n<li>返回结果</li>\n</ol>\n<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>\n<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>\n<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：<a href=\"https://redis.io/docs/manual/pipelining/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/docs/manual/pipelining/</a> 。</p>\n<h4> 原生批量操作命令</h4>\n<p>Redis 中有一些原生支持批量操作的命令，比如：</p>\n<ul>\n<li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li>\n<li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>\n<li><code>SADD</code>（向指定集合添加一个或多个元素）</li>\n<li>……</li>\n</ul>\n<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>\n<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>\n<ol>\n<li>找到 key 对应的所有 hash slot；</li>\n<li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li>\n<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>\n</ol>\n<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>\n<blockquote>\n<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>\n<p>我在 <a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p>\n</blockquote>\n<h4> pipeline</h4>\n<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>\n<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>\n<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>\n<ul>\n<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>\n<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>\n<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>\n</ul>\n<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>\n<ul>\n<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>\n<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li>\n</ul>\n<blockquote>\n<p>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p>\n</blockquote>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pipeline-vs-transaction.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>\n<h4> Lua 脚本</h4>\n<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>\n<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>\n<p>不过， Lua 脚本依然存在下面这些缺陷：</p>\n<ul>\n<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>\n<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>\n</ul>\n<h3> 大量 key 集中过期问题</h3>\n<p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>\n<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>\n<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>\n<ol>\n<li>给 key 设置随机过期时间。</li>\n<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ol>\n<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>\n<h3> Redis bigkey（大 Key）</h3>\n<h4> 什么是 bigkey？</h4>\n<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：</p>\n<ul>\n<li>String 类型的 value 超过 1MB</li>\n<li>复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个（不过，对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/bigkey-criterion.png\" alt=\"bigkey 判定标准\" tabindex=\"0\"><figcaption>bigkey 判定标准</figcaption></figure>\n<h4> bigkey 是怎么产生的？有什么危害？</h4>\n<p>bigkey 通常是由于下面这些原因产生的：</p>\n<ul>\n<li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li>\n<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>\n<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>\n</ul>\n<p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。</p>\n<p>在 <a href=\"/database/redis/redis-common-blocking-problems-summary.html\" target=\"blank\">Redis 常见阻塞原因总结</a>这篇文章中我们提到：大 key 还会造成阻塞问题。具体来说，主要体现在下面三个方面：</p>\n<ol>\n<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>\n<li>网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>\n<li>工作线程阻塞：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n</ol>\n<p>大 key 造成的阻塞问题还会进一步影响到主从同步和集群扩容。</p>\n<p>综上，大 key 带来的潜在问题是非常多的，我们应该尽量避免 Redis 中存在 bigkey。</p>\n<h4> 如何发现 bigkey？</h4>\n<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 String 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p>\n<p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p>\n<p><strong>2、使用 Redis 自带的 SCAN 命令</strong></p>\n<p><code>SCAN</code> 命令可以按照一定的模式和数量返回匹配的 key。获取了 key 之后，可以利用 <code>STRLEN</code>、<code>HLEN</code>、<code>LLEN</code>等命令返回其长度或成员数量。</p>\n<table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>命令</th>\n<th>复杂度</th>\n<th>结果（对应 key）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>STRLEN</td>\n<td>O(1)</td>\n<td>字符串值的长度</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>HLEN</td>\n<td>O(1)</td>\n<td>哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>List</td>\n<td>LLEN</td>\n<td>O(1)</td>\n<td>列表元素数量</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>SCARD</td>\n<td>O(1)</td>\n<td>集合元素数量</td>\n</tr>\n<tr>\n<td>Sorted Set</td>\n<td>ZCARD</td>\n<td>O(1)</td>\n<td>有序集合的元素数量</td>\n</tr>\n</tbody>\n</table>\n<p>对于集合类型还可以使用 <code>MEMORY USAGE</code> 命令（Redis 4.0+），这个命令会返回键值对占用的内存空间。</p>\n<p><strong>3、借助开源工具分析 RDB 文件。</strong></p>\n<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>\n<p>网上有现成的代码/工具可以直接拿来使用：</p>\n<ul>\n<li><a href=\"https://github.com/sripathikrishnan/redis-rdb-tools\" target=\"_blank\" rel=\"noopener noreferrer\">redis-rdb-tools</a>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li><a href=\"https://github.com/weiyanwei412/rdb_bigkeys\" target=\"_blank\" rel=\"noopener noreferrer\">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n<p><strong>4、借助公有云的 Redis 分析服务。</strong></p>\n<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>\n<p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：<a href=\"https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png\" alt=\"阿里云Key分析\" tabindex=\"0\"><figcaption>阿里云Key分析</figcaption></figure>\n<h4> 如何处理 bigkey？</h4>\n<p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>\n<ul>\n<li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。</li>\n<li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>\n<li><strong>采用合适的数据结构</strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）。</li>\n<li><strong>开启 lazy-free（惰性删除/延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<h3> Redis hotkey（热 Key）</h3>\n<h4> 什么是 hotkey？</h4>\n<p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p>\n<p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>\n<h4> hotkey 有什么危害？</h4>\n<p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p>\n<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>\n<h4> 如何发现 hotkey？</h4>\n<p><strong>1、使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p>\n<p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p>\n<p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Redis 中有两种 LFU 算法：</p>\n<ol>\n<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>\n<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>\n</ol>\n<p>以下是配置文件 <code>redis.conf</code> 中的示例：</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>\n<p><strong>2、使用<code>MONITOR</code> 命令。</strong></p>\n<p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>\n<p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p>\n<p><strong>3、借助开源项目。</strong></p>\n<p>京东零售的 <a href=\"https://gitee.com/jd-platform-opensource/hotkey\" target=\"_blank\" rel=\"noopener noreferrer\">hotkey</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/jd-hotkey.png\" alt=\"京东零售开源的 hotkey\" tabindex=\"0\"><figcaption>京东零售开源的 hotkey</figcaption></figure>\n<p><strong>4、根据业务情况提前预估。</strong></p>\n<p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p>\n<p><strong>5、业务代码中记录分析。</strong></p>\n<p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p>\n<p><strong>6、借助公有云的 Redis 分析服务。</strong></p>\n<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>\n<p>这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：<a href=\"https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-key-analysis.png\" alt=\"阿里云Key分析\" tabindex=\"0\"><figcaption>阿里云Key分析</figcaption></figure>\n<h4> 如何解决 hotkey？</h4>\n<p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>\n<ul>\n<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li>\n<li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li>\n<li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>\n</ul>\n<p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p>\n<p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/aliyun-hotkey-proxy-query-cache.png\" alt=\"通过阿里云的Proxy Query Cache优化热点Key问题\" tabindex=\"0\"><figcaption>通过阿里云的Proxy Query Cache优化热点Key问题</figcaption></figure>\n<h3> 慢查询命令</h3>\n<h4> 为什么会有慢查询命令？</h4>\n<p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li>命令执行</li>\n<li>返回结果</li>\n</ol>\n<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>\n<p>Redis 为什么会有慢查询命令呢？</p>\n<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>\n<ul>\n<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>\n<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>\n<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>\n<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>\n<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>\n<li>……</li>\n</ul>\n<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>\n<p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>\n<ul>\n<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>\n<li>……</li>\n</ul>\n<h4> 如何找到慢查询命令？</h4>\n<p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>\n<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>\n<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>\n<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>慢查询日志中的每个条目都由以下六个值组成：</p>\n<ol>\n<li>唯一渐进的日志标识符。</li>\n<li>处理记录命令的 Unix 时间戳。</li>\n<li>执行所需的时间量，以微秒为单位。</li>\n<li>组成命令参数的数组。</li>\n<li>客户端 IP 地址和端口。</li>\n<li>客户端名称。</li>\n</ol>\n<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>\n<p>下面是其他比较常用的慢查询相关的命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Redis 内存碎片</h3>\n<p><strong>相关问题</strong>：</p>\n<ol>\n<li>什么是内存碎片?为什么会有 Redis 内存碎片?</li>\n<li>如何清理 Redis 内存碎片？</li>\n</ol>\n<p><strong>参考答案</strong>：<a href=\"https://javaguide.cn/database/redis/redis-memory-fragmentation.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 内存碎片详解</a>。</p>\n<h2> Redis 生产问题（重要）</h2>\n<h3> 缓存穿透</h3>\n<h4> 什么是缓存穿透？</h4>\n<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration.png\" alt=\"缓存穿透\" tabindex=\"0\"><figcaption>缓存穿透</figcaption></figure>\n<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>\n<p><strong>1）缓存无效 key</strong></p>\n<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>\n<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p>\n<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>2）布隆过滤器</strong></p>\n<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>\n<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p>加入布隆过滤器之后的缓存处理流程图如下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png\" alt=\"加入布隆过滤器之后的缓存处理流程图\" tabindex=\"0\"><figcaption>加入布隆过滤器之后的缓存处理流程图</figcaption></figure>\n<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>\n<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>\n</ol>\n<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter/\" target=\"_blank\" rel=\"noopener noreferrer\">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>\n<h3> 缓存击穿</h3>\n<h4> 什么是缓存击穿？</h4>\n<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-breakdown.png\" alt=\"缓存击穿\" tabindex=\"0\"><figcaption>缓存击穿</figcaption></figure>\n<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<ul>\n<li>设置热点数据永不过期或者过期时间比较长。</li>\n<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>\n</ul>\n<h4> 缓存穿透和缓存击穿有什么区别？</h4>\n<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>\n<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>\n<h3> 缓存雪崩</h3>\n<h4> 什么是缓存雪崩？</h4>\n<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>\n<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-avalanche.png\" alt=\"缓存雪崩\" tabindex=\"0\"><figcaption>缓存雪崩</figcaption></figure>\n<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<p><strong>针对 Redis 服务不可用的情况：</strong></p>\n<ol>\n<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p><strong>针对热点缓存失效的情况：</strong></p>\n<ol>\n<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效（不太推荐，实用性太差）。</li>\n<li>设置二级缓存。</li>\n</ol>\n<h4> 缓存雪崩和缓存击穿有什么区别？</h4>\n<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>\n<h3> 如何保证缓存和数据库数据的一致性？</h3>\n<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>\n<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>\n<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>\n<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>\n<ol>\n<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>\n<li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>\n</ol>\n<p>相关文章推荐：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd\" target=\"_blank\" rel=\"noopener noreferrer\">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a>。</p>\n<h3> 哪些情况可能会导致 Redis 阻塞？</h3>\n<p>单独抽了一篇文章来总结可能会导致 Redis 阻塞的情况：<a href=\"https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 常见阻塞原因总结</a>。</p>\n<h2> Redis 集群</h2>\n<p><strong>Redis Sentinel</strong>：</p>\n<ol>\n<li>什么是 Sentinel？ 有什么用？</li>\n<li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li>\n<li>Sentinel 是如何实现故障转移的？</li>\n<li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li>\n<li>Sentinel 如何选择出新的 master（选举机制）?</li>\n<li>如何从 Sentinel 集群中选择出 Leader ？</li>\n<li>Sentinel 可以防止脑裂吗？</li>\n</ol>\n<p><strong>Redis Cluster</strong>：</p>\n<ol>\n<li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li>\n<li>Redis Cluster 是如何分片的？</li>\n<li>为什么 Redis Cluster 的哈希槽是 16384 个?</li>\n<li>如何确定给定 key 的应该分布到哪个哈希槽中？</li>\n<li>Redis Cluster 支持重新分配哈希槽吗？</li>\n<li>Redis Cluster 扩容缩容期间可以提供服务吗？</li>\n<li>Redis Cluster 中的节点是怎么进行通信的？</li>\n</ol>\n<p><strong>参考答案</strong>：<a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解（付费）</a>。</p>\n<h2> Redis 使用规范</h2>\n<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>\n<ol>\n<li>使用连接池：避免频繁创建关闭客户端连接。</li>\n<li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li>\n<li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li>\n<li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>\n<li>禁止长时间开启 monitor：对性能影响比较大。</li>\n<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>\n<li>……</li>\n</ol>\n<p>相关文章推荐：<a href=\"https://developer.aliyun.com/article/531067\" target=\"_blank\" rel=\"noopener noreferrer\">阿里云 Redis 开发规范</a> 。</p>\n<h2> 参考</h2>\n<ul>\n<li>《Redis 开发与运维》</li>\n<li>《Redis 设计与实现》</li>\n<li>Redis Transactions : <a href=\"https://redis.io/docs/manual/transactions/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/docs/manual/transactions/</a></li>\n<li>What is Redis Pipeline：<a href=\"https://buildatscale.tech/what-is-redis-pipeline/\" target=\"_blank\" rel=\"noopener noreferrer\">https://buildatscale.tech/what-is-redis-pipeline/</a></li>\n<li>一文详解 Redis 中 BigKey、HotKey 的发现与处理：<a href=\"https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q</a></li>\n<li>Bigkey 问题的解决思路与方式探索:<a href=\"https://mp.weixin.qq.com/s/Sej7D9TpdAobcCmdYdMIyA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/Sej7D9TpdAobcCmdYdMIyA</a></li>\n<li>Redis 延迟问题全面排障指南：<a href=\"https://mp.weixin.qq.com/s/mIc6a9mfEGdaNDD3MmfFsg\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/mIc6a9mfEGdaNDD3MmfFsg</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/redis-transactions.png",
      "date_published": "2022-07-20T14:27:00.000Z",
      "date_modified": "2023-11-14T02:58:07.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 5 种基本数据类型详解",
      "url": "https://javaguide.cn/database/redis/redis-data-structures-01.html",
      "id": "https://javaguide.cn/database/redis/redis-data-structures-01.html",
      "summary": "Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。 Redis 5 种基本数据类型对应的底层数据结构实现如下表所示： String List Hash Set Zset SDS LinkedList/ZipList/QuickList Dict、ZipList Dict、Intset ZipList、SkipList",
      "content_html": "<p>Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>\n<p>这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>\n<p>Redis 5 种基本数据类型对应的底层数据结构实现如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">String</th>\n<th style=\"text-align:left\">List</th>\n<th style=\"text-align:left\">Hash</th>\n<th style=\"text-align:left\">Set</th>\n<th style=\"text-align:left\">Zset</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SDS</td>\n<td style=\"text-align:left\">LinkedList/ZipList/QuickList</td>\n<td style=\"text-align:left\">Dict、ZipList</td>\n<td style=\"text-align:left\">Dict、Intset</td>\n<td style=\"text-align:left\">ZipList、SkipList</td>\n</tr>\n</tbody>\n</table>\n<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。</p>\n<p>你可以在 Redis 官网上找到 Redis 数据类型/结构非常详细的介绍：</p>\n<ul>\n<li><a href=\"https://redis.com/redis-enterprise/data-structures/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Data Structures</a></li>\n<li><a href=\"https://redis.io/docs/manual/data-types/data-types-tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Data types tutorial</a></li>\n</ul>\n<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720181630203.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> String（字符串）</h2>\n<h3> 介绍</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据类型。</p>\n<p>String 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719124403897.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SET key value</td>\n<td>设置指定 key 的值</td>\n</tr>\n<tr>\n<td>SETNX key value</td>\n<td>只有在 key 不存在时设置 key 的值</td>\n</tr>\n<tr>\n<td>GET key</td>\n<td>获取指定 key 的值</td>\n</tr>\n<tr>\n<td>MSET key1 value1 key2 value2 ……</td>\n<td>设置一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>MGET key1 key2 ...</td>\n<td>获取一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>STRLEN key</td>\n<td>返回 key 所储存的字符串值的长度</td>\n</tr>\n<tr>\n<td>INCR key</td>\n<td>将 key 中储存的数字值增一</td>\n</tr>\n<tr>\n<td>DECR key</td>\n<td>将 key 中储存的数字值减一</td>\n</tr>\n<tr>\n<td>EXISTS key</td>\n<td>判断指定 key 是否存在</td>\n</tr>\n<tr>\n<td>DEL key（通用）</td>\n<td>删除指定的 key</td>\n</tr>\n<tr>\n<td>EXPIRE key seconds（通用）</td>\n<td>给指定 key 设置过期时间</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href=\"https://redis.io/commands/?group=string\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/?group=string</a> 。</p>\n<p><strong>基本操作</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>批量设置</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>设置过期时间（默认为永不过期）</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要存储常规数据的场景</strong></p>\n<ul>\n<li>举例：缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>\n<li>相关命令：<code>SET</code>、<code>GET</code>。</li>\n</ul>\n<p><strong>需要计数的场景</strong></p>\n<ul>\n<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>\n<li>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>\n</ul>\n<p><strong>分布式锁</strong></p>\n<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>\n<h2> List（列表）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 List 其实就是链表数据结构的实现。我在 <a href=\"https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html\" target=\"_blank\" rel=\"noopener noreferrer\">线性数据结构 :数组、链表、栈、队列</a> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>\n<p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719124413287.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RPUSH key value1 value2 ...</td>\n<td>在指定列表的尾部（右边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LPUSH key value1 value2 ...</td>\n<td>在指定列表的头部（左边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LSET key index value</td>\n<td>将指定列表索引 index 位置的值设置为 value</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并获取指定列表的第一个元素(最左边)</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并获取指定列表的最后一个元素(最右边)</td>\n</tr>\n<tr>\n<td>LLEN key</td>\n<td>获取列表元素数量</td>\n</tr>\n<tr>\n<td>LRANGE key start end</td>\n<td>获取列表 start 和 end 之间 的元素</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href=\"https://redis.io/commands/?group=list\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/?group=list</a> 。</p>\n<p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/redis-list.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>\n<p><strong>通过 <code>LLEN</code> 查看链表长度</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>信息流展示</strong></p>\n<ul>\n<li>举例：最新文章、最新动态。</li>\n<li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li>\n</ul>\n<p><strong>消息队列</strong></p>\n<p><code>List</code> 可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>\n<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>\n<h2> Hash（哈希）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>\n<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719124421703.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HSET key field value</td>\n<td>设置指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HSETNX key field value</td>\n<td>只有指定字段不存在时设置指定字段的值</td>\n</tr>\n<tr>\n<td>HMSET key field1 value1 field2 value2 ...</td>\n<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HMGET key field1 field2 ...</td>\n<td>获取指定哈希表中一个或者多个指定字段的值</td>\n</tr>\n<tr>\n<td>HGETALL key</td>\n<td>获取指定哈希表中所有的键值对</td>\n</tr>\n<tr>\n<td>HEXISTS key field</td>\n<td>查看指定哈希表中指定的字段是否存在</td>\n</tr>\n<tr>\n<td>HDEL key field1 field2 ...</td>\n<td>删除一个或多个哈希表字段</td>\n</tr>\n<tr>\n<td>HLEN key</td>\n<td>获取指定哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>HINCRBY key field increment</td>\n<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href=\"https://redis.io/commands/?group=hash\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/?group=hash</a> 。</p>\n<p><strong>模拟对象数据存储</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>对象数据存储场景</strong></p>\n<ul>\n<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>\n<li>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>\n</ul>\n<h2> Set（集合）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>\n<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719124430264.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SADD key member1 member2 ...</td>\n<td>向指定集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SMEMBERS key</td>\n<td>获取指定集合中的所有元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>获取指定集合的元素数量</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断指定元素是否在指定集合中</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 ...</td>\n<td>获取给定所有集合的交集</td>\n</tr>\n<tr>\n<td>SINTERSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的交集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 ...</td>\n<td>获取给定所有集合的并集</td>\n</tr>\n<tr>\n<td>SUNIONSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的并集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 ...</td>\n<td>获取给定所有集合的差集</td>\n</tr>\n<tr>\n<td>SDIFFSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的差集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SPOP key count</td>\n<td>随机移除并获取指定集合中一个或多个元素</td>\n</tr>\n<tr>\n<td>SRANDMEMBER key count</td>\n<td>随机获取指定集合中指定数量的元素</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href=\"https://redis.io/commands/?group=set\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/?group=set</a> 。</p>\n<p><strong>基本操作</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>mySet</code> : <code>value1</code>、<code>value2</code> 。</li>\n<li><code>mySet2</code>：<code>value2</code>、<code>value3</code> 。</li>\n</ul>\n<p><strong>求交集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求并集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求差集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要存放的数据不能重复的场景</strong></p>\n<ul>\n<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>\n<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719073733851.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>\n<ul>\n<li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li>\n<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719074543513.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>需要随机获取数据源中的元素的场景</strong></p>\n<ul>\n<li>举例：抽奖系统、随机点名等场景。</li>\n<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>\n</ul>\n<h2> Sorted Set（有序集合）</h2>\n<h3> 介绍</h3>\n<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719124437791.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZADD key score1 member1 score2 member2 ...</td>\n<td>向指定有序集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>ZCARD KEY</td>\n<td>获取指定有序集合的元素数量</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取指定有序集合中指定元素的 score 值</td>\n</tr>\n<tr>\n<td>ZINTERSTORE destination numkeys key1 key2 ...</td>\n<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>\n</tr>\n<tr>\n<td>ZUNIONSTORE destination numkeys key1 key2 ...</td>\n<td>求并集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZDIFFSTORE destination numkeys key1 key2 ...</td>\n<td>求差集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>\n</tr>\n<tr>\n<td>ZREVRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>\n</tr>\n<tr>\n<td>ZREVRANK key member</td>\n<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href=\"https://redis.io/commands/?group=sorted-set\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/?group=sorted-set</a> 。</p>\n<p><strong>基本操作</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>myZset</code> : <code>value1</code>(2.0)、<code>value2</code>(1.0) 。</li>\n<li><code>myZset2</code>：<code>value2</code> （4.0）、<code>value3</code>(3.0) 。</li>\n</ul>\n<p><strong>获取指定元素的排名</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求交集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求并集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求差集</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>\n<ul>\n<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>\n<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/2021060714195385.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719071115140.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>\n<ul>\n<li>举例：优先级任务队列。</li>\n<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>\n</ul>\n<h2> 总结</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td>\n</tr>\n<tr>\n<td>List</td>\n<td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td>\n</tr>\n<tr>\n<td>Zset</td>\n<td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td>\n</tr>\n</tbody>\n</table>\n<h2> 参考</h2>\n<ul>\n<li>Redis Data Structures：<a href=\"https://redis.com/redis-enterprise/data-structures/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.com/redis-enterprise/data-structures/</a> 。</li>\n<li>Redis Commands：<a href=\"https://redis.io/commands/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/commands/</a> 。</li>\n<li>Redis Data types tutorial：<a href=\"https://redis.io/docs/manual/data-types/data-types-tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/docs/manual/data-types/data-types-tutorial/</a> 。</li>\n<li>Redis 存储对象信息是用 Hash 还是 String : <a href=\"https://segmentfault.com/a/1190000040032006\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000040032006</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720181630203.png",
      "date_published": "2022-07-20T07:08:15.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 3 种特殊数据类型详解",
      "url": "https://javaguide.cn/database/redis/redis-data-structures-02.html",
      "id": "https://javaguide.cn/database/redis/redis-data-structures-02.html",
      "summary": "除了 5 种基本的数据类型之外，Redis 还支持 3 种特殊的数据类型：Bitmap、HyperLogLog、GEO。 Bitmap （位图） 介绍 根据官网介绍： Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits. Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。",
      "content_html": "<p>除了 5 种基本的数据类型之外，Redis 还支持 3 种特殊的数据类型：Bitmap、HyperLogLog、GEO。</p>\n<h2> Bitmap （位图）</h2>\n<h3> 介绍</h3>\n<p>根据官网介绍：</p>\n<blockquote>\n<p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p>\n<p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。</p>\n</blockquote>\n<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>\n<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SETBIT key offset value</td>\n<td>设置指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>GETBIT key offset</td>\n<td>获取指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>BITCOUNT key start end</td>\n<td>获取 start 和 end 之前值为 1 的元素个数</td>\n</tr>\n<tr>\n<td>BITOP operation destkey key1 key2 ...</td>\n<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Bitmap 基本操作演示</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>\n<ul>\n<li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>\n<li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>\n</ul>\n<h2> HyperLogLog（基数统计）</h2>\n<h3> 介绍</h3>\n<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>\n<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>\n<ul>\n<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>\n<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>\n</ul>\n<p>Redis 官方文档中有对应的详细说明：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220721091424563.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href=\"https://juejin.cn/post/6844903785744056333\" target=\"_blank\" rel=\"noopener noreferrer\">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>\n<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href=\"http://content.research.neustar.biz/blog/hll.html\" target=\"_blank\" rel=\"noopener noreferrer\">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>\n<p>除了 HyperLogLog 之外，Redis 还提供了其他的概率数据结构，对应的官方文档地址：<a href=\"https://redis.io/docs/data-types/probabilistic/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/docs/data-types/probabilistic/</a> 。</p>\n<h3> 常用命令</h3>\n<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PFADD key element1 element2 ...</td>\n<td>添加一个或多个元素到 HyperLogLog 中</td>\n</tr>\n<tr>\n<td>PFCOUNT key1 key2</td>\n<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>\n</tr>\n<tr>\n<td>PFMERGE destkey sourcekey1 sourcekey2 ...</td>\n<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>HyperLogLog 基本操作演示</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>\n<ul>\n<li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>\n<li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>\n</ul>\n<h2> Geospatial (地理位置)</h2>\n<h3> 介绍</h3>\n<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>\n<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194359494.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GEOADD key longitude1 latitude1 member1 ...</td>\n<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>\n</tr>\n<tr>\n<td>GEOPOS key member1 member2 ...</td>\n<td>返回给定元素的经纬度信息</td>\n</tr>\n<tr>\n<td>GEODIST key member1 member2 M/KM/FT/MI</td>\n<td>返回两个给定元素之间的距离</td>\n</tr>\n<tr>\n<td>GEORADIUS key longitude latitude radius distance</td>\n<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>\n</tr>\n<tr>\n<td>GEORADIUSBYMEMBER key member radius distance</td>\n<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>\n<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220721201545147.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>获取指定位置范围内的其他元素</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href=\"https://juejin.cn/post/6844903966061363207\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>\n<p><strong>移除元素</strong>：</p>\n<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要管理使用地理空间数据的场景</strong></p>\n<ul>\n<li>举例：附近的人。</li>\n<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>\n</ul>\n<h2> 总结</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bitmap</td>\n<td>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td>\n</tr>\n<tr>\n<td>HyperLogLog</td>\n<td>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</td>\n</tr>\n<tr>\n<td>Geospatial index</td>\n<td>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</td>\n</tr>\n</tbody>\n</table>\n<h2> 参考</h2>\n<ul>\n<li>Redis Data Structures：<a href=\"https://redis.com/redis-enterprise/data-structures/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.com/redis-enterprise/data-structures/</a> 。</li>\n<li>《Redis 深度历险：核心原理与应用实践》1.6 四两拨千斤——HyperLogLog</li>\n<li>布隆过滤器,位图,HyperLogLog：<a href=\"https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png",
      "date_published": "2022-07-20T07:08:15.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Java 魔法类 Unsafe 详解",
      "url": "https://javaguide.cn/java/basis/unsafe.html",
      "id": "https://javaguide.cn/java/basis/unsafe.html",
      "summary": "本文整理完善自下面这两篇优秀的文章： Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019 Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021",
      "content_html": "<blockquote>\n<p>本文整理完善自下面这两篇优秀的文章：</p>\n<ul>\n<li><a href=\"https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019</a></li>\n<li><a href=\"https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb\" target=\"_blank\" rel=\"noopener noreferrer\">Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021</a></li>\n</ul>\n</blockquote>\n<p>阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 <code>Unsafe</code> 的类。</p>\n<p>那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！</p>\n<h2> Unsafe 介绍</h2>\n<p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 <code>Unsafe</code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 <code>Unsafe</code> 的使用一定要慎重。</p>\n<p>另外，<code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 <strong><code>native</code></strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717115231125.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><strong>为什么要使用本地方法呢？</strong></p>\n<ol>\n<li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。</li>\n<li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。</li>\n<li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。</li>\n</ol>\n<p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。</p>\n<h2> Unsafe 创建</h2>\n<p><code>sun.misc.Unsafe</code> 部分源码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>为什么 <code>public static</code> 方法无法被直接调用呢？</strong></p>\n<p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p>\n<p><strong>为什么要对 Unsafe 类进行这么谨慎的使用限制呢?</strong></p>\n<p><code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p>\n<p><strong>如若想使用 <code>Unsafe</code> 这个类的话，应该如何获取其实例呢？</strong></p>\n<p>这里介绍两个可行的方案。</p>\n<p>1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2、从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> Unsafe 功能</h2>\n<p>概括的来说，<code>Unsafe</code> 类实现功能可以被分为下面 8 类：</p>\n<ol>\n<li>内存操作</li>\n<li>内存屏障</li>\n<li>对象操作</li>\n<li>数据操作</li>\n<li>CAS 操作</li>\n<li>线程调度</li>\n<li>Class 操作</li>\n<li>系统信息</li>\n</ol>\n<h3> 内存操作</h3>\n<h4> 介绍</h4>\n<p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用下面的代码进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>先看结果输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>\n<p>你可以通过下图理解这个过程：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144344005.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144354582.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>\n<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>\n<p><strong>为什么要使用堆外内存？</strong></p>\n<ul>\n<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>\n<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>\n</ul>\n<h4> 典型应用</h4>\n<p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>\n<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 内存屏障</h3>\n<h4> 介绍</h4>\n<p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>\n<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>\n<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>\n<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144703446.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>\n<h4> 典型应用</h4>\n<p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>\n<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对象操作</h3>\n<h4> 介绍</h4>\n<p><strong>例子</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>对象属性</strong></p>\n<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>\n<p>有序写入的方法有以下三个：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>\n<ul>\n<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>\n<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>\n</ul>\n<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144834132.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>\n<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>\n<p><strong>对象实例化</strong></p>\n<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p>\n<h4> 典型应用</h4>\n<ul>\n<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>\n<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>\n</ul>\n<h3> 数组操作</h3>\n<h4> 介绍</h4>\n<p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 典型应用</h4>\n<p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144927257.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> CAS 操作</h3>\n<h4> 介绍</h4>\n<p>这部分主要为 CAS 相关操作的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>什么是 CAS?</strong> CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>\n<h4> 典型应用</h4>\n<p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行代码会依次输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144939826.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>\n<h3> 线程调度</h3>\n<h4> 介绍</h4>\n<p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>\n<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>\n<h4> 典型应用</h4>\n<p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序输出为：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144950116.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> Class 操作</h3>\n<h4> 介绍</h4>\n<p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>\n<p><strong>静态属性读取相关的方法</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个包含静态属性的类，进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>\n<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被初始化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>使用<code>defineClass</code>方法允许程序在运行时动态地创建一个类</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717145000710.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>\n<h4> 典型应用</h4>\n<p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>\n<h3> 系统信息</h3>\n<h4> 介绍</h4>\n<p>这部分包含两个获取系统相关信息的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 典型应用</h4>\n<p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>\n<h2> 总结</h2>\n<p>在本文中，我们首先介绍了 <code>Unsafe</code> 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 <code>Unsafe</code> 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 <code>Unsafe</code> 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 <code>Unsafe</code> 的过程中一定要做到使用谨慎使用、避免滥用。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717115231125.png",
      "date_published": "2022-07-17T07:13:30.000Z",
      "date_modified": "2023-10-08T08:33:50.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "单元测试到底是什么？应该怎么做？",
      "url": "https://javaguide.cn/system-design/basis/unit-test.html",
      "id": "https://javaguide.cn/system-design/basis/unit-test.html",
      "summary": "本文重构完善自谈谈为什么写单元测试 - 键盘男 - 2016这篇文章。 何谓单元测试？ 维基百科是这样介绍单元测试的： 在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。 程序单元是应用的 最小可测试部件 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。",
      "content_html": "<blockquote>\n<p>本文重构完善自<a href=\"https://www.jianshu.com/p/fa41fb80d2b8\" target=\"_blank\" rel=\"noopener noreferrer\">谈谈为什么写单元测试 - 键盘男 - 2016</a>这篇文章。</p>\n</blockquote>\n<h2> 何谓单元测试？</h2>\n<p>维基百科是这样介绍单元测试的：</p>\n<blockquote>\n<p>在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。</p>\n<p>程序单元是应用的 <strong>最小可测试部件</strong> 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>\n</blockquote>\n<p>由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖不影响验证逻辑，我们经常会用到 Fake、Stub 与 Mock 。</p>\n<p>关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/26942686\" target=\"_blank\" rel=\"noopener noreferrer\">测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018</a> 。</p>\n<h2> 为什么需要单元测试？</h2>\n<h3> 为重构保驾护航</h3>\n<p>我在<a href=\"/system-design/basis/refactoring.html\" target=\"blank\">重构</a>这篇文章中这样写到：</p>\n<blockquote>\n<p>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。</p>\n</blockquote>\n<p>每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。</p>\n<p>如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试……写 100 个类，道理一样，每个类做到第一点“保证逻辑正确性”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。</p>\n<h3> 提高代码质量</h3>\n<p>由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。</p>\n<h3> 减少 bug</h3>\n<p>一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。</p>\n<p>一个可单元测试的工程，会把业务、功能分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证各个单元的逻辑正确性。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。</p>\n<h3> 快速定位 bug</h3>\n<p>如果程序有 bug，我们运行一次全部单元测试，找到不通过的测试，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试……直到<strong>测试通过</strong>。</p>\n<h3> 持续集成依赖单元测试</h3>\n<p>持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p>\n<h2> 谁逼你写单元测试？</h2>\n<h3> 领导要求</h3>\n<p>有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？</p>\n<p>培训新人单元测试用法，是一项艰巨的任务。新人代码风格未形成，也不知道单元测试多重要，强制单元测试会让他们感到困惑，没办法按自己思路写代码。</p>\n<h3> 大牛都写单元测试</h3>\n<p>国外很多家喻户晓的开源项目，都有大量单元测试。例如，<a href=\"https://link.jianshu.com?t=https://github.com/square/retrofit/tree/master/retrofit/src/test/java/retrofit2\" target=\"_blank\" rel=\"noopener noreferrer\">retrofit</a>、<a href=\"https://link.jianshu.com?t=https://github.com/square/okhttp/tree/master/okhttp-tests/src/test/java/okhttp3\" target=\"_blank\" rel=\"noopener noreferrer\">okhttp</a>、<a href=\"https://link.jianshu.com?t=https://github.com/JakeWharton/butterknife/tree/master/butterknife-compiler/src/test/java/butterknife\" target=\"_blank\" rel=\"noopener noreferrer\">butterknife</a>…… 国外大牛都写单元测试，我们也写吧！</p>\n<p>很多读者都有这种想法，一开始满腔热血。当真要对自己项目单元测试时，便困难重重，很大原因是项目对单元测试不友好。最后只能对一些不痛不痒的工具类做单元测试，久而久之，当初美好愿望也不了了之。</p>\n<h3> 保住面子</h3>\n<p>都是有些许年经验的老鸟，还天天被测试同学追 bug，好意思么？花多一点时间写单元测试，确保没低级 bug，还能彰显大牛风范，何乐而不为？</p>\n<h3> 心虚</h3>\n<p>笔者也是个不太相信自己代码的人，总觉得哪里会突然冒出莫名其妙的 bug，也怕别人不小心改了自己的代码（被害妄想症），新版本上线提心吊胆……花点时间写单元测试，有事没事跑一下测试，确保原逻辑没问题，至少能睡安稳一点。</p>\n<h2> TDD 测试驱动开发</h2>\n<h3> 何谓 TDD？</h3>\n<p>TDD 即 Test-Driven Development（ 测试驱动开发），这是敏捷开发的一项核心实践和技术，也是一种设计方法论。</p>\n<p>TDD 原理是开发功能代码之前，先编写测试用例代码，然后针对测试用例编写功能代码，使其能够通过。</p>\n<p>TDD 的节奏：“红 - 绿 - 重构”。</p>\n<figure><img src=\"https://static001.geekbang.org/resource/image/09/7f/090e1fc6aff08b4aa66376f776c2337f.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>由于 TDD 对开发人员要求非常高，跟传统开发思维不一样，因此实施起来相当困难。</p>\n<p>TDD 在很多人眼中是不实用的，一来他们并不理解测试“驱动”开发的含义，但更重要的是，他们很少会做任务分解。而任务分解是做好 TDD 的关键点。只有把任务分解到可以测试的地步，才能够有针对性地写测试。</p>\n<h3> TDD 优缺点分析</h3>\n<p>测试驱动开发有好处也有坏处。因为每个测试用例都是根据需求来的，或者说把一个大需求分解成若干小需求编写测试用例，所以测试用例写出来后，开发者写的执行代码，必须满足测试用例。如果测试不通过，则修改执行代码，直到测试用例通过。</p>\n<p><strong>优点</strong>：</p>\n<ol>\n<li>帮你整理需求，梳理思路；</li>\n<li>帮你设计出更合理的接口（空想的话很容易设计出屎）；</li>\n<li>减小代码出现 bug 的概率；</li>\n<li>提高开发效率（前提是正确且熟练使用 TDD）。</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>能用好 TDD 的人非常少，看似简单，实则门槛很高；</li>\n<li>投入开发资源（时间和精力）通常会更多；</li>\n<li>由于测试用例在未进行代码设计前写；很有可能限制开发者对代码整体设计；</li>\n<li>可能引起开发人员不满情绪，我觉得这点很严重，毕竟不是人人都喜欢单元测试，尽管单元测试会带给我们相当多的好处。</li>\n</ol>\n<p>相关阅读：<a href=\"https://zhuanlan.zhihu.com/p/24997923\" target=\"_blank\" rel=\"noopener noreferrer\">如何用正确的姿势打开 TDD？ - 陈天 - 2017</a> 。</p>\n<h2> 单测框架如何选择？</h2>\n<p>对于单测来说，目前常用的单测框架有：JUnit、Mockito、Spock、PowerMock、JMockit、TestableMock 等等。</p>\n<p>JUnit 几乎是默认选择，但是其不支持 Mock，因此我们还需要选择一个 Mock 工具。Mockito 和 Spock 是最主流的两款 Mock 工具，一般都是在这两者中选择。</p>\n<p>究竟是选择 Mockito 还是 Spock 呢？我这里做了一些简单的对比分析：</p>\n<ul>\n<li>Spock 没办法 Mock 静态方法和私有方法 ，Mockito 3.4.0 以后，支持静态方法的 Mock，具体可以看这个 issue：<a href=\"https://github.com/mockito/mockito/issues/1013%EF%BC%8C%E5%85%B7%E4%BD%93%E6%95%99%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%9Ahttps://www.baeldung.com/mockito-mock-static-methods%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/mockito/mockito/issues/1013，具体教程可以看这篇文章：https://www.baeldung.com/mockito-mock-static-methods。</a></li>\n<li>Spock 基于 Groovy，写出来的测试代码更清晰易读，比较规范(自带 given-when-then 的常用测试结构规范)。Mockito 没有具体的结构规范，需要项目组自己约定一个或者遵守比较好的测试代码实践。通常来说，同样的测试用例，Spock 的代码要更简洁。</li>\n<li>Mockito 使用的人群更广泛，稳定可靠。并且，Mockito 是 SpringBoot Test 默认集成的 Mock 工具。</li>\n</ul>\n<p>Mockito 和 Spock 都是非常不错的 Mock 工具，相对来说，Mockito 的适用性更强一些。</p>\n<h2> 总结</h2>\n<p>单元测试确实会带给你相当多的好处，但不是立刻体验出来。正如买重疾保险，交了很多保费，没病没痛，十几年甚至几十年都用不上，最好就是一辈子用不上理赔，身体健康最重要。单元测试也一样，写了可以买个放心，对代码的一种保障，有 bug 尽快测出来，没 bug 就最好，总不能说“写那么多单元测试，结果测不出 bug，浪费时间”吧？</p>\n<p>以下是个人对单元测试一些建议：</p>\n<blockquote>\n<ul>\n<li>越重要的代码，越要写单元测试；</li>\n<li>代码做不到单元测试，多思考如何改进，而不是放弃；</li>\n<li>边写业务代码，边写单元测试，而不是完成整个新功能后再写；</li>\n<li>多思考如何改进、简化测试代码。</li>\n<li>测试代码需要随着生产代码的演进而重构或者修改，如果测试不能保持整洁，只会越来越难修改。</li>\n</ul>\n</blockquote>\n<p>作为一名经验丰富的程序员，写单元测试更多的是<strong>对自己的代码负责</strong>。有测试用例的代码，别人更容易看懂，以后别人接手你的代码时，也可能放心做改动。</p>\n<p><strong>多敲代码实践，多跟有单元测试经验的工程师交流</strong>，你会发现写单元测试获得的收益会更多。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://static001.geekbang.org/resource/image/09/7f/090e1fc6aff08b4aa66376f776c2337f.png",
      "date_published": "2022-07-16T13:03:16.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "代码质量"
      ]
    },
    {
      "title": "Java IO 基础知识总结",
      "url": "https://javaguide.cn/java/io/io-basis.html",
      "id": "https://javaguide.cn/java/io/io-basis.html",
      "summary": "这是一则或许对你有用的小广告 面试专版：准备 Java 面试的小伙伴可以考虑面试专版：《Java 面试指北 》 (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。 知识星球：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 JavaGuide 官方知识星球。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">这是一则或许对你有用的小广告</p>\n<ul>\n<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>\n<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">JavaGuide 官方知识星球</a></strong>。</li>\n</ul>\n</div>\n<h2> IO 流简介</h2>\n<p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>\n<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h2> 字节流</h2>\n<h3> InputStream（字节输入流）</h3>\n<p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>\n<p><code>InputStream</code> 常用方法：</p>\n<ul>\n<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>\n<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>\n<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>\n<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>\n<li><code>available()</code>：返回输入流中可以读取的字节数。</li>\n<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>\n</ul>\n<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>\n<ul>\n<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>\n<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>\n<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>\n</ul>\n<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>\n<p><code>FileInputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220419155214614.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>\n<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>\n<h3> OutputStream（字节输出流）</h3>\n<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>\n<p><code>OutputStream</code> 常用方法：</p>\n<ul>\n<li><code>write(int b)</code>：将特定字节写入输出流。</li>\n<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>\n<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>\n<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>\n<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>\n</ul>\n<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>\n<p><code>FileOutputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220419155514392.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符流</h2>\n<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>\n<p>个人认为主要有两点原因：</p>\n<ul>\n<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>\n<li>如果我们不知道编码类型就很容易出现乱码问题。</li>\n</ul>\n<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220419154632551.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很明显地看到读取出来的内容已经变成了乱码。</p>\n<p>因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>\n<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>\n<h3> Reader（字符输入流）</h3>\n<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>\n<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>\n<p><code>Reader</code> 常用方法：</p>\n<ul>\n<li><code>read()</code> : 从输入流读取一个字符。</li>\n<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>\n<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>\n<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>\n</ul>\n<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FileReader</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220419154632551.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Writer（字符输出流）</h3>\n<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>\n<p><code>Writer</code> 常用方法：</p>\n<ul>\n<li><code>write(int c)</code> : 写入单个字符。</li>\n<li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>\n<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>\n<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>\n<li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>\n<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>\n<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>\n</ul>\n<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FileWriter</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220419155802288.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 字节缓冲流</h2>\n<p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>\n<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>\n<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>\n<p>我使用 <code>write(int b)</code> 和 <code>read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1/165。</p>\n<p>测试代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p>\n<p>这次我们使用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p>\n<p>测试代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> BufferedInputStream（字节缓冲输入流）</h3>\n<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>\n<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>缓冲区的大小默认为 <strong>8192</strong> 字节，当然了，你也可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p>\n<h3> BufferedOutputStream（字节缓冲输出流）</h3>\n<p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类似于 <code>BufferedInputStream</code> ，<code>BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>\n<h2> 字符缓冲流</h2>\n<p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>\n<h2> 打印流</h2>\n<p>下面这段代码大家经常使用吧？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p>\n<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 随机访问流</h2>\n<p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p>\n<p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>读写模式主要有下面四种：</p>\n<ul>\n<li><code>r</code> : 只读模式。</li>\n<li><code>rw</code>: 读写模式</li>\n<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>\n<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li>\n</ul>\n<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>\n<p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p>\n<p><code>RandomAccessFile</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220421162050158.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>输出：</p>\n<div class=\"language-plain line-numbers-mode\" data-ext=\"plain\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p>\n<p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为 <code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p>\n<p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>\n<p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/io/20210609164749122.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>我在<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中详细介绍了大文件的上传问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/image-20220428104115362.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/image-20220419155214614.png",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java IO 设计模式总结",
      "url": "https://javaguide.cn/java/io/io-design-patterns.html",
      "id": "https://javaguide.cn/java/io/io-design-patterns.html",
      "summary": "这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。",
      "content_html": "<p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>\n<h2> 装饰器模式</h2>\n<p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>\n<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>\n<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>\n<p>我们常见的<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p>\n<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>\n<p><code>BufferedInputStream</code> 构造函数如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出，<code>BufferedInputStream</code> 的构造函数其中的一个参数就是 <code>InputStream</code> 。</p>\n<p><code>BufferedInputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果 <code>InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code>InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p>\n<p>如果你对 IO 流比较熟悉的话，你会发现<code>ZipInputStream</code> 和<code>ZipOutputStream</code> 还可以分别增强 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 的能力。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ZipInputStream</code> 和<code>ZipOutputStream</code> 分别继承自<code>InflaterInputStream</code> 和<code>DeflaterOutputStream</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p>\n<p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code>InputStream</code> 和<code>OutputStream</code>。</p>\n<p>对于字符流来说，<code>BufferedReader</code> 可以用来增加 <code>Reader</code> （字符输入流）子类的功能，<code>BufferedWriter</code> 可以用来增加 <code>Writer</code> （字符输出流）子类的功能。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。</p>\n<h2> 适配器模式</h2>\n<p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p>\n<p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>\n<p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>\n<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p>\n<p><code>InputStream</code> 和 <code>OutputStream</code> 的子类是被适配者， <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>是适配器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>java.io.InputStreamReader</code> 部分源码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>java.io.OutputStreamWriter</code> 部分源码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>适配器模式和装饰器模式有什么区别呢？</strong></p>\n<p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>\n<p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p>\n<p>另外，<code>FutureTask</code> 类使用了适配器模式，<code>Executors</code> 的内部类 <code>RunnableAdapter</code> 实现属于适配器，用于将 <code>Runnable</code> 适配成 <code>Callable</code>。</p>\n<p><code>FutureTask</code>参数包含 <code>Runnable</code> 的一个构造方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Executors</code>中对应的方法和适配器：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 工厂模式</h2>\n<p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、<code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 观察者模式</h2>\n<p>NIO 中的文件目录监听服务使用到了观察者模式。</p>\n<p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p>\n<p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code>（监控服务） 并绑定监听事件的方法 <code>register</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WatchService</code> 用于监听文件目录的变化，同一个 <code>WatchService</code> 对象能够监听多个文件目录。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Path</code> 类 <code>register</code> 方法的第二个参数 <code>events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常用的监听事件有 3 种：</p>\n<ul>\n<li><code>StandardWatchEventKinds.ENTRY_CREATE</code>：文件创建。</li>\n<li><code>StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li>\n<li><code>StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li>\n</ul>\n<p><code>register</code> 方法返回 <code>WatchKey</code> 对象，通过<code>WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>Patterns in Java APIs：<a href=\"http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html</a></li>\n<li>装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式：<a href=\"https://time.geekbang.org/column/article/204845\" target=\"_blank\" rel=\"noopener noreferrer\">https://time.geekbang.org/column/article/204845</a></li>\n<li>sun.nio 包是什么，是 java 代码么？ - RednaxelaFX <a href=\"https://www.zhihu.com/question/29237781/answer/43653953\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/29237781/answer/43653953</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2023-09-01T07:42:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java IO 模型详解",
      "url": "https://javaguide.cn/java/io/io-model.html",
      "id": "https://javaguide.cn/java/io/io-model.html",
      "summary": "IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~ 个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！ 前言 I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。 I/O 何为 I/O? I/O（Input/Outpu） 即输入／输出 。",
      "content_html": "<p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~</p>\n<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！</em></p>\n<h2> 前言</h2>\n<p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。</p>\n<h2> I/O</h2>\n<h3> 何为 I/O?</h3>\n<p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>\n<p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p>\n<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/io/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.jpeg\" alt=\"冯诺依曼体系结构\" tabindex=\"0\"><figcaption>冯诺依曼体系结构</figcaption></figure>\n<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>\n<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>\n<p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p>\n<p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p>\n<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>\n<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>\n<p>并且，用户空间的程序不能直接访问内核空间。</p>\n<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>\n<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>\n<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>\n<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>\n<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>\n<ol>\n<li>内核等待 I/O 设备准备好数据</li>\n<li>内核将数据从内核空间拷贝到用户空间。</li>\n</ol>\n<h3> 有哪些常见的 IO 模型?</h3>\n<p>UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p>\n<p>这也是我们经常提到的 5 种 IO 模型。</p>\n<h2> Java 中 3 种常见 IO 模型</h2>\n<h3> BIO (Blocking I/O)</h3>\n<p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.png\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" tabindex=\"0\"><figcaption>图源：《深入拆解Tomcat &amp; Jetty》</figcaption></figure>\n<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>\n<h3> NIO (Non-blocking/New I/O)</h3>\n<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>\n<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>\n<p>跟着我的思路往下看看，相信你会得到答案！</p>\n<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>\n<figure><img src=\"https://oss.javaguide.cn/p3-juejin/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" tabindex=\"0\"><figcaption>图源：《深入拆解Tomcat &amp; Jetty》</figcaption></figure>\n<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>\n<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/io/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>\n<blockquote>\n<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>\n<ul>\n<li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>\n<li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>\n</ul>\n</blockquote>\n<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>\n<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png\" alt=\"Buffer、Channel和Selector三者之间的关系\" tabindex=\"0\"><figcaption>Buffer、Channel和Selector三者之间的关系</figcaption></figure>\n<h3> AIO (Asynchronous I/O)</h3>\n<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>\n<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/io/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>\n<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png\" alt=\"BIO、NIO 和 AIO 对比\" tabindex=\"0\"><figcaption>BIO、NIO 和 AIO 对比</figcaption></figure>\n<h2> 参考</h2>\n<ul>\n<li>《深入拆解 Tomcat &amp; Jetty》</li>\n<li>如何完成一次 IO：<a href=\"https://llc687.top/126.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://llc687.top/126.html</a></li>\n<li>程序员应该这样理解 IO：<a href=\"https://www.jianshu.com/p/fa7bdc4f3de7\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/fa7bdc4f3de7</a></li>\n<li>10 分钟看懂， Java NIO 底层原理：<a href=\"https://www.cnblogs.com/crazymakercircle/p/10225159.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></li>\n<li>IO 模型知多少 | 理论篇：<a href=\"https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</a></li>\n<li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/java/io/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.jpeg",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "RPC基础知识总结",
      "url": "https://javaguide.cn/distributed-system/rpc/rpc-intro.html",
      "id": "https://javaguide.cn/distributed-system/rpc/rpc-intro.html",
      "summary": "这篇文章会简单介绍一下 RPC 相关的基础概念。 RPC 是什么? RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。 为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。",
      "content_html": "<p>这篇文章会简单介绍一下 RPC 相关的基础概念。</p>\n<h2> RPC 是什么?</h2>\n<p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>\n<p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p>\n<p><strong>RPC 能帮助我们做什么呢？</strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>\n<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>\n<p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>\n<h2> RPC 的原理是什么?</h2>\n<p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：</p>\n<ol>\n<li><strong>客户端（服务消费端）</strong>：调用远程方法的一端。</li>\n<li><strong>客户端 Stub（桩）</strong>：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>\n<li><strong>网络传输</strong>：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li>\n<li><strong>服务端 Stub（桩）</strong>：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。</li>\n<li><strong>服务端（服务提供端）</strong>：提供远程方法的一端。</li>\n</ol>\n<p>具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/37345851.jpg\" alt=\"RPC原理图\" tabindex=\"0\"><figcaption>RPC原理图</figcaption></figure>\n<ol>\n<li>服务消费端（client）以本地调用的方式调用远程服务；</li>\n<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>\n<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>\n<li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li>\n<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>\n<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>\n<li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li>\n</ol>\n<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>\n<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>\n<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>\n<h2> 有哪些常见的 RPC 框架？</h2>\n<p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC 这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如 Feign。</p>\n<h3> Dubbo</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716111053081.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，<br>\n涵盖 Java、Golang 等多种语言 SDK 实现。</p>\n<p>Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716111545343.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>\n<p>Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！</p>\n<ul>\n<li>GitHub：<a href=\"https://github.com/apache/incubator-dubbo\" title=\"https://github.com/apache/incubator-dubbo\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/incubator-dubbo</a></li>\n<li>官网：<a href=\"https://dubbo.apache.org/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dubbo.apache.org/zh/</a></li>\n</ul>\n<h3> Motan</h3>\n<p>Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。</p>\n<p>很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。</strong></p>\n<p>不过，我不推荐你在实际项目中使用 Motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p>\n<ul>\n<li>从 Motan 看 RPC 框架设计：<a href=\"http://kriszhang.com/motan-rpc-impl/\" title=\"http://kriszhang.com/motan-rpc-impl/\" target=\"_blank\" rel=\"noopener noreferrer\">http://kriszhang.com/motan-rpc-impl/</a></li>\n<li>Motan 中文文档：<a href=\"https://github.com/weibocom/motan/wiki/zh_overview\" title=\"https://github.com/weibocom/motan/wiki/zh_overview\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/weibocom/motan/wiki/zh_overview</a></li>\n</ul>\n<h3> gRPC</h3>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/2843b10d-0c2f-4b7e-9c3e-ea4466792a8b.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>\n<p><strong>何谓 ProtoBuf？</strong> <a href=\"https://github.com/protocolbuffers/protobuf\" target=\"_blank\" rel=\"noopener noreferrer\">ProtoBuf（ Protocol Buffer）</a> 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/image-20220716104304033.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>不得不说，gRPC 的通信层的设计还是非常优秀的，<a href=\"https://dubbogo.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo-go 3.0</a> 的通信层改进主要借鉴了 gRPC。</p>\n<p>不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。</p>\n<ul>\n<li>GitHub：<a href=\"https://github.com/grpc/grpc\" title=\"https://github.com/grpc/grpc\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/grpc/grpc</a></li>\n<li>官网：<a href=\"https://grpc.io/\" title=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener noreferrer\">https://grpc.io/</a></li>\n</ul>\n<h3> Thrift</h3>\n<p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>\n<p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p>\n<ul>\n<li>官网：<a href=\"https://thrift.apache.org/\" title=\"https://thrift.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://thrift.apache.org/</a></li>\n<li>Thrift 简单介绍：<a href=\"https://www.jianshu.com/p/8f25d057a5a9\" title=\"https://www.jianshu.com/p/8f25d057a5a9\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/8f25d057a5a9</a></li>\n</ul>\n<h3> 总结</h3>\n<p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>\n<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo 在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。</p>\n<p>下图展示了 Dubbo 的生态系统。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/eee98ff2-8e06-4628-a42b-d30ffcd2831e.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/0d195dae-72bc-4956-8451-3eaf6dd11cbd.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。</p>\n<p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p>\n<h2> 如何设计并实现一个 RPC 框架？</h2>\n<p><strong>《手写 RPC 框架》</strong> 是我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</p>\n<p>麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p>\n<p><strong>内容概览</strong>：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/image-20220308100605485.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h2> 既然有了 HTTP 协议，为什么还要有 RPC ？</h2>\n<p>关于这个问题的详细答案，请看这篇文章：<a href=\"/distributed-system/rpc/http&amp;rpc.html\" target=\"blank\">有了 HTTP 协议，为什么还要有 RPC ？</a> 。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/37345851.jpg",
      "date_published": "2022-07-16T03:43:09.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "校招进入飞书的个人经验",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "summary": "推荐语：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。 原文地址：https://www.ihewro.com/archives/1217/ 基本情况 我是 C++主要是后台开发的方向。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。</p>\n<br>\n<p><strong>原文地址</strong>：<a href=\"https://www.ihewro.com/archives/1217/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.ihewro.com/archives/1217/</a></p>\n</blockquote>\n<h2> 基本情况</h2>\n<p>我是 C++主要是后台开发的方向。</p>\n<p>2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）的 HR 面试通过（还没有收到录用意向书）。</p>\n<h2> 不顺利的春招过程</h2>\n<h3> 春招实习对我来说不太顺利</h3>\n<p>实验室在 1 月份元旦的那天正式可以放假回家，但回家仍然继续“远程工作”，工作并没有减少，每天日复一日的测试，调试我们开发的“流媒体会议系统”。</p>\n<p>在 1 月的倒数第三天，我们开了“年终总结”线上会议。至此，作为研二基本上与实验室的工作开始告别。也正式开始了春招复习的阶段。</p>\n<p>2 月前已经间歇性的开始准备，无非就是在 LeetCode 上面刷刷题目，一天刷不了几道，后面甚至象征性的刷一下每日一题。对我的算法刷题帮助很少。</p>\n<p>2 月份开始，2 月初的时候，LeetCode 才刷了大概 40 多道题目，挤出了几周时间更新了 handsome 主题的 8.x 版本，这又是一个繁忙的几周。直到春节的当天正式发布，春节过后又开始陆陆续续用一些时间修复 bug，发布修复版本。2 月份这样悄悄溜走。</p>\n<h3> 找实习的过程</h3>\n<p><strong>2021-3 月初</strong></p>\n<p>3 月 初的时候，投了阿里提前批，没想到阿里 3 月 4 号提前批就结束了，那一天约的一面的电话面也被取消了。紧接了开学实验室开会同步进度的时候，发现大家都一面/二面/三面的进度，而我还没有投递的进度。</p>\n<p><strong>2021-3-8</strong></p>\n<p>投递了字节飞书</p>\n<p><strong>2021-4 月初</strong></p>\n<p>字节第一次一面，腾讯第一次一面</p>\n<p><strong>2021-4 中旬</strong></p>\n<p>美团一、二面，腾讯第二次一面和二面，百度三轮面试，通过了。</p>\n<p><strong>2021-4 底</strong></p>\n<p>腾讯第三次一面和字节第二次一面</p>\n<p><strong>2021-5 月初</strong></p>\n<p>腾讯第三次二面和字节第二次二面，后面这两个都通过了</p>\n<h4> 阿里</h4>\n<p>第一次投了钉钉，没想到因为行测做的不好，在简历筛选给拒绝了。</p>\n<p>第二次阿里妈妈的后端面试，一面电话面试，我感觉面的还可以，最后题目也做出来了。最后反问阶段问对我的面试有什么建议，面试官说投阿里最好还是 Java 的…… 然后电话结束后就给我拒了……</p>\n<p>当时真的心态有点崩，问了这个晚上 7 点半的面试，一直看书晚上都没吃……</p>\n<p>所以春招和阿里就无缘了。</p>\n<h4> 美团</h4>\n<p>美团一面的面试官真的人很好。也很轻松，因为他们是 Java 岗位，也没问 c++知识，聊了一些基础知识，后面半个小时就是聊非技术问题，比如最喜欢网络上的某位程序员是谁，如何写出优雅的代码，推荐的技术类的书籍之类的。当时回答王垠是比较喜欢的程序员，面试官笑了说他也很喜欢。面试的氛围感觉很好。</p>\n<p>二面的时候全程就问简历上的一个项目，问了大概 90 分钟，感觉他从一开始就有点不太想要我的感觉，很大原因我觉的是我是 c++，转 Java 可能成本还是有一些的。最后问 HR 说结果待定，几天后通知被拒了。</p>\n<h4> 百度</h4>\n<p>百度一共三轮面试，在一个下午一起进行，真的很刺激。一面就是很基础的一些 c++问题，写了一个题目说一下思路没让运行（真的要运行还不一定能运行起来:)）</p>\n<p>二面也是基础，第一个题目合并两个有序数组，第二个题目写归并排序，写的结果不对，又给我换了一个题目，树的 BFS。二面面试官最后问我对今天面试觉得怎么样，我说虽然中间有一个道题目结果不对，但是思路是对的，可能某个小地方写的有问题，但总体的应该还是可以的。二面就给我通过了。</p>\n<p>三面问的技术问题比较少，30 多分钟，也没写题目，问了一些基本情况和基础知识。最后问部门做的什么内容。面试官说后面 hr 会联系我告诉我内容。</p>\n<h4> 字节飞书</h4>\n<p>第一次一面就凉了，原因应该是笔试题目结果不对……</p>\n<p>第二次一面在 4 月底了，很顺利。二面在五一劳动节后，面试官还让学姐告诉我让我多看看智能指针，面试的时候让我手写 shared_ptr，我之前看了一些实现，但是没有自己写过，导致代码考虑的不够完善，leader 就一直提醒我要怎么改怎么改。</p>\n<p>本来我以为凉了，在 5 月中旬的时候都准备去百度入职了，给我通知说过了，就这样决定去了字节。</p>\n<h4> 感悟</h4>\n<p>这么多次面试中，让我感悟最深的是面试中的考察题目真的很重要，因为我在基础知识上面也不突出，再加上如果算法题（一般 1 道或者 2 道）如果没做出来，基本就凉了。而面试之前的笔试考试反而没那么重要，也没那么难。基本 4 题写出来 1~2 道题目就有发起面试的机会了。难度也基本就是 LeetCode top 100 上面的那些算法。</p>\n<p>面试中做题，我很容易紧张，头脑就容易一片空白，稍不注意，写错个符号，或者链表赋值错了，很难看出来问题，导出最终结果不对。</p>\n<h2> 入职字节实习</h2>\n<p>入职字节之前我本来觉得这个岗位可能是我面试的最适合我的了，因为我主 c++，而且飞书用 c++应该挺深的。来之后就觉得我可能不太喜欢做客户端相关，感觉好复杂……也许服务端好一些，现在我仍然不能确定。</p>\n<p>字节的实习福利在这些公司中应该算是比较好的，小问题是工位比较窄，还是工作强度比其他的互联网公司大一些。字节食堂免费而且挺不错的。字节办公大厦很多，我所在的办公地点比较小。</p>\n<p>目前，需要放轻松，仓库代码慢慢看呗，mentor 也让我不急，准备有问题就多问问，不能憋着，浪费时间。拿到转正 offer 后，秋招还是想多试试外企或者国企。强度太大的工作目前很难适应。</p>\n<p>希望过段时间可以分享一下我的感受，以及能够更加适应目前的工作内容。</p>\n<h2> 求职经验分享</h2>\n<h3> 一些概念</h3>\n<h4> 日常实习与正式（暑期）实习有什么区别</h4>\n<ul>\n<li><strong>日常实习如果一个组比较缺人，就很可能一年四季都招实习生，就会有日常实习的机会</strong>，只要是在校学生都可以去面试。而正式实习开始时间有一个范围比较固定，比如每年的 3-6 月，也就是暑期实习。</li>\n<li>日常实习相对要好进一些，但是有的日常实习没有转正名额，这个要先确认一下。</li>\n<li><strong>字节的日常实习和正式实习在转正没什么区别，都是一起申请转正的。</strong></li>\n</ul>\n<h4> 正式实习拿到 offer 之后什么时候可以去实习</h4>\n<p>暑期实习拿到 offer 后就<strong>可以立即实习</strong>（一般需要走个流程 1 周左右的样子），<strong>也可以选择晚一点去实习</strong>，时间可以自己去把握，有的公司可以在系统上选择去实习的时间，有的是直接和 hr 沟通一下就可以。</p>\n<h4> 提前批和正式批的区别</h4>\n<p>以找实习为例：</p>\n<ul>\n<li>先提前批，再正式批，提前批一般是小组直接招人<strong>不进系统</strong>，<strong>没有笔试</strong>，<strong>流程相对走的快</strong>，一般一面过了，很快就是二面。</li>\n<li>正式批面试都会有面评，如果上一次失败的面试评价会影响下一次面试，所以还是谨慎一点好</li>\n</ul>\n<h4> 实习 offer 和正式 offer 区别</h4>\n<p>简单来说，实习 offer 只是给你一个实习的机会，如果在实习期间干的不错就可以转正，获得正式 offer。</p>\n<p>签署正式 offer 之后并不是意味着马上去上班，因为我们是校招生，拿到正式 offer 之后，可以继续实习（工资会是正式工资的百分比），也可以请假一段时间等真正毕业的时候再去正式工作。</p>\n<h3> 时间节点</h3>\n<blockquote>\n<p>尽早把简历弄出来，最好就是最近一段时间，因为大家对实验室项目现在还很熟悉，现在写起来不是很难，再过几个月写简历就比较痛苦了。</p>\n</blockquote>\n<p>以去年为例：</p>\n<ul>\n<li>2 月份中旬的时候阿里提前批开始（基本上只有阿里这个时候开了提前批），3 月 8 号阿里提前批结束。腾讯提前批是 3 月多开始的，4 月 15 号结束</li>\n<li>3-5 月拿到实习 offer，最好在 4 月份可以拿到比较想去的实习 offer。</li>\n<li>4-8 月份实习，7 月初秋招提前批，7 月底或者 8 月初就是秋招正式批，9 月底秋招就少了挺多，但是只是相对来说，还是有机会，</li>\n<li>10 月底秋招基本结束，后面还会有秋招补录</li>\n</ul>\n<hr>\n<ul>\n<li><strong>怎么找实习机会</strong>，个人觉得可以找认识的人内推比较好，内推好处除了可以帮看进度，一般可以直推到组，这样可以排除一些坑的组。提前知道这个组干嘛的。</li>\n<li><strong>实习挺重要，最好是实习的时候就找到一个想去的公司，秋招会轻松很多</strong>，因为实习转正基本没什么问题，其次实习转正的 offer 一般要比秋招的好（当然如果秋招表现好也是可以拿到很好的 offer）身边不少人正式 offer 都是实习转正的。</li>\n<li><strong>控制好实习的时间</strong>，因为边实习边准备秋招挺累的，一般实习的时候工作压力也挺大，没什么时间刷题。</li>\n</ul>\n<h3> 面试准备</h3>\n<h4> 项目经历</h4>\n<p>我觉得我们实验室项目是没问题的，重要是要讲好。</p>\n<ul>\n<li><strong>项目介绍</strong></li>\n</ul>\n<p>首先可能让你介绍一下这个项目是什么东西，以及<strong>为什么要去做这个项目</strong>。</p>\n<ul>\n<li><strong>项目的结果</strong></li>\n</ul>\n<p>然后可能会问这个项目的一些数据上最终结果，比如会议系统能够同时多少人使用，或者量化的体验，比如流畅度，或者是一些其他的一些优势。</p>\n<ul>\n<li><strong>项目中的困难</strong></li>\n</ul>\n<p>最后都会问过程中有没有遇到什么困难、挑战的，以及怎么解决的。这个过程中主要考察这个项目的技术点是什么。</p>\n<blockquote>\n<p>困难是指什么，个人觉得主要是花了好几天才解决的问题就是困难。</p>\n</blockquote>\n<p>举两个例子：</p>\n<p><strong>第一个例子是排查 bug 方面</strong>，比如有一个内存泄露的问题花了一周才排查出来，那就算一个困难，那么解决这个困难的过程就是<strong>如何去定位这个问题过程</strong>，比如我们先根据错误搜索相关资料，肯定没那么容易就直接找到原因，而是我们会在这些资料中找到一些<strong>关键词</strong>，比如一些工具，那么我们对这个工具的使用就是解决问题的一个过程。</p>\n<p><strong>第二个例子是需求方案的设计</strong>，比如某个需求完成，我们实现这个需求可能有多个可行的设计方案。解决这个困难的过程就是<strong>我们对最终选择这个方法的原因，以及其他的设计方案的优缺点的思考</strong>。</p>\n<p><a href=\"https://blog.csdn.net/u012423865/article/details/79452713\" target=\"_blank\" rel=\"noopener noreferrer\">面试中被问到：你在工作中碰到的最困难的问题是什么？<em>发现问题，解决问题.-CSDN 博客</em>面试中问到工作中遇到困难是怎么解决的</a></p>\n<p>有人说我解决方法就是通过百度搜索，但实际上细节也是先搜索某个错误或者问题，但是肯定不可能一下子就搜到了代码答案，而是找到一个答案中有某个关键词，接着我们继续找关键词获取其他的信息。</p>\n<h4> 笔试</h4>\n<p>找实习的笔试我觉得不会太难，一般如果是 4 道题目，做出来 1-2 道题目差不多就有面试的机会了。</p>\n<p>刷题老生常谈的问题，LeetCode Top100。一开始刷题很痛苦，等刷了 40 道题目的时候就有点感觉的，建议从链表、二叉树开始刷，数组类型题目有很多不能通用的技巧。</p>\n<ul>\n<li>::一定要用白版进行训练::，一定要用白板，不仅仅是为了面试记住 API，更重要的是用白板熟练后，写代码会更熟练而且思路更独立和没有依赖。</li>\n<li>算法题重中之重，终点不是困难题目，而是简单，中等，常见，高频的题目要熟能生巧，滚瓜烂熟。</li>\n<li>面试的笔试过程中，如果出现了问题，<strong>一定要第一时间申请使用本地 IDE 进行调试</strong>，否则可能很长时间找不到问题，浪费了机会。</li>\n</ul>\n<h4> 面试</h4>\n<p>面试一般 1 场 1 个小时候分为两个部分，前半部分会问一些基础知识或者项目经历，后半部分做题。</p>\n<p><strong>基础知识复习一开始没必要系统的去复习，首先是确保高频问题必会</strong>，比如计算机网络、操作系统那几个必问的问题，可以多看看面经就能找到常问题的问题，对于比较偏问题就算没答上来也不是决定性的影响。</p>\n<ul>\n<li><strong>多看面经!!!!!!</strong> 不要一直埋头自己学，要看别人问过了哪些常问的问题。</li>\n<li>对于实习工作，<strong>看的知识点常见的问题一定要全!!!!!</strong>，不是那么精问题不大，一定要全，一定要全！！！！</li>\n<li><strong>对于自己不会的，尽量多的说！！！！</strong> 实在不行，就往别的地方说！！！总之是引导面试官往自己会的地方上说。</li>\n<li>面试中的笔试和前面的笔试风格不同，面试笔试题目不太难，但是考察是冷静思考，代码优雅，没有 bug，先思考清楚！！！在写！！！</li>\n<li>在描述项目的难点的时候，不要去聊文档调研是难点，回答这部分问题更应该是技术上的难点，最后通过了什么技术解决了这个问题，这部分技术可以让面试官来更多提问以便知道自己的技术能力。</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "date_published": "2022-07-15T03:53:57.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [
        {
          "name": "月色真美"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "HTTP 常见状态码总结（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/http-status-codes.html",
      "id": "https://javaguide.cn/cs-basics/network/http-status-codes.html",
      "summary": "HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。 常见 HTTP 状态码 1xx Informational（信息性状态码） 相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。",
      "content_html": "<p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png\" alt=\"常见 HTTP 状态码\" tabindex=\"0\"><figcaption>常见 HTTP 状态码</figcaption></figure>\n<h3> 1xx Informational（信息性状态码）</h3>\n<p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>\n<h3> 2xx Success（成功状态码）</h3>\n<ul>\n<li><strong>200 OK</strong>：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>\n<li><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>\n<li><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。</li>\n<li><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。</li>\n</ul>\n<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>\n<p><a href=\"https://tools.ietf.org/html/rfc2616#section-10.2.5\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP RFC 2616 对 204 状态码的描述</a>如下：</p>\n<blockquote>\n<p>The server has fulfilled the request but does not need to return an<br>\nentity-body, and might want to return updated metainformation. The<br>\nresponse MAY include new or updated metainformation in the form of<br>\nentity-headers, which if present SHOULD be associated with the<br>\nrequested variant.</p>\n<p>If the client is a user agent, it SHOULD NOT change its document view<br>\nfrom that which caused the request to be sent. This response is<br>\nprimarily intended to allow input for actions to take place without<br>\ncausing a change to the user agent's active document view, although<br>\nany new or updated metainformation SHOULD be applied to the document<br>\ncurrently in the user agent's active view.</p>\n<p>The 204 response MUST NOT include a message-body, and thus is always<br>\nterminated by the first empty line after the header fields.</p>\n</blockquote>\n<p>简单来说，204 状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p>\n<p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p>\n<h3> 3xx Redirection（重定向状态码）</h3>\n<ul>\n<li><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</li>\n<li><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>\n</ul>\n<h3> 4xx Client Error（客户端错误状态码）</h3>\n<ul>\n<li><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</li>\n<li><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</li>\n<li><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</li>\n<li><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>\n<li><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>\n</ul>\n<h3> 5xx Server Error（服务端错误状态码）</h3>\n<ul>\n<li><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>\n<li><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>\n</ul>\n<h3> 参考</h3>\n<ul>\n<li><a href=\"https://www.restapitutorial.com/httpstatuscodes.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.restapitutorial.com/httpstatuscodes.html</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018264501\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000018264501</a></li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png",
      "date_published": "2022-07-08T00:49:36.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "华为 OD 275 天后，我进了腾讯！",
      "url": "https://javaguide.cn/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "summary": "推荐语：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。 原文地址：https://www.cnblogs.com/shoufeng/p/14322931.html 时间线 18 年 7 月，毕业于某不知名 985 计科专业； 毕业前，在某马的 JavaEE（后台开发）培训了 6 个月； 第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景； 19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）； 20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台； 2021 年 1 月，入职鹅厂",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong>：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。</p>\n<br>\n<p><strong>原文地址</strong>：<a href=\"https://www.cnblogs.com/shoufeng/p/14322931.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/shoufeng/p/14322931.html</a></p>\n</blockquote>\n<h2> 时间线</h2>\n<ul>\n<li>18 年 7 月，毕业于某不知名 985 计科专业；</li>\n<li>毕业前，在某马的 JavaEE（后台开发）培训了 6 个月；</li>\n<li>第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景；</li>\n<li>19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）；</li>\n<li>20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台；</li>\n<li>2021 年 1 月，入职鹅厂</li>\n</ul>\n<h2> 华为 OD 工作经历总结</h2>\n<h3> 为什么会去华为 OD</h3>\n<p>在平安产险（正式员工）只待了 3 个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊 😂</p>\n<p>但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……<br>\n平台和工作内容都不错，这么好的机会，说啥也要去啊 💪</p>\n<blockquote>\n<p>其实有想过在平安内部转岗到大数据的，但是不满足“入职一年以上”这个要求；<br>\n「等待就是浪费生命」，在转正流程还没批下来的时候，赶紧溜了 😂</p>\n</blockquote>\n<h3> 华为 OD 的工作内容</h3>\n<p><strong>带着无限的期待，火急火燎地去华为报到了。</strong></p>\n<p>和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：</p>\n<blockquote>\n<p>主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；<br>\n试用期 6 个月，有导师带你，一般都是高你 2 个 Level 的华为自有员工，基本都是部门大牛。</p>\n</blockquote>\n<p>所以，<strong>不存在外包做的都是基础的、流程性的、没有技术含量的工作</strong> —— 顾虑这个的完全不用担心，你只需要打听清楚要去的部门/小组具体做什么，能接受就再考虑其他的。</p>\n<p>感触很深的一点是：华为是有着近 20 万员工的巨头，内部有很多流程和制度。好处是：能接触到大公司的产品从开发、测试，到发布、运维等一系列的流程，比如提交代码的时候，会由经验资深、经过内部认证的大牛给你 Review，在拉会检视的时候，可以学习他们考虑问题的角度，还有对整个产品全局的把控。</p>\n<p>但同时，个人觉得这也有不好的地方：流程繁琐会导致工作效率变低，比如改动几行代码，就需要跑完整个 CI（有些耗时比较久），还要提供自验和 VT 的报告。</p>\n<h3> OD 与华为自有员工的对比</h3>\n<p>什么是 OD？Outstanding Dispatcher，人员派遣，官方强调说，OD 和常说的“外包”是不一样的。</p>\n<p>说说我了解的 OD：</p>\n<ul>\n<li>参考华为的薪酬框架，OD 人员的薪酬体系有一定的市场竞争力 —— 的确是这样，貌似会稍微倒挂同级别的自有员工；</li>\n<li>可以参与华为主力产品的研发 —— 是的，这也是和某软等“供应商”的兄弟们不一样的地方；</li>\n<li>外网权限也可以申请打开（对，就是梯子），部门内部的大多数文档都是可以看的；</li>\n<li>工号是单独的 300 号段，其他供应商员工的工号是 8 开头，或着 WX 开头；</li>\n<li>工卡带是红色的，和自有员工一样，但是工卡内容不同，OD 的明确标注：办公区通行证，并有德科公司的备注：</li>\n</ul>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>还听到一些内部的说法：</p>\n<ul>\n<li>没股票，没 TUP，年终奖少，只有工资可能比我司高一点点而已；</li>\n<li>不能借针对 HW 的消费贷，也不能买公司提供的优惠保险……</li>\n</ul>\n<h3> 那，到底要不要去华为 OD？</h3>\n<p>我想，搜到我这篇文字的你，心里其实是有偏向的，只是缺最后一片雪花 ❄️，让自己下决心。</p>\n<p>作为过来人之一，我再提供一些参考吧 😃</p>\n<p>1）除了华为 OD，<strong>还有没有更好的选择？</strong> 综合考虑加班（996、有些是 9106 甚至更多）、薪资、工作内容，以及这份工作经历对你整个职业的加成等等因素；</p>\n<p>2）有看到一些内部的说法，比如：“奇怪 OD 这么棒，为啥大家不自愿转去 OD 啊？”；再比如：“OD 等同华为？这话都说的出口，既然都等同，为啥还要 OD？就是降成本嘛……”</p>\n<p>3）内心够强大吗？虽然没有人会说你是 OD，但总有一些事情会提醒你：<strong>你不是华为员工</strong>。比如：</p>\n<p>a) 内部发文啥的，还有心声平台的大部分内容，都是无权限看的：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124225007848-1701355006.png\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<p>b) 你的考勤是在租赁人员管理系统里考核，绩效管理也是；</p>\n<p>c) 自有员工的工卡具有消费功能（包括刷夜宵），OD 的工卡不能消费，需要办个消费卡，而且夜宵只能通过手机软件领取（自有员工是用工卡领的）；</p>\n<p>d) 你的加班一定要提加班申请电子流换 Double 薪资，不然只能换调休，离职时没时间调休也换不来 Double —— 而华为员工即使自己主动离职，也是有 N+1，以及加班时间换成 Double 薪资的；</p>\n<h3> 网传的 OD 转华为正编，真的假的？</h3>\n<p>这个放到单独的一节，是因为它很重要，有很多纠结的同学在关注这个问题。</p>\n<p><strong>答案是：真的。</strong></p>\n<p>据各类非官方渠道（比如知乎上的一些分享），转华为自有是有条件的（<a href=\"https://www.zhihu.com/question/356592219/answer/1562692667%EF%BC%89%EF%BC%9A\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/356592219/answer/1562692667）：</a></p>\n<p>1）入职时间：一年以上<br>\n2）绩效要求：连续两次绩效 A<br>\n3）认证要求：通过可信专业级认证<br>\n4）其他条件：根据业务部门的人员需求及指标要求确定</p>\n<p>说说这些条件吧 😃</p>\n<p><strong>条件 2 连续两次绩效 A</strong></p>\n<p>上面链接里的说法：</p>\n<blockquote>\n<p>绩效 A 大约占整个部门的前 10%，连续两次 A 的意思就是一年里两次考评都排在部门前 10%，能做到这样的在华为属于火车头，这种难得的绩效会舍得分给一个租赁人员吗？</p>\n</blockquote>\n<p>OD 同学能拿到 A 吗？不知道，我入职晚，都没有经历一个完整的绩效考评。</p>\n<p>（20210605 更新下）一年多了，还留着的 OD 同学告知我：OD 是单独评绩效的，能拿到 A 的比例，大概是 1/5，对应的年终奖就是 4 个月；绩效是 B，年终奖就是 2 个月。</p>\n<p>在我看来，在试用期答辩时，能拿 A，接下来半年的绩效大概率也是拿 A 的。</p>\n<p>但总的来说，这种事既看实力，又看劳动态度（能不能拼命三郎疯狂加班），还要看运气（主管对你是不是认可）……</p>\n<p><strong>条件 3 通过可信专业级认证</strong></p>\n<p>可信专业级认证考试是啥？华为在推动技术人员的可信认证，算是一项安全合规的工作。<br>\n专业级有哪些考试呢？共有四门：</p>\n<ul>\n<li>科目一：上级编程，对比力扣 2 道中等、1 道困难；</li>\n<li>科目二：编程知识与应用，考察基础的编程语言知识等；</li>\n<li>科目三：安全编程、质量、隐私，还有开发者测试等；</li>\n<li>科目四：重构知识，包括设计模式、代码重构等。</li>\n</ul>\n<p>上面这些，每一门单季度只能考一次（好像有些一年只能考 3 次），每个都要准备，少则 3 天，多则 1 星期，不准备，基本都过不了。<br>\n我在 4 个月左右、还没转正的时候，就考过了专业级的科目二、三、四，只剩科目一大半年都没过（算法确实太菜了 😂<br>\n但也有同事没准备，连着好几次都没通过。</p>\n<p><strong>条件 4 部门人员需求指标？</strong></p>\n<p>这个听起来都感觉很玄学。还是那句话，实力和运气到了，应该可以的！成功转正员工图镇楼：</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231943817-1976130336.jpg\" alt=\"\" tabindex=\"0\"><figcaption></figcaption></figure>\n<h3> 真的感谢 OD，也感谢华为</h3>\n<p>运气很好，在我换工作还不到 3 个月的时候，华为还收我。</p>\n<p>我遇到了很好的主管，起码在工作时间，感觉跟兄长一样指导、帮助我；</p>\n<p>分配给我的导师，是我工作以来认识到技术实力最厉害的人，定位问题思路清晰，编码实力强悍，全局思考问题、制定方案……</p>\n<p>小组、部门的同学都很 nice，9 个多月里，我基本每天都跟打了鸡血一样，现在想想，也不知道当时为什么会那么积极有干劲 😂</p>\n<p>从个人能力上来讲，我是进不去华为的（心里还是有点数的 😂）。正是有了 OD 这个渠道，才有机会切身感受华为的工作氛围，也学到了很多软技能：</p>\n<ul>\n<li>积极主动，勇于承担尝试，好工作要抢过来自己做；</li>\n<li>及时同步工作进展，包括已完成、待完成，存在的风险困难等内容，要让领导知道你的工作情况；</li>\n<li>勤于总结提炼输出，形成个人 DNA，利人利己；</li>\n<li>有不懂的可以随时找人问，脸皮要厚，虚心求教；</li>\n<li>不管多忙，所有的会议，不论大小，都要有会议纪要，邮件发给相关人……</li>\n</ul>\n<p>再次感谢，大家都加油，向很牛掰很牛掰前进 💪</p>\n<h2> 投简历，找面试官求虐</h2>\n<p>20 年 11 月初的一天，在同事们讨论“某某被其他公司高薪挖去了，钱景无限”的消息。</p>\n<p>我忽然惊觉，自己来到华为半年多，除了熟悉内部的系统和流程，好像没有什么成长和进步？</p>\n<p>不禁反思：只有厉害的人才会被挖，现在这个状态的我，在市场上值几个钱？</p>\n<p>刚好想起了之前的一个同事在离职聚会上分享的经验：</p>\n<blockquote>\n<p>技术人不能闭门造车，要多交流，多看看外面的动态。</p>\n<p>如果感觉自己太安逸了，那就把简历挂出去，去了解其他公司用的是什么技术，他们更关注哪些痛点？面几次你就有方向了。</p>\n</blockquote>\n<p>这时候起了个念头：找面试官求虐，以此来鞭策自己，进而更好地制定学习方向。</p>\n<p>于是我重新下载了某聘软件，在首页推荐里投了几家公司。</p>\n<h2> 开始面试</h2>\n<p>11 月 10 号投的简历，当天就有 2 家预约了 11 号下午的线上面试，其中就有鹅厂 🐧</p>\n<p>好巧不巧，10 号晚上要双十一业务保障，一直到第二天凌晨 2 点半才下班。</p>\n<p>熬夜太伤身，还好能申请调休一天，也省去了找借口请假 🙊</p>\n<p>这段时间集中面了 3 家：</p>\n<blockquote>\n<p>第 1 个是广州的公司，11 号当晚就完成了 2 轮线上面试，开得有点低，就婉拒了；<br>\n第 2 个就是本文的重点——鹅厂；<br>\n第 3 个是做跨境电商的公司，一面就跪（恭喜它荣升为“在我有限的工作经历中，面试体验最差的 2 家公司之一”🙂️）</p>\n</blockquote>\n<h2> 鹅厂，去还是不去？</h2>\n<p>一直有一个大厂梦，奈何菜鸟一枚，之前试过好几次，都跪在技术面了。</p>\n<p>所以想了个曲线救国的方法：先在其他单位积累着，有机会了再争取大厂的机会 💪</p>\n<p>很幸运，也很猝不及防，这次竟然通过了鹅厂的所有面试。</p>\n<p>虽然已到年底，但是要是错过这么难得的机会，下次就不知道什么时候才能再通关了。</p>\n<p>所以，<strong>年后拿到年终再跳槽 vs 已到手的鹅厂 Offer，我选择了后者 😄</strong></p>\n<h2> 我的鹅厂面试</h2>\n<p>如本文标题所说，16 天通关五轮面试，第 17 天，我终于收到了期盼已久的鹅厂 Offer。</p>\n<p>做技术的同学，可能会对鹅厂的面试很好奇，他们都会问哪些问题呢？</p>\n<p>我应聘的是大数据开发（Java）岗位，接下来对我的面试做个梳理，也给想来鹅厂的同学们一个参考 😊</p>\n<blockquote>\n<p>几乎所有问题都能在网络上找到很详细的答案。<br>\n篇幅有限，这里只写题目和一些引申的问题。</p>\n</blockquote>\n<h3> 技术一面</h3>\n<h4> Java 语言相关</h4>\n<p>1、对 Java 的类加载器有没有了解？如何自定义类加载器？</p>\n<blockquote>\n<p>引申：一个类能被加载多次吗？<code>java/javax</code> 包下的类会被加载多次吗？</p>\n</blockquote>\n<p>2、Java 中要怎么创建一个对象 🐘？</p>\n<p>3、对多线程有了解吗？在什么场景下需要使用多线程？</p>\n<blockquote>\n<p>引申：对 <strong>线程安全</strong> 的认识；对线程池的了解，以及各个线程池的适用场景。</p>\n</blockquote>\n<p>4、对垃圾回收的了解？</p>\n<p>5、对 JVM 分代的了解？</p>\n<p>6、NIO 的了解？用过 RandomAccessFile 吗？</p>\n<blockquote>\n<p>引申：对 <strong>同步、异步，阻塞、非阻塞</strong> 的理解？</p>\n<p>多路复用 IO 的优势？</p>\n</blockquote>\n<p>7、ArrayList 和 LinkedList 的区别？各自的适用场景？</p>\n<p>8、实现一个 Hash 集合，需要考虑哪些因素？</p>\n<blockquote>\n<p>引申：JDK 对 HashMap 的设计关键点，比如初识容量，扩所容，链表转红黑树，以及 JDK 7 和 JDK 8 的区别等等。</p>\n</blockquote>\n<h4> 通用学科相关</h4>\n<p>1、TCP 的三次握手；</p>\n<p>2、Linux 的常用命令，比如：</p>\n<blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></blockquote>\n<h4> 项目框架相关</h4>\n<p>1、Kafka 和其他 MQ 的区别？它的吞吐量为什么高？</p>\n<blockquote>\n<p>消费者主动 pull 数据，目的是：控制消费节奏，还可以重复消费；</p>\n<p>吞吐量高：各 partition 顺序写 IO，批量刷新到磁盘（OS 的 pageCache 负责刷盘，Kafka 不用管），比随机 IO 快；读取数据基于 sendfile 的 Zero Copy；批量数据压缩……</p>\n</blockquote>\n<p>2、Hive 和 SparkSQL 的区别？</p>\n<p>3、Ranger 的权限模型、权限对象，鉴权过程，策略如何刷新……</p>\n<h4> 问题定位方法</h4>\n<p>1、ssh 连接失败，如何定位？</p>\n<blockquote>\n<p>是否能 ping 通（DNS 是否正确）、对端端口是否开了防火墙、对端服务是否正常……</p>\n</blockquote>\n<p>2、运行 Java 程序的服务器，CPU 使用率达到 100%，如何定位？</p>\n<blockquote>\n<p><code>ps aux | grep xxx</code> 或 <code>jps</code> 命令找到 Java 的进程号 <code>pid</code>，</p>\n<p>然后用 <code>top -Hp pid</code> 命令查看其阻塞的线程序号，<strong>将其转换为 16 进制</strong>；</p>\n<p>再通过 <code>jstack pid</code> 命令跟踪此 Java 进程的堆栈，搜索上述转换来的 16 进制线程号，即可找到对应的线程名及其堆栈信息……</p>\n</blockquote>\n<p>3、Java 程序发生了内存溢出，如何定位？</p>\n<blockquote>\n<p><code>jmap</code> 工具查看堆栈信息，看 Eden、Old 区的变化……</p>\n</blockquote>\n<h3> 技术二面</h3>\n<p>二面主要是过往项目相关的问题：</p>\n<p>1、Solr 和 Elasticsearch 的区别 / 优劣？</p>\n<p>2、对 Elasticsearch 的优化，它的索引过程，选主过程等问题……</p>\n<p>3、项目中遇到的难题，如何解决的？</p>\n<p>blabla 有少量的基础问题和一面有重复，还有几个和大数据相关的问题，记不太清了 😅</p>\n<h3> 技术三面</h3>\n<p>这一面是总监面，更多是个人关于职业发展的一些想法，以及在之前公司的成长和收获、对下一份工作的期望等问题。</p>\n<p>但也问了几个技术问题。印象比较深的是这个：</p>\n<blockquote>\n<p>1 个 1TB 的大文件，每行都只是 1 个数字，无重复，8GB 内存，要怎么对这个文件进行排序？</p>\n</blockquote>\n<p>首先想到的是 MapReduce 的思路，拆分小文件，分批排序，最后合并。</p>\n<p><strong>此时连环追问来了：</strong></p>\n<blockquote>\n<p>Q：如何尽可能多的利用内存呢？</p>\n<p>A：用位图法的思路，对数字按顺序映射。（对映射方法要有基本的了解）</p>\n<p>Q：如果在排好序之后，还需要快速查找呢？</p>\n<p>A：可以做索引，类似 Redis 的跳表，通过多级索引提高查找速度。</p>\n<p>Q：索引查找的还是文件。要如何才能更多地利用内存呢？</p>\n<p>A：那就要添加缓存了，把读取过的数字缓存到内存中。</p>\n<p>Q：缓存应该满足什么特点呢？</p>\n<p>A：应该使用 LRU 型的缓存。</p>\n</blockquote>\n<p>呼。。。总算是追问完了这道题 😂</p>\n<hr>\n<p>还有 GM 面和 HR 面，问题都和个人经历相关，这里就略去不表。</p>\n<h2> 文末的絮叨</h2>\n<p><strong>入职鹅厂已经 1 月有余。不同的岗位，不同的工作内容，也是不同的挑战。</strong></p>\n<p>感受比较深的是，作为程序员，还是要自我驱动，努力提升个人技术能力，横向纵向都要扩充，这样才能走得长远。</p>\n<figure><img src=\"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png\" alt=\"JavaGuide 官方公众号\" tabindex=\"0\"><figcaption>JavaGuide 官方公众号</figcaption></figure>\n",
      "image": "https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg",
      "date_published": "2022-07-04T11:20:20.000Z",
      "date_modified": "2023-10-26T22:44:02.000Z",
      "authors": [],
      "tags": [
        "技术文章精选集"
      ]
    }
  ]
}